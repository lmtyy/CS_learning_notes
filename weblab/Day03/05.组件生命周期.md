好的！我来详细讲讲React组件的生命周期。

## 什么是组件生命周期？

组件生命周期指的是组件从创建、更新到销毁的整个过程。在函数式组件中，**我们主要使用`useEffect`来管理生命周期**。

## 三个主要阶段

### 1. 挂载阶段（组件创建和显示）

组件第一次被渲染到页面时：

```jsx
import { useEffect, useState } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);
  
  console.log('1. 组件函数开始执行');
  
  // 挂载时的效果 - 只在组件创建时执行一次
  useEffect(() => {
    console.log('3. 组件已挂载到页面');
    
    // 通常在这里进行数据初始化
    fetchUserData();
  }, []); // 空依赖数组表示只在挂载时执行
  
  const fetchUserData = async () => {
    const userData = await fetch('/api/user');
    setUser(await userData.json());
  };
  
  console.log('2. 准备返回JSX');
  
  return (
    <div>
      <h1>用户信息</h1>
      {user && <p>欢迎, {user.name}</p>}
    </div>
  );
}
```

**执行顺序：**
```
1. 组件函数开始执行
2. 准备返回JSX  
3. 组件已挂载到页面
```

### 2. 更新阶段（组件重新渲染）

当组件的状态或属性发生变化时：

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  const [theme, setTheme] = useState('light');
  
  // 每次渲染都会执行
  useEffect(() => {
    console.log('组件重新渲染了');
  });
  
  // 只在count变化时执行
  useEffect(() => {
    console.log(`计数更新为: ${count}`);
    document.title = `计数: ${count}`;
  }, [count]); // 依赖count
  
  // 只在theme变化时执行  
  useEffect(() => {
    console.log(`主题变为: ${theme}`);
  }, [theme]); // 依赖theme
  
  return (
    <div>
      <p>计数: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
      <button onClick={() => setTheme('dark')}>切换主题</button>
    </div>
  );
}
```

**点击"增加"按钮时：**
```
组件重新渲染了
计数更新为: 1
```

**点击"切换主题"按钮时：**
```
组件重新渲染了  
主题变为: dark
```

### 3. 卸载阶段（组件从页面移除）

当组件不再需要显示时：

```jsx
function ToggleComponent() {
  const [showTimer, setShowTimer] = useState(true);
  
  return (
    <div>
      <button onClick={() => setShowTimer(!showTimer)}>
        {showTimer ? '隐藏计时器' : '显示计时器'}
      </button>
      {showTimer && <Timer />}
    </div>
  );
}

function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    console.log('计时器组件已挂载');
    
    // 设置定时器
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // 清理函数 - 在组件卸载时执行
    return () => {
      console.log('计时器组件即将卸载');
      clearInterval(interval); // 清除定时器
    };
  }, []);
  
  return <div>运行时间: {seconds}秒</div>;
}
```

**点击"隐藏计时器"时：**
```
计时器组件即将卸载
```

## ==useEffect 的三种使用方式==

### 方式1：每次渲染都执行
```jsx
useEffect(() => {
  // 每次组件渲染后都会执行
  console.log('组件渲染完成');
});
```

### 方式2：只在挂载时执行
```jsx
useEffect(() => {
  // 只在组件挂载时执行一次
  console.log('组件已挂载');
}, []); // 空依赖数组
```

### 方式3：在特定依赖变化时执行
```jsx
useEffect(() => {
  // 当count或name变化时执行
  console.log('count或name发生了变化');
}, [count, name]); // 依赖数组
```

## 实际应用场景

### 数据获取
```jsx
function ProductList({ category }) {
  const [products, setProducts] = useState([]);
  
  // 当category变化时重新获取数据
  useEffect(() => {
    const fetchProducts = async () => {
      const data = await fetch(`/api/products?category=${category}`);
      setProducts(await data.json());
    };
    
    fetchProducts();
  }, [category]); // 依赖category
  
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

### 事件监听和清理
```jsx
function ResizeListener() {
  const [width, setWidth] = useState(window.innerWidth);
  
  useEffect(() => {
    console.log('开始监听窗口大小变化');
    
    const handleResize = () => {
      setWidth(window.innerWidth);
    };
    
    window.addEventListener('resize', handleResize);
    
    // 清理函数：移除事件监听
    return () => {
      console.log('移除窗口大小监听');
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return <div>窗口宽度: {width}px</div>;
}
```

## 生命周期执行顺序总结

1. **挂载阶段**：
   - 执行组件函数
   - 渲染JSX
   - 执行useEffect（挂载后）

2. **更新阶段**：
   - 状态/属性变化
   - 重新执行组件函数
   - 重新渲染JSX
   - 执行相关useEffect（渲染后）

3. **卸载阶段**：
   - 执行useEffect的清理函数
   - 组件从DOM移除

理解组件生命周期很重要，因为它关系到：
- 什么时候初始化数据
- 什么时候清理资源
- 如何避免内存泄漏
- 如何优化性能