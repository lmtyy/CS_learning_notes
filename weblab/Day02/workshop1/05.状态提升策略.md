是的，**将父组件的 state 作为 props 传递给子组件**是 React 中非常常见和核心的策略，这被称为 **=="状态提升"（State Lifting）==** 或 **"单向数据流"**。

## 为什么这是常见策略？

### 1. 单一数据源
```jsx
// 父组件管理状态
function Parent() {
  const [count, setCount] = useState(0); // 单一数据源
  
  return (
    <div>
      <Child count={count} />
      <AnotherChild count={count} />
    </div>
  );
}

// 子组件只接收数据
function Child({ count }) {
  return <div>计数: {count}</div>;
}
```

### 2. ==数据向下，事件向上==
```jsx
function Parent() {
  const [user, setUser] = useState(null);
  
  // 状态更新逻辑保持在父组件
  const handleLogin = (userData) => {
    setUser(userData);
  };

  return (
    <div>
      <LoginForm onLogin={handleLogin} />
      <UserProfile user={user} />
    </div>
  );
}

function LoginForm({ onLogin }) {
  // 子组件触发事件，父组件处理状态
  return <button onClick={() => onLogin({ name: 'John' })}>登录</button>;
}
```

## 适用场景

### 1. ==共享状态==
```jsx
function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    <div className={theme}>
      <Header theme={theme} />
      <Content theme={theme} />
      <Footer theme={theme} onThemeChange={setTheme} />
    </div>
  );
}
```

### 2. 表单数据
```jsx
function FormPage() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: ''
  });
  
  return (
    <div>
      <PersonalInfo 
        data={formData} 
        onChange={setFormData} 
      />
      <ContactInfo 
        data={formData} 
        onChange={setFormData} 
      />
    </div>
  );
}
```

## 优点

1. **可预测性**：数据流向清晰，易于调试
2. **可维护性**：状态逻辑集中管理
3. **复用性**：子组件成为纯展示组件，更容易复用
4. **测试性**：子组件更容易测试（纯函数）

## 注意事项

- 避免 **prop drilling**（过多层级的 props 传递）
- 对于复杂应用，可以考虑使用 Context API 或状态管理库（Redux, Zustand）

**总结**：这是 React 官方推荐的核心模式，是构建可维护 React 应用的基础。