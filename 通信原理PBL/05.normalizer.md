归一化（Normalization）的原理非常简单，但它是数字音频处理中最重要的一步，尤其是在做完一堆加法运算（加噪声、失真）之后。

简单来说，它的原理就是：**找最大值，算比例，整体缩放。**

### 1. 为什么需要归一器？

在数字音频中，音量的最大限度是 **1.0 (或 0 dB)**。
*   如果有任何一个采样点的数值超过 `1.0`（比如变成 `1.5`），当你播放时，电脑声卡无法输出比最大值还大的电压，它会直接把 `1.5` 砍成 `1.0`。
*   这种“砍平”波峰的现象叫做 **“硬削波 (Hard Clipping)”**。
*   **听觉结果**：产生非常难听的破音、撕裂声。

当你在项目中通过 `audio + noise` 加上白噪声时，原本已经是 `0.9` 的信号可能会变成 `0.9 + 0.2 = 1.1`，这就导致了破音。

### 2. 数学步骤 (Step-by-Step)

`Normalizer` 类的 `process` 方法其实只做了三件事：

**第一步：找最大值 (Peak Detection)**
遍历整个音频矩阵，找到绝对值最大的那个点。
$$ \text{MaxVal} = \max(|x_1|, |x_2|, ..., |x_n|) $$

**第二步：计算增益因子 (Gain Calculation)**
假设我们需要把最大音量限制在 `-1.0 dB`（留一点安全余量，对应线性幅度约 `0.89`）。
$$ \text{Factor} = \frac{\text{目标幅度}}{\text{MaxVal}} $$

**第三步：应用增益 (Apply Gain)**
把音频里的每一个点都乘以这个因子。
$$ y_i = x_i \times \text{Factor} $$

---

### 3. 代码对应

让我们回头看 `effects/normalizer.py` 中的代码：

```python
class Normalizer(AudioEffect):
    def process(self, audio, samplerate):
        # 1. 找最大值 (NumPy 极速运算)
        max_val = np.max(np.abs(audio))
        
        # 2. 如果是静音文件(全0)，就不处理，防止除以0
        if max_val > 0:
            # 3. 计算因子并乘上去
            # 假设 target_factor 是 0.89 (-1dB)
            # audio * (0.89 / max_val)
            return audio / max_val * self.target_factor
            
        return audio
```

**举个例子：**
1.  你有一个音频，最大峰值是 `2.0`（严重爆音）。
2.  你想限制在 `1.0`。
3.  归一器算出因子：Factor = $1.0 / 2.0 = 0.5$。
4.  整个音频所有声音变小一半，最大的峰值刚好落在 `1.0`，破音消失，细节保留。