这个现象展示了 SQL 中一个非常重要且容易被误解的概念：**当 SELECT 子句中同时包含聚合函数和非聚合列时**的行为。

## 现象分析

你的查询结果：
```sql
select max(weight), kind from animals;  -- 返回: 12000|t-rex
select min(weight), kind from animals;  -- 返回: 6|parrot
```

这看起来好像 `max(weight)` 对应了 `t-rex`，`min(weight)` 对应了 `parrot`，但实际上**这是一种巧合，而不是有意义的对应关系**。

## 根本原因

### 1. 缺少 GROUP BY 子句

当你在 SELECT 中同时使用聚合函数（如 `MAX`, `MIN`, `SUM`, `AVG`）和非聚合列（如 `kind`），但**没有使用 GROUP BY** 时，SQL 的行为是：

- **聚合函数**：对整个表进行计算，返回单个值
- **非聚合列**：从**任意一行**中返回一个值（具体哪一行取决于数据库实现）

### 2. 数据库的实际处理

大多数数据库（包括 SQLite）在这种情况下：
1. 计算聚合函数（如 `MAX(weight)`），得到 `12000`
2. 从表中**任意选择一行**的 `kind` 值来搭配这个聚合结果
3. 返回这个"随机"的组合

## 示例数据推测

根据你的结果，`animals` 表可能包含类似这样的数据：

| weight | kind    |
|--------|---------|
| 12000  | t-rex   |
| 8000   | elephant|
| 200    | lion    |
| 6      | parrot  |
| 15     | cat     |

## 为什么会出现这种结果？

### 对于 `MAX(weight)`：
- 数据库找到最大重量 `12000`
- 然后它需要返回一个 `kind` 值
- 它发现有一行的 `weight` 正好是 `12000`，对应的 `kind` 是 `t-rex`
- 于是返回 `12000|t-rex`

### 对于 `MIN(weight)`：
- 数据库找到最小重量 `6`
- 然后它需要返回一个 `kind` 值
- 它发现有一行的 `weight` 正好是 `6`，对应的 `kind` 是 `parrot`
- 于是返回 `6|parrot`

## 这是危险的行为！

这种查询方式**在逻辑上是错误的**，因为它暗示 `t-rex` 的重量是 `12000`（这可能是对的），但也暗示其他动物的重量信息与这个最大值无关（这是误导性的）。

## 正确的写法

### 1. 如果你想要最大重量对应的动物种类：

```sql
SELECT weight, kind
FROM animals
WHERE weight = (SELECT MAX(weight) FROM animals);
```

或者：

```sql
SELECT weight, kind
FROM animals
ORDER BY weight DESC
LIMIT 1;
```

### 2. 如果你想要每个种类的最大重量：

```sql
SELECT kind, MAX(weight) as max_weight
FROM animals
GROUP BY kind;
```

### 3. 如果你只是想要最大重量值（不需要种类信息）：

```sql
SELECT MAX(weight) FROM animals;
```

## 为什么数据库允许这种语法？

SQL 标准允许这种语法主要是为了：
1. **历史原因**：早期 SQL 实现的行为
2. **灵活性**：在某些简单情况下可能有用
3. **性能**：避免严格的语法检查开销

但**这是一个糟糕的实践**，应该避免使用。

## 总结

- **你的查询在语法上是有效的**，但在逻辑上是错误的
- **返回的结果是巧合**，不是有意义的对应关系
- **永远不要**在同一个 SELECT 中混合聚合列和非聚合列而不使用 GROUP BY
- **使用明确的查询**来表达你真正的意图

这种查询就像是在问："世界上最高的人是谁？顺便告诉我一个随机的人的名字。" - 数据库会给出最高身高，然后随便配一个名字，这两者之间可能完全没有关系！