这是一个非常好的问题！它触及了 SQL 的核心运作机制。

**简短回答：SQL 表达式可以评估列，也可以评估行，这完全取决于上下文和使用场景。**

让我们详细分解一下：

---

### 一、在 SELECT 子句中：评估列（但按行处理）

当表达式在 `SELECT` 子句中时，它**按行进行评估，但产生的是列结果**。

```sql
SELECT name, salary, salary * 1.1 AS increased_salary
FROM employees;
```

在这里：
- `salary * 1.1` 这个表达式会**对每一行**的 salary 值进行计算
- 但最终结果是创建一个新的**列** `increased_salary`
- **本质**：逐行计算，列式输出

**执行过程可视化：**

| 行号 | name | salary | 计算过程 | increased_salary |
|------|------|--------|----------|------------------|
| 1 | Alice | 5000 | 5000 × 1.1 | 5500 |
| 2 | Bob | 6000 | 6000 × 1.1 | 6600 |
| 3 | Charlie | 4500 | 4500 × 1.1 | 4950 |

---

### 二、在 WHERE 子句中：评估行

当表达式在 `WHERE` 子句中时，它**按行进行评估，用于过滤行**。

```sql
SELECT name, salary
FROM employees
WHERE salary > 5000 AND department = 'Sales';
```

在这里：
- `salary > 5000 AND department = 'Sales'` 对**每一行**进行评估
- 只有使表达式为 TRUE 的行才会被保留
- **本质**：逐行评估，行式过滤

---

### 三、聚合函数：评估列（多行→单值）

聚合函数对**整个列或多个行的值**进行操作，返回单个值。

```sql
SELECT 
    AVG(salary) AS avg_salary,      -- 评估整个salary列
    MAX(salary) AS max_salary,      -- 评估整个salary列  
    COUNT(*) AS total_employees     -- 评估所有行
FROM employees;
```

**本质**：多行输入，单值输出

---

### 四、与 GROUP BY 结合：评估组

当与 `GROUP BY` 结合时，表达式**按组进行评估**。

```sql
SELECT 
    department,
    AVG(salary) AS avg_salary  -- 对每个部门的salary列进行评估
FROM employees
GROUP BY department;
```

**本质**：分组评估，每组产生一个结果

---

### 五、总结对比

| 上下文 | 评估对象 | 结果 | 示例 |
|--------|----------|------|------|
| **SELECT 子句** | 行 → 列 | 新列 | `SELECT price * quantity AS total` |
| **WHERE 子句** | 行 | 过滤的行 | `WHERE age > 18` |
| **聚合函数** | 列 → 单值 | 汇总值 | `AVG(salary)` |
| **GROUP BY** | 组 → 单值 | 每组的汇总值 | `GROUP BY department, AVG(salary)` |
| **HAVING 子句** | 组 | 过滤的组 | `HAVING AVG(salary) > 50000` |

### 六、关键理解点

1.  **SQL 是声明式的**：你描述"想要什么"，而不是"如何做"
2.  **数据库优化器决定执行方式**：虽然逻辑上是逐行处理，但实际执行时数据库可能使用向量化处理等优化技术
3.  **思维转换**：从"循环遍历每一行"的过程式思维，转变为"对整个数据集操作"的声明式思维

### 七、一个综合示例

```sql
SELECT 
    department,                           -- 列引用
    COUNT(*) AS employee_count,           -- 聚合：多行→单值（按组）
    AVG(salary) * 1.1 AS budgeted_avg,    -- 表达式：先聚合，再逐行计算
    MAX(salary) AS highest_salary         -- 聚合：多行→单值
FROM employees
WHERE salary > 30000                      -- 逐行评估过滤
GROUP BY department                       -- 分组
HAVING AVG(salary) > 50000                -- 按组评估过滤
ORDER BY budgeted_avg DESC;               -- 按列排序
```

**在这个查询中：**
- `WHERE salary > 30000`：逐行评估
- `AVG(salary)`：按组评估列
- `AVG(salary) * 1.1`：先按组聚合，然后对聚合结果逐"组"计算
- `budgeted_avg`：在 `ORDER BY` 中引用的是结果列

所以，回答你的问题：**SQL 表达式既评估列也评估行，取决于它所在的上下文**。这种灵活性正是 SQL 强大之处！