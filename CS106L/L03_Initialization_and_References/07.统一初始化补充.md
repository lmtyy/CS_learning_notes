您说得完全正确！这是一个非常敏锐的观察。您发现了问题的关键所在。

## 问题根源分析

您指出的完全正确：**直接列表初始化语法 `Type{args...}` 只能在变量定义（初始化）时使用，不能用于赋值**。

### 1. **定义时的初始化** - ✅ 正确
```cpp
Edge dd{1, 2, 3};  // 正确：在定义变量时使用列表初始化
```

### 2. **赋值时的初始化** - ❌ 错误
```cpp
edges[i] {a, b, c};  // 错误：这是在赋值，不是定义
```

## 正确的语法对比

### ✅ 正确的用法（在定义时）
```cpp
// 全局变量定义时初始化
Edge global_edge{1, 2, 3};

// 局部变量定义时初始化
Edge local_edge{4, 5, 6};

// 函数参数传递
void processEdge(Edge e);
processEdge(Edge{7, 8, 9});  // 正确：创建临时对象

// 返回值
Edge createEdge() {
    return Edge{10, 11, 12};  // 正确：返回临时对象
}
```

### ❌ 错误的用法（在赋值时）
```cpp
Edge existing_edge;
existing_edge{1, 2, 3};  // 错误：不能对已存在对象使用列表初始化

edges[i] {a, b, c};      // 错误：edges[i] 已经存在
```

## 修复方案

### 方案1：使用赋值列表初始化 (推荐)
```cpp
edges[i] = {a, b, c};  // 正确：使用赋值和初始化列表
```

### 方案2：逐个成员赋值
```cpp
edges[i].a = a;
edges[i].b = b;
edges[i].w = c;
```

### 方案3：使用构造函数
```cpp
// 在结构体中添加构造函数
struct Edge {
    int a, b, w;
    
    Edge(int _a, int _b, int _w) : a(_a), b(_b), w(_w) {}
    
    bool operator<(const Edge& edge) const {
        return w < edge.w;
    }
};

// 然后使用
edges[i] = Edge(a, b, c);
```

## 完整的正确代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 100010, M = N * 2;

struct Edge
{
    int a, b, w;
    
    bool operator<(const Edge& edge) const
    {
        return w < edge.w;
    }
} edges[M];

int n, m;
int p[N];

int find(int x)
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    // 正确：定义时的列表初始化
    Edge dd{1, 2, 3};
    
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        
        // 正确：赋值时的列表初始化
        edges[i] = {a, b, c};
    }
    
    return 0;
}
```

## 语言规则的深层理解

这个区别体现了C++的一个重要设计原则：
- **初始化**：创建对象并赋予初始值
- **赋值**：修改已存在对象的值

`Type{args...}` 语法是用于**初始化**的，而 `edges[i]` 已经是一个存在的对象，您是在进行**赋值**操作。

## 其他类似的语法区别

这种初始化/赋值的区别也存在于其他场景：

```cpp
// 初始化 - 正确
std::vector<int> v{1, 2, 3};

// 赋值 - 错误
std::vector<int> v;
v{1, 2, 3};  // 错误

// 赋值 - 正确
v = {1, 2, 3};
```

您对这个细节的观察非常准确！这确实是C++语法中一个容易混淆但很重要的区别。