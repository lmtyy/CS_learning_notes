这是一个非常关键的问题，也是滑动窗口协议中一个容易混淆的重点。

**正确答案是：对于选择重传协议，最大窗口大小 \( W_{max} = 2^{n-1} \)。**

---

### 详细解释：为什么是 \( 2^{n-1} \) 而不是 \( 2^n - 1 \)？

这个更严格的规定是为了避免在一种特定场景下出现**致命的序号歧义**。这种歧义在接收窗口 \( W_R > 1 \) 时才会出现。

#### 让我们来看一个反例：

假设序号字段 \( n = 2 \) 位，那么序号范围是 0, 1, 2, 3。
如果我们错误地将窗口大小设置为 \( 2^n - 1 = 3 \)。

1.  **初始状态**：
    - 发送窗口和接收窗口都覆盖 [0, 1, 2]。发送方发送帧0,1,2。
    - 接收方正确接收了帧0,1,2，它的窗口向前滑动，现在覆盖 [3, 0, 1]。它期待接收新一轮的帧3,0,1。

2.  **出现问题**：
    - 现在，对第一轮帧0,1,2的**所有确认（ACK0, ACK1, ACK2）都在网络中丢失了**。
    - 发送方超时，并**重传**旧的帧0,1,2。

3.  **致命的歧义**：
    - 接收方此时收到了一个序号为0的帧。
    - 接收方无法判断：
        - **情况A**：这是**旧的、第一轮**的帧0的重传？（应该丢弃，因为已经上交过）
        - **情况B**：这是**新的、第二轮**的帧0的首次发送？（应该接收并缓存）

**因为接收窗口覆盖了新旧两轮中的相同序号（0和1），导致接收方完全无法区分帧的新旧，协议失败。**

---

### 解决方案：将最大窗口大小减半

为了解决这个问题，选择重传协议强制要求：
**发送窗口大小 \( W_T \) ≤ \( 2^{n-1} \)**
**接收窗口大小 \( W_R \) ≤ \( 2^{n-1} \)**

这样，接收窗口的大小最多只有序号空间的一半。这就确保了**新旧两轮的发送窗口永远不会出现重叠**，从而彻底避免了上述的歧义问题。

在上面的例子中，如果 \( n=2 \)，那么 \( W_{max} = 2^{2-1} = 2 \)。接收方的窗口在任何时候都只能覆盖2个序号，从而与上一轮的窗口错开，不会包含完全相同的序号集合。

### 总结与对比

| 协议 | 接收窗口大小 \( W_R \) | **最大允许窗口大小 \( W_{max} \)** | 原因 |
| :--- | :--- | :--- | :--- |
| **回退N帧** | 1 | \( 2^n - 1 \) | 防止“新旧一轮序号完全重合” |
| **选择重传** | **> 1** | \( 2^{n-1} \) | 防止“新旧一轮序号**部分重叠**”导致的歧义 |

所以，你的记忆是正确的。对于**选择重传ARQ协议**，其最大窗口大小的约束比回退N帧更严格，为 **\( W_{max} = 2^{n-1} \)**。这是一个至关重要的设计要点。