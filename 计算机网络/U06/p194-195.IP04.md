这两张图详细讲解了 IP 协议中一个非常硬核的数学机制——**首部校验和 (Header Checksum)** 的计算过程。

这也是考试中计算题的热门考点（虽然通常不会让你手算二进制，但原理必考）。它的核心目的是**确保“快递单（首部）”在传输过程中没有坏掉**。

我结合这两张图，分**发送方 (Sender)** 和 **接收方 (Receiver)** 两个视角为你讲解：

### 1. 核心算法规则 (图 image_cc7e52.png)

这张图定义了游戏的规则，听起来有点拗口，但其实就三步：

1. **切分**：把 IP 首部看成是一堆 **16位 (16-bit)** 的整数序列。
2. **求和**：用 **“反码算术运算 (One's complement arithmetic)”** 把它们全部加起来。
3. **取反**：把算出来的结果**取反 (Complement)**，得到的数就是校验和。

> **什么是“反码算术”？** 简单理解就是：做加法时，如果最高位产生了进位（溢出），要把这个进位**加回到最低位去**，而不是直接丢掉。

---

### 2. 发送方怎么做？(图 image_cc7e4c.jpg 左半部分)

看左边的流程，这是一个“填空”的过程：

1. **挖坑 (Set to 0)**：
* 发送方先把 IP 首部里的 **Checksum 字段暂时填为 0**。


2. **切块求和**：
* 把整个首部（包括那个是 0 的 Checksum 字段）按 16 位一切，分成 `word 1`, `word 2` ... `word n`。
* 把它们全部加起来。


3. **取反填坑**：
* 得到的结果取反码（比如算出 `1010`，取反就是 `0101`）。
* 把这个值填入 Checksum 字段，然后把包发出去。



---

### 3. 接收方怎么做？(图 image_cc7e4c.jpg 右半部分)

看右边的流程，这是一个“验货”的过程：

1. **照单全收**：
* 接收方收到包后，首部里的 Checksum 字段已经是发送方填好的那个数了（不再是 0）。


2. **再次求和**：
* 接收方把首部里所有的 16 位整数（包括 Checksum）再加一遍。


3. **见证奇迹 (Verification)**：
* **原理**：因为 `原数 + 原数的反码 = 全是1`。
* **判断**：如果算出来的结果是 **全 1 (1111...1111)**（在反码逻辑中对应 0），说明首部是完好无损的。
* 如果结果不是全 1？说明传输路上出错了，路由器会毫不留情地把这个包**丢弃 (Discard)**。



### 💡 总结与考点

* **为什么只校验首部？**
* 因为路由器每转发一次，**TTL (生存时间)** 都会减 1。这意味着**首部是变化的**，所以每经过一个路由器，Checksum 都要重新计算一次。
* 如果还要校验数据部分（Data），路由器的计算压力就太大了。数据的校验留给终点的 TCP/UDP 去做。


* **流程记忆**：
* 发送方：**求和 -> 取反 -> 填入**。
* 接收方：**求和 -> 检查是否全 1**。