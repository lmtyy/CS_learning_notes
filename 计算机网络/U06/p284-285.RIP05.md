这两页新课件（`image_e2b421.jpg` 和 `image_e2b441.jpg`）通过一个具体的**时延（Delay）计算案例**，展示了路由器 J 如何根据邻居传来的矢量信息更新自己的路由表。

这部分内容是**距离矢量路由（Distance Vector Routing）**在实际应用中的核心计算逻辑。

---

### 1. 场景背景与已知条件

* **当前节点**：路由器 **J**。
* **邻居节点**：J 有四个邻居，分别是 **A、I、H、K**。
* **测量到的时延**：J 到这四个邻居的链路时延分别为：
* 
* 
* 
* 



### 2. 收到邻居的矢量更新 (Vectors received)

课件中的四个列表分别代表 A、I、H、K 告诉 J 的信息，即“从它们自己出发到达全网各节点（A 到 L）所需的时延”。

### 3. J 如何计算并生成新路由表

J 的更新原则非常简单：**计算经过每一个邻居到达目的地的总时延，然后选最小的那一个。**

**计算公式：**


#### **具体案例演示：**

* **目标：到达节点 B**
* 经 A：
* 经 I：
* 经 H：
* 经 K：
* **结果**：最小值是 **20**，所以 J 决定去 B 要**经过 A**。


* **目标：到达节点 D**
* 经 A：
* 经 I：
* 经 H：
* 经 K：
* **结果**：最小值是 **20**，所以 J 决定去 D 要**经过 H**。


* **目标：到达节点 G**
* 经 A：
* 经 I：
* 经 H：
* 经 K：
* **结果**：最小值是 **18**，所以 J 决定去 G 要**经过 H**。



---

### 4. 最终路由表条目 (Routing Table for J)

根据上述逻辑，J 生成了完整的路由表：

* **Destination (目的地)**：网络中的每一个节点。
* **Metric (度量值)**：计算出的最小总时延。
* **Next hop (下一跳)**：提供这个最小总时延的那个邻居。

### 💡 核心知识点总结

1. **Metric 的灵活性**：之前的课件讲的是“跳数 (Hops)”，这里展示的是“时延 (Delay)”。距离矢量算法可以根据不同的 Metric 进行选路。
2. **分布式计算**：J 不需要知道全网的拓扑结构，它只需要相信邻居给它的数据，并加上自己到邻居的那一段距离即可。
3. **考试技巧**：做这种题时，先在邻居给出的矢量表下方写上 J 到它们的初始距离（8, 10, 12, 6），然后每一行做加法对比最小值，这样不容易出错。

你想尝试自己计算一下去往节点 **L** 的过程吗？它可以帮你检验是否完全掌握了这一页的逻辑。