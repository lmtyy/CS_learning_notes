这七页课件（从 image_1c5f4a 到 image_1c5fc2）带我们进入了 TCP 协议的核心使命之一：**差错控制（Error Control）**。

在不稳定的互联网中，数据包可能会坏、会丢、会重、会乱。TCP 必须像一个“强迫症”质检员一样，确保交给应用层的数据绝对完美。

---

### 1. 差错控制的三大工具 (image_1c5f4a)

TCP 主要依靠三个简单的工具来实现差错检测和纠正：

* **校验和 (Checksum)**：检测数据在传输中是否发生了位错误（变质）。
* **确认 (Acknowledgment)**：接收方收到数据后必须给个回馈，证明“我拿到了”。
* **超时 (Time-out)**：发送方如果等太久没收到确认，就认为出事了。
* **纠错手段**：一旦发现问题，TCP 唯一的手段就是**重传该段 (Retransmit the segment)**。

### 2. 差错的五种典型场景 (image_1c5f64)

这页课件列举了网络中可能出现的五种“意外”：

1. **差错 (Corrupted)**：数据变样了。
2. **丢失 (Lost)**：数据在路上消失了。
3. **重复 (Duplicate)**：同一个包收到了两次。
4. **乱序 (Out-of-order)**：后发的包先到了。
5. **应答丢失 (Lost ACK)**：数据到了，但回传的确认信丢了。

---

### 3. 场景解析：TCP 是如何应对的？

#### A. 差错/损坏 (image_1c5f6a)

* **现象**：数据包到达，但经过**校验和 (Checksum)** 计算发现内容被篡改或损坏。
* **对策**：接收方直接**丢弃 (Discard)** 该包，且不发确认。发送方**超时 (Time-out)** 后自动重传。

#### B. 丢失 (image_1c5f86)

* **现象**：`Seq:1601` 的包在网络拥堵中被路由器丢弃了。
* **对策**：发送方启动定时器，时间一到还没收到 `ack:1801`，就重新发送 `Seq:1601`。

#### C. 重复 (image_1c5fa0)

* **现象**：发送方以为包丢了（超时），重传了 `Seq:1401`，结果其实之前的包只是绕路了，导致接收方收到了两个 `1401`。
* **对策**：接收方根据序列号发现重复，直接**丢弃 (Discard)** 掉多出来的那个，确保应用层只拿到一份数据。

#### D. 乱序 (image_1c5fa6)

* **现象**：`Seq:1401` 晚到了，而 `Seq:1601` 却先到了。
* **对策**：接收方暂时**缓存**这些乱序的包，等缺掉的 `1401` 到达后，再按正确的顺序拼装好交给应用层。

#### E. 应答丢失 (image_1c5fc2)

* **现象**：数据 `Seq:1601` 已经送达，但回传的 `ack:1801` 丢了。
* **对策**：发送方还是会**超时重传**。接收方收到重复数据后，会再次发送 `ack:1801`，直到发送方收到确认并停止重传。

---

### 🎓 核心笔记：定时器的重要性

你会发现，在所有丢包或差错的场景下，**“超时 (Time-out)”** 都是触发重传的终极底牌。

* 如果定时器设得**太短**：网络稍微一延迟就会导致大量没必要的重传，浪费带宽。
* 如果定时器设得**太长**：真丢包了也要等半天，用户会觉得网络很卡。

所以，TCP 还会动态计算往返时间（RTT）来调整这个定时器。

**你想了解一下 TCP 是如何根据网络状况，“聪明地”设置这个超时时间的吗？（即 7.3.8 定时器管理）**