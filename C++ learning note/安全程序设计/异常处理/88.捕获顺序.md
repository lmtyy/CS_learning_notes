**捕获顺序（Catch Ordering）** 在 C++ 异常处理中至关重要，因为它决定了哪个 `catch` 块会处理抛出的异常。编译器按照 `catch` 块的书写顺序进行匹配，第一个匹配的块会被执行。

## 1. 基本捕获顺序规则

### 基础示例

```cpp
#include <iostream>
#include <stdexcept>

class BaseException : public std::exception {
public:
    const char* what() const noexcept override {
        return "BaseException";
    }
};

class DerivedException : public BaseException {
public:
    const char* what() const noexcept override {
        return "DerivedException";
    }
};

class AnotherException : public std::exception {
public:
    const char* what() const noexcept override {
        return "AnotherException";
    }
};

// 正确的捕获顺序
void correctOrder() {
    try {
        throw DerivedException();
    }
    catch (const DerivedException& e) {  // 1. 最具体的先捕获
        std::cout << "Caught Derived: " << e.what() << std::endl;
    }
    catch (const BaseException& e) {     // 2. 然后基类
        std::cout << "Caught Base: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {    // 3. 然后更通用的
        std::cout << "Caught std::exception: " << e.what() << std::endl;
    }
    catch (...) {                        // 4. 最后捕获所有
        std::cout << "Caught unknown exception" << std::endl;
    }
}
```

## 2. 错误的捕获顺序及后果

### 问题演示

```cpp
// 错误的捕获顺序 - 派生类永远无法被捕获
void wrongOrder() {
    try {
        throw DerivedException();
    }
    catch (const BaseException& e) {     // 这个会先匹配！
        std::cout << "Caught Base: " << e.what() << std::endl;
    }
    catch (const DerivedException& e) {  // 永远不会执行！
        std::cout << "Caught Derived: " << e.what() << std::endl;
    }
}

// 编译器警告
void demonstrateCompilerWarning() {
    try {
        throw DerivedException();
    }
    catch (const BaseException& e) {
        std::cout << "Base caught" << std::endl;
    }
    catch (const DerivedException& e) { 
        // 很多编译器会警告：此代码不可达
        std::cout << "Derived caught" << std::endl;
    }
}
```

## 3. 复杂继承层次的捕获顺序

### 多级继承示例

```cpp
class Level1Exception : public std::exception {
public:
    const char* what() const noexcept override {
        return "Level1Exception";
    }
};

class Level2Exception : public Level1Exception {
public:
    const char* what() const noexcept override {
        return "Level2Exception";
    }
};

class Level3Exception : public Level2Exception {
public:
    const char* what() const noexcept override {
        return "Level3Exception";
    }
};

class UnrelatedException : public std::exception {
public:
    const char* what() const noexcept override {
        return "UnrelatedException";
    }
};

void complexHierarchyOrder() {
    try {
        throw Level3Exception();
    }
    catch (const Level3Exception& e) {       // 1. 最底层派生类
        std::cout << "Level3: " << e.what() << std::endl;
    }
    catch (const Level2Exception& e) {       // 2. 中间层
        std::cout << "Level2: " << e.what() << std::endl;
    }
    catch (const Level1Exception& e) {       // 3. 直接基类
        std::cout << "Level1: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {        // 4. 标准异常基类
        std::cout << "std::exception: " << e.what() << std::endl;
    }
    catch (...) {                            // 5. 捕获所有
        std::cout << "Unknown" << std::endl;
    }
}
```

## 4. 标准库异常的捕获顺序

### 标准异常层次结构

```cpp
#include <stdexcept>
#include <iostream>

void standardExceptionOrder() {
    try {
        // 可能抛出各种标准异常
        throw std::out_of_range("Index out of range");
    }
    catch (const std::out_of_range& e) {         // 1. 最具体的标准异常
        std::cout << "out_of_range: " << e.what() << std::endl;
    }
    catch (const std::runtime_error& e) {        // 2. 运行时错误类别
        std::cout << "runtime_error: " << e.what() << std::endl;
    }
    catch (const std::logic_error& e) {          // 3. 逻辑错误类别
        std::cout << "logic_error: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {            // 4. 所有标准异常
        std::cout << "std::exception: " << e.what() << std::endl;
    }
    catch (...) {                                // 5. 非标准异常
        std::cout << "Non-standard exception" << std::endl;
    }
}
```

## 5. 混合类型的捕获顺序

### 处理不同类型异常的排序

```cpp
void mixedTypeOrder() {
    try {
        // 可能抛出多种类型的异常
        throw "C-style string exception";
    }
    catch (const std::string& e) {           // 1. std::string
        std::cout << "std::string: " << e << std::endl;
    }
    catch (const char* e) {                  // 2. C风格字符串
        std::cout << "const char*: " << e << std::endl;
    }
    catch (int error_code) {                 // 3. 整数错误码
        std::cout << "Error code: " << error_code << std::endl;
    }
    catch (double value) {                   // 4. 浮点数
        std::cout << "Double: " << value << std::endl;
    }
    catch (const std::exception& e) {        // 5. 标准异常
        std::cout << "std::exception: " << e.what() << std::endl;
    }
    catch (...) {                            // 6. 其他所有
        std::cout << "Unknown type" << std::endl;
    }
}
```

## 6. 模板和捕获顺序

### 模板函数中的异常捕获

```cpp
#include <typeinfo>

template<typename T>
void processValue(const T& value) {
    try {
        // 模板相关的操作可能抛出各种异常
        if (sizeof(T) > 100) {
            throw std::bad_alloc();
        }
        throw T(value);  // 抛出类型相关的异常
    }
    catch (const T& e) {                    // 1. 特定类型异常
        std::cout << "Type-specific: " << typeid(T).name() << std::endl;
    }
    catch (const std::bad_alloc& e) {       // 2. 内存错误
        std::cout << "Memory error: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {       // 3. 标准异常
        std::cout << "Standard: " << e.what() << std::endl;
    }
    catch (...) {                           // 4. 其他
        std::cout << "Unknown in template" << std::endl;
    }
}
```

## 7. 实际项目中的最佳实践

### 模块化异常处理

```cpp
class DatabaseException : public std::runtime_error {
public:
    DatabaseException(const std::string& msg) : std::runtime_error(msg) {}
};

class NetworkException : public std::runtime_error {
public:
    NetworkException(const std::string& msg) : std::runtime_error(msg) {}
};

class FileSystemException : public std::runtime_error {
public:
    FileSystemException(const std::string& msg) : std::runtime_error(msg) {}
};

void handleApplicationExceptions() {
    try {
        // 应用逻辑...
        throw DatabaseException("Connection failed");
    }
    // 应用特定异常
    catch (const DatabaseException& e) {
        std::cout << "Database: " << e.what() << std::endl;
        // 重试逻辑、回滚等
    }
    catch (const NetworkException& e) {
        std::cout << "Network: " << e.what() << std::endl;
        // 网络重连逻辑
    }
    catch (const FileSystemException& e) {
        std::cout << "FileSystem: " << e.what() << std::endl;
        // 文件系统恢复逻辑
    }
    // 标准异常
    catch (const std::runtime_error& e) {
        std::cout << "Runtime: " << e.what() << std::endl;
        // 通用运行时错误处理
    }
    catch (const std::logic_error& e) {
        std::cout << "Logic: " << e.what() << std::endl;
        // 程序逻辑错误，可能需要终止
    }
    catch (const std::exception& e) {
        std::cout << "General: " << e.what() << std::endl;
        // 通用错误处理
    }
    catch (...) {
        std::cout << "Unexpected error" << std::endl;
        // 紧急恢复或终止
        std::terminate();
    }
}
```

## 8. 调试和测试捕获顺序

### 验证捕获顺序的工具函数

```cpp
#include <iostream>
#include <typeinfo>

template<typename ExceptionType>
void testCatchOrder(const std::string& expected) {
    try {
        throw ExceptionType();
    }
    catch (const DerivedException& e) {
        std::cout << "DerivedException caught - ";
    }
    catch (const BaseException& e) {
        std::cout << "BaseException caught - ";
    }
    catch (const std::exception& e) {
        std::cout << "std::exception caught - ";
    }
    catch (...) {
        std::cout << "Unknown caught - ";
    }
    std::cout << "Expected: " << expected << std::endl;
}

void verifyCatchOrder() {
    std::cout << "Testing catch order:\n";
    testCatchOrder<DerivedException>("DerivedException");
    testCatchOrder<BaseException>("BaseException");
    testCatchOrder<std::runtime_error>("std::exception");
}
```

## 9. 常见陷阱和解决方案

### 陷阱1：基类捕获块太早

```cpp
// 错误：基类在派生类之前
void problematic() {
    try {
        throw DerivedException();
    }
    catch (const BaseException& e) {    // 错误顺序！
        // 处理...
    }
    catch (const DerivedException& e) { // 不可达！
        // 永远不会执行
    }
}

// 修正：重新排序
void corrected() {
    try {
        throw DerivedException();
    }
    catch (const DerivedException& e) { // 正确顺序
        // 特定处理
    }
    catch (const BaseException& e) {    // 通用处理
        // 后备处理
    }
}
```

### 陷阱2：重复的捕获条件

```cpp
void duplicateConditions() {
    try {
        throw DerivedException();
    }
    catch (const BaseException& e) {        // 匹配所有派生类
        std::cout << "Base or derived" << std::endl;
    }
    catch (const DerivedException& e) {     // 重复且不可达！
        std::cout << "This is unreachable!" << std::endl;
    }
}
```

## 总结

**捕获顺序的核心原则**：

1. **从具体到通用**：最派生的类 → 基类 → 通用异常 → catch-all
2. **按书写顺序匹配**：编译器严格按代码顺序尝试匹配
3. **第一个匹配获胜**：找到第一个匹配的 catch 块后停止搜索
4. **不可达代码**：顺序错误的 catch 块会产生编译器警告

**最佳实践**：
- 总是先捕获最具体的异常类型
- 将 `catch (...)` 放在最后
- 定期检查编译器警告，修复不可达的 catch 块
- 在复杂项目中建立一致的异常处理策略

正确的捕获顺序确保了异常能够被最合适的处理程序捕获，是编写健壮异常处理代码的基础。