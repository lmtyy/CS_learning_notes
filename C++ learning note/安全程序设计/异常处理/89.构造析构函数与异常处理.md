异常处理与构造/析构函数的交互是 C++ 异常安全的核心问题。理解这些交互对于编写健壮的代码至关重要。

## 1. 构造函数中的异常

### 基本行为

当构造函数中抛出异常时：
- 对象构造被视为失败
- **析构函数不会被调用**
- 已构造的成员变量会被正确销毁

```cpp
#include <iostream>
#include <stdexcept>

class Member {
public:
    Member(int id) : id(id) {
        std::cout << "Member " << id << " constructed\n";
    }
    ~Member() {
        std::cout << "Member " << id << " destroyed\n";
    }
private:
    int id;
};

class TestClass {
private:
    Member m1;
    Member m2;
    int* dynamic_data;
    
public:
    TestClass() : m1(1), m2(2), dynamic_data(new int[100]) {
        std::cout << "TestClass constructor started\n";
        
        // 模拟构造函数中途失败
        throw std::runtime_error("Construction failed!");
        
        // 以下代码不会执行
        std::cout << "TestClass constructor completed\n";
    }
    
    ~TestClass() {
        std::cout << "TestClass destructor called\n";
        delete[] dynamic_data;
    }
};

void testConstructorException() {
    try {
        TestClass obj;  // 构造函数抛出异常
        std::cout << "Object created successfully\n";
    }
    catch (const std::exception& e) {
        std::cout << "Caught: " << e.what() << std::endl;
        // 输出显示成员被销毁，但析构函数没调用
    }
}
```

**输出：**
```
Member 1 constructed
Member 2 constructed
TestClass constructor started
Member 2 destroyed
Member 1 destroyed
Caught: Construction failed!
```

### 资源泄漏问题

```cpp
class DangerousClass {
private:
    int* resource1;
    int* resource2;
    
public:
    DangerousClass() {
        resource1 = new int[100];  // 分配资源
        resource2 = new int[200];  // 分配更多资源
        
        throw std::runtime_error("Oops!");  // 构造函数失败
        
        // 资源泄漏！没有机会释放 resource1 和 resource2
    }
    
    ~DangerousClass() {
        delete[] resource1;
        delete[] resource2;
    }
};
```

## 2. 使用 RAII 解决构造函数异常

### 智能指针和 RAII 类

```cpp
#include <memory>
#include <vector>

class SafeClass {
private:
    std::unique_ptr<int[]> resource1;  // 自动管理内存
    std::vector<int> resource2;        // 自动管理内存
    std::string name;
    
public:
    SafeClass(const std::string& n) : name(n) {
        std::cout << "SafeClass constructor for " << name << "\n";
        
        resource1 = std::make_unique<int[]>(100);
        resource2.resize(1000);
        
        // 即使这里抛出异常，资源也会自动释放
        if (name.empty()) {
            throw std::invalid_argument("Name cannot be empty");
        }
        
        std::cout << "SafeClass " << name << " fully constructed\n";
    }
    
    ~SafeClass() {
        std::cout << "SafeClass " << name << " destroyed\n";
        // 不需要手动释放资源！
    }
};

void testSafeConstructor() {
    try {
        SafeClass safe("test");
        SafeClass unsafe("");  // 抛出异常
    }
    catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }
}
```

## 3. 析构函数中的异常

### 析构函数异常的危险性

```cpp
#include <iostream>

class DangerousDestructor {
public:
    ~DangerousDestructor() noexcept(false) {
        std::cout << "Destructor doing cleanup...\n";
        
        // 危险：在析构函数中抛出异常！
        throw std::runtime_error("Error in destructor!");
        
        std::cout << "Cleanup completed\n";
    }
};

void testDangerousDestructor() {
    try {
        DangerousDestructor obj;
        // obj 离开作用域时析构函数被调用
    }
    catch (const std::exception& e) {
        // 在 C++11 之前，这会调用 std::terminate()
        // 在 C++11 之后，如果异常没有在析构函数内捕获，仍然会终止程序
        std::cout << "Caught: " << e.what() << std::endl;
    }
}
```

### 正确处理析构函数中的错误

```cpp
#include <fstream>

class FileHandler {
private:
    std::ofstream file;
    
public:
    FileHandler(const std::string& filename) : file(filename) {
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file: " + filename);
        }
    }
    
    ~FileHandler() noexcept {
        try {
            if (file.is_open()) {
                file.close();
                // 关闭文件可能失败，但我们不能抛出异常
            }
        }
        catch (const std::exception& e) {
            // 记录错误，但不抛出异常
            std::cerr << "Warning: Failed to close file properly: " 
                      << e.what() << std::endl;
        }
        catch (...) {
            std::cerr << "Warning: Unknown error during file closure" << std::endl;
        }
    }
    
    void write(const std::string& data) {
        file << data;
        if (file.fail()) {
            throw std::runtime_error("Write failed");
        }
    }
};
```

## 4. 异常安全保证级别

### 三种异常安全级别

```cpp
#include <vector>
#include <algorithm>

class ExceptionSafeContainer {
private:
    std::vector<int> data;
    
public:
    // 1. 基本保证 - 不泄漏资源，对象处于有效状态
    void basicGuarantee(int value) {
        data.push_back(value);  // 可能抛出 bad_alloc
        // 如果失败，data 保持原有状态
    }
    
    // 2. 强保证 - 操作要么成功，要么保持原状态
    void strongGuarantee(int value) {
        std::vector<int> new_data = data;  // 先拷贝
        new_data.push_back(value);         // 修改拷贝
        
        // 如果上面成功，再交换（不会抛出异常）
        data.swap(new_data);
    }
    
    // 3. 不抛保证 - 操作保证不会抛出异常
    void noThrowGuarantee() noexcept {
        // 只调用不抛出异常的操作
        if (!data.empty()) {
            data.pop_back();  // std::vector::pop_back() 不抛出
        }
    }
    
    // 拷贝赋值运算符 - 提供强保证
    ExceptionSafeContainer& operator=(const ExceptionSafeContainer& other) {
        if (this != &other) {
            // 拷贝并交换惯用法 (copy-and-swap idiom)
            ExceptionSafeContainer temp(other);  // 可能抛出
            swap(temp);                          // 不抛出
        }
        return *this;
    }
    
    void swap(ExceptionSafeContainer& other) noexcept {
        data.swap(other.data);
    }
};
```

## 5. 成员初始化和异常

### 成员初始化列表中的异常

```cpp
class Resource {
public:
    Resource(const std::string& name) {
        if (name.empty()) {
            throw std::invalid_argument("Resource name cannot be empty");
        }
        std::cout << "Resource " << name << " created\n";
    }
    ~Resource() {
        std::cout << "Resource destroyed\n";
    }
};

class ComplexClass {
private:
    Resource res1;
    Resource res2;
    std::unique_ptr<int[]> data;
    
public:
    ComplexClass(const std::string& name1, const std::string& name2) 
        : res1(name1),      // 如果这里抛出异常，res2 和 data 不会被构造
          res2(name2),      // 如果这里抛出异常，res1 会被销毁，data 不会被构造
          data(new int[100]) // 如果这里抛出异常，res1 和 res2 会被销毁
    {
        std::cout << "ComplexClass fully constructed\n";
    }
    
    ~ComplexClass() {
        std::cout << "ComplexClass destroyed\n";
    }
};

void testMemberInitialization() {
    try {
        ComplexClass obj("valid", "");  // res2 构造失败
    }
    catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }
}
```

## 6. 继承体系中的构造和析构

### 基类和派生类的异常交互

```cpp
class Base {
public:
    Base() {
        std::cout << "Base constructor\n";
        // 基类构造函数可以抛出异常
    }
    
    virtual ~Base() {
        std::cout << "Base destructor\n";
        // 基类析构函数不应该抛出异常
    }
};

class Derived : public Base {
private:
    std::vector<int> data;
    
public:
    Derived(int size) : data(size) {
        std::cout << "Derived constructor\n";
        
        if (size < 0) {
            throw std::invalid_argument("Size cannot be negative");
        }
    }
    
    ~Derived() override {
        std::cout << "Derived destructor\n";
    }
};

void testInheritance() {
    try {
        Derived obj(-1);  // 派生类构造函数抛出异常
    }
    catch (const std::exception& e) {
        std::cout << "Caught: " << e.what() << std::endl;
        // 输出显示基类析构函数被调用！
    }
}
```

## 7. 函数 try 块

### 构造函数函数 try 块

```cpp
class FunctionTryBlock {
private:
    std::unique_ptr<int[]> data;
    std::string name;
    
public:
    // 构造函数函数 try 块
    FunctionTryBlock(const std::string& n, size_t size) 
    try  // 注意语法
        : name(n), data(std::make_unique<int[]>(size))
    {
        std::cout << "Constructing " << name << "\n";
        if (name.empty()) {
            throw std::invalid_argument("Name cannot be empty");
        }
    }
    catch (const std::exception& e) {
        // 这里可以记录日志，但异常会自动重新抛出
        std::cerr << "Construction failed: " << e.what() << std::endl;
        // 异常会继续传播！
    }
    
    // 析构函数函数 try 块
    ~FunctionTryBlock() 
    try {
        std::cout << "Destroying " << name << "\n";
        // 清理代码
    }
    catch (const std::exception& e) {
        // 必须在这里处理所有异常！
        std::cerr << "Destruction error: " << e.what() << std::endl;
        // 不能抛出异常！
    }
};

void testFunctionTryBlock() {
    try {
        FunctionTryBlock obj("", 100);  // 会触发构造函数异常
    }
    catch (const std::exception& e) {
        std::cout << "Main caught: " << e.what() << std::endl;
    }
}
```

## 8. 最佳实践总结

### 构造函数最佳实践

```cpp
class WellDesignedClass {
private:
    std::unique_ptr<Resource> resource1;  // RAII 成员
    std::shared_ptr<Resource> resource2;  // RAII 成员
    std::vector<int> data;                // RAII 成员
    
public:
    // 提供强异常安全的构造函数
    WellDesignedClass(const std::string& res1_name, 
                      const std::string& res2_name,
                      const std::vector<int>& initial_data)
        : resource1(std::make_unique<Resource>(res1_name))
        , resource2(std::make_shared<Resource>(res2_name))
        , data(initial_data)  // 拷贝，可能抛出
    {
        // 所有初始化在初始化列表中完成
        // 如果任何操作失败，已构造的成员会自动销毁
    }
    
    // 两阶段初始化 - 替代方案
    void initialize(const std::string& config) {
        // 可以抛出异常，但对象已构造
        if (config.empty()) {
            throw std::invalid_argument("Config cannot be empty");
        }
    }
    
    ~WellDesignedClass() noexcept {
        // 只包含不抛出异常的操作
        // 或者捕获所有异常
        try {
            // 清理代码
        }
        catch (...) {
            // 记录错误，不传播异常
        }
    }
};
```

### 关键要点

1. **构造函数异常**：对象构造失败，析构函数不会被调用
2. **使用 RAII**：让资源管理类处理异常时的清理工作
3. **析构函数不抛异常**：使用 `noexcept`，在内部捕获所有异常
4. **初始化列表**：按声明顺序初始化，按相反顺序销毁
5. **异常安全保证**：根据需求提供基本、强或不抛保证
6. **函数 try 块**：用于记录错误，但不能阻止异常传播

理解这些交互关系是编写异常安全 C++ 代码的基础。