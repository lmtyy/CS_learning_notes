C++ 的异常处理机制提供了一种结构化的方式来处理程序运行时可能出现的错误。以下是 C++ 异常处理的详细介绍：

## 异常处理的基本组件

### 1. 抛出异常 - `throw`
```cpp
double divide(double a, double b) {
    if (b == 0) {
        throw "Division by zero!";  // 抛出字符串异常
    }
    return a / b;
}

class MathError {
private:
    string message;
public:
    MathError(const string& msg) : message(msg) {}
    string what() const { return message; }
};

double sqrt(double x) {
    if (x < 0) {
        throw MathError("Negative number!");  // 抛出对象异常
    }
    return std::sqrt(x);
}
```

### 2. 捕获异常 - `try-catch`
```cpp
try {
    // 可能抛出异常的代码
    double result = divide(10, 0);
    cout << "Result: " << result << endl;
}
catch (const char* error_msg) {
    // 捕获字符串异常
    cerr << "Error: " << error_msg << endl;
}
catch (const MathError& e) {
    // 捕获自定义异常
    cerr << "Math Error: " << e.what() << endl;
}
catch (...) {
    // 捕获所有其他异常
    cerr << "Unknown error occurred!" << endl;
}
```

## 标准异常类

C++ 标准库提供了一系列异常类，都继承自 `std::exception`：

```cpp
#include <stdexcept>
#include <iostream>

void processNumber(int num) {
    try {
        if (num < 0) {
            throw std::invalid_argument("Number cannot be negative");
        }
        if (num > 100) {
            throw std::out_of_range("Number too large");
        }
        cout << "Processing: " << num << endl;
    }
    catch (const std::exception& e) {
        // 捕获所有标准异常
        cerr << "Standard exception: " << e.what() << endl;
    }
}

// 使用标准异常
void example() {
    try {
        throw std::runtime_error("Something went wrong!");
    }
    catch (const std::logic_error& e) {
        // 逻辑错误（invalid_argument, out_of_range, length_error等）
    }
    catch (const std::runtime_error& e) {
        // 运行时错误（range_error, overflow_error, underflow_error等）
    }
    catch (const std::exception& e) {
        // 所有标准异常的基类
        cout << e.what() << endl;
    }
}
```

## 函数异常规范

### 1. `noexcept` 说明符
```cpp
// 该函数保证不会抛出异常
void safeFunction() noexcept {
    // 如果这里抛出异常，程序会调用 std::terminate()
}

// 条件性的 noexcept
template<typename T>
void swap(T& a, T& b) noexcept(noexcept(T(std::move(a))) && 
                               noexcept(a.~T())) {
    // 实现...
}
```

### 2. 动态异常规范（已弃用）
```cpp
// C++11 之前的方式，现在不推荐使用
void oldFunction() throw(std::exception);  // 只能抛出 std::exception
void noThrowFunction() throw();           // 不抛出任何异常
```

## 自定义异常类

```cpp
#include <exception>
#include <string>

class MyException : public std::exception {
private:
    std::string message;
    int errorCode;
    
public:
    MyException(const std::string& msg, int code = 0) 
        : message(msg), errorCode(code) {}
    
    // 重写 what() 方法
    const char* what() const noexcept override {
        return message.c_str();
    }
    
    int getErrorCode() const {
        return errorCode;
    }
};

// 使用自定义异常
void businessLogic() {
    bool errorCondition = true;
    
    if (errorCondition) {
        throw MyException("Business logic failed", 1001);
    }
}

int main() {
    try {
        businessLogic();
    }
    catch (const MyException& e) {
        cerr << "Error " << e.getErrorCode() << ": " << e.what() << endl;
    }
    return 0;
}
```

## 异常处理的最佳实践

### 1. 按特定顺序捕获异常
```cpp
try {
    // 可能抛出多种异常
}
catch (const DerivedException& e) {
    // 先捕获派生类异常
}
catch (const BaseException& e) {
    // 再捕获基类异常
}
catch (...) {
    // 最后捕获所有其他异常
}
```

### 2. 资源管理 - RAII
```cpp
class FileHandler {
private:
    FILE* file;
public:
    FileHandler(const char* filename) : file(fopen(filename, "r")) {
        if (!file) {
            throw std::runtime_error("Failed to open file");
        }
    }
    
    ~FileHandler() {
        if (file) {
            fclose(file);
        }
    }
    
    // 禁止拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};

void useFile() {
    FileHandler fh("data.txt");  // 自动资源管理
    // 使用文件，如果抛出异常，fh 的析构函数会自动关闭文件
}
```

### 3. 重新抛出异常
```cpp
void process() {
    try {
        // 某些操作
    }
    catch (const std::exception& e) {
        // 记录日志或其他处理
        std::cout << "Log: " << e.what() << std::endl;
        // 重新抛出异常
        throw;
    }
}
```

## 异常安全保证

1. **基本保证**：不会资源泄漏，对象处于有效状态
2. **强保证**：操作要么成功，要么保持原状态（事务性）
3. **不抛保证**：操作保证不会抛出异常

```cpp
// 强保证示例
class StrongGuaranteeExample {
    vector<int> data;
public:
    void addValue(int value) {
        vector<int> newData = data;  // 先拷贝
        newData.push_back(value);    // 修改拷贝
        
        // 如果这里抛出异常，原 data 不受影响
        data.swap(newData);          // 原子性交换
    }
};
```

## 异常处理的优点和注意事项

### 优点：
- 将错误处理代码与正常逻辑分离
- 异常不能忽略，必须被处理
- 支持错误信息的传递
- 自动调用析构函数进行资源清理

### 注意事项：
- 异常处理有性能开销
- 不要在析构函数中抛出异常
- 避免在构造函数中抛出异常导致资源泄漏
- 谨慎使用 catch-all (`catch(...)`)

C++ 异常处理提供了一种强大而灵活的错误处理机制，正确使用可以大大提高程序的健壮性和可维护性。