**对象切片（Object Slicing）** 是 C++ 中的一个常见问题，发生在将派生类对象赋值给基类对象时，派生类特有的成员会被"切掉"，只保留基类的部分。

## 1. 基本概念

### 问题演示

```cpp
#include <iostream>
#include <string>

class Base {
public:
    int base_data;
    
    Base(int value = 0) : base_data(value) {}
    
    virtual void display() const {
        std::cout << "Base: " << base_data << std::endl;
    }
    
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    std::string derived_data;  // 派生类特有的成员
    
    Derived(int value, const std::string& str) 
        : Base(value), derived_data(str) {}
    
    void display() const override {
        std::cout << "Derived: " << base_data << ", " << derived_data << std::endl;
    }
    
    void specialMethod() const {
        std::cout << "Special: " << derived_data << std::endl;
    }
};

void demonstrateSlicing() {
    Derived derived_obj(42, "Hello World");
    
    // 对象切片发生在这里！
    Base base_obj = derived_obj;  // 只拷贝了 Base 部分
    
    std::cout << "Original Derived object:" << std::endl;
    derived_obj.display();  // 输出: Derived: 42, Hello World
    
    std::cout << "After slicing:" << std::endl;
    base_obj.display();     // 输出: Base: 42 （丢失了派生类信息）
    
    // derived_data 被切掉了！
    // base_obj.derived_data  // 错误！不存在
    // base_obj.specialMethod()  // 错误！不存在
}
```

## 2. 切片发生的场景

### 场景1：值赋值

```cpp
void assignmentSlicing() {
    Derived derived(100, "Important Data");
    Base base;
    
    base = derived;  // 切片！只复制了 Base 部分
    base.display();  // 只能看到 Base 的行为
}
```

### 场景2：函数参数传值

```cpp
// 按值接收参数 - 会导致切片！
void processByValue(Base obj) {
    obj.display();  // 总是调用 Base::display()
}

// 按引用接收参数 - 安全！
void processByReference(const Base& obj) {
    obj.display();  // 多态调用，正确！
}

void testFunctionCalls() {
    Derived derived(200, "Polymorphic Data");
    
    std::cout << "By value (slicing occurs):" << std::endl;
    processByValue(derived);  // 切片！丢失派生类信息
    
    std::cout << "By reference (polymorphism works):" << std::endl;
    processByReference(derived);  // 正确！保持多态
}
```

### 场景3：异常抛出和捕获（特别重要！）

```cpp
void exceptionSlicingExample() {
    try {
        Derived derived_exception(404, "File not found");
        
        // 错误：按值抛出导致切片
        throw derived_exception;  // 创建副本时发生切片！
        
    } catch (const Base& e) {
        e.display();  // 只能看到 Base 的行为！
    }
}

void correctExceptionHandling() {
    try {
        // 正确：直接抛出临时对象
        throw Derived(500, "Server error");  // 无切片！
        
    } catch (const Base& e) {
        e.display();  // 多态调用，正确显示 Derived 信息
    }
}
```

## 3. 切片的具体影响

### 数据成员丢失

```cpp
class Animal {
public:
    std::string type;
    Animal(const std::string& t) : type(t) {}
};

class Dog : public Animal {
public:
    std::string breed;  // 派生类特有数据
    Dog(const std::string& t, const std::string& b) : Animal(t), breed(b) {}
};

void dataMemberSlicing() {
    Dog dog("Canine", "Golden Retriever");
    Animal animal = dog;  // 切片！
    
    std::cout << "Dog: " << dog.type << ", " << dog.breed << std::endl;
    // 输出: Dog: Canine, Golden Retriever
    
    std::cout << "Animal: " << animal.type << std::endl;
    // 输出: Animal: Canine
    // breed 数据被切掉了！
}
```

### 虚函数表失效

```cpp
class Shape {
public:
    virtual double area() const {
        std::cout << "Shape area" << std::endl;
        return 0;
    }
    virtual ~Shape() = default;
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    
    double area() const override {
        std::cout << "Circle area: " << 3.14159 * radius * radius << std::endl;
        return 3.14159 * radius * radius;
    }
};

void vtableSlicing() {
    Circle circle(5.0);
    Shape shape = circle;  // 切片！
    
    std::cout << "Original Circle:" << std::endl;
    circle.area();  // 输出: Circle area: 78.5397
    
    std::cout << "After slicing:" << std::endl;
    shape.area();   // 输出: Shape area - 虚函数表被重置！
}
```

## 4. 如何避免对象切片

### 解决方案1：使用指针或引用

```cpp
void avoidSlicingWithPointers() {
    Derived* derived_ptr = new Derived(1, "Pointer");
    Base* base_ptr = derived_ptr;  // 无切片！
    
    base_ptr->display();  // 正确调用 Derived::display()
    delete derived_ptr;
}

void avoidSlicingWithReferences() {
    Derived derived(2, "Reference");
    Base& base_ref = derived;  // 无切片！
    
    base_ref.display();  // 正确调用 Derived::display()
}

void avoidSlicingWithSmartPointers() {
    auto derived = std::make_unique<Derived>(3, "Smart Pointer");
    std::unique_ptr<Base> base = std::move(derived);  // 无切片！
    
    base->display();  // 正确调用 Derived::display()
}
```

### 解决方案2：使用 clone 模式

```cpp
class CloneableBase {
public:
    int base_value;
    
    CloneableBase(int value = 0) : base_value(value) {}
    virtual ~CloneableBase() = default;
    
    // 克隆接口
    virtual std::unique_ptr<CloneableBase> clone() const {
        return std::make_unique<CloneableBase>(*this);
    }
    
    virtual void show() const {
        std::cout << "Base: " << base_value << std::endl;
    }
};

class CloneableDerived : public CloneableBase {
public:
    std::string derived_value;
    
    CloneableDerived(int base_val, const std::string& derived_val)
        : CloneableBase(base_val), derived_value(derived_val) {}
    
    std::unique_ptr<CloneableBase> clone() const override {
        return std::make_unique<CloneableDerived>(*this);
    }
    
    void show() const override {
        std::cout << "Derived: " << base_value << ", " << derived_value << std::endl;
    }
};

void useClonePattern() {
    CloneableDerived original(100, "Original");
    auto copy = original.clone();  // 正确复制整个对象
    
    original.show();  // Derived: 100, Original
    copy->show();     // Derived: 100, Original - 无切片！
}
```

## 5. 实际应用中的注意事项

### 在容器中避免切片

```cpp
#include <vector>
#include <memory>

void containerSlicing() {
    std::vector<Base> bad_vector;  // 会导致切片！
    bad_vector.push_back(Derived(1, "Data1"));  // 切片！
    bad_vector.push_back(Derived(2, "Data2"));  // 切片！
    
    for (const auto& obj : bad_vector) {
        obj.display();  // 总是 Base::display()
    }
}

void correctContainerUsage() {
    std::vector<std::unique_ptr<Base>> good_vector;  // 使用智能指针
    good_vector.push_back(std::make_unique<Derived>(1, "Data1"));
    good_vector.push_back(std::make_unique<Derived>(2, "Data2"));
    
    for (const auto& ptr : good_vector) {
        ptr->display();  // 正确调用 Derived::display()
    }
}
```

### 在函数返回时避免切片

```cpp
// 错误：返回基类对象会导致切片
Base createSlicedObject() {
    Derived derived(999, "Return Value");
    return derived;  // 切片！
}

// 正确：返回智能指针
std::unique_ptr<Base> createCorrectObject() {
    return std::make_unique<Derived>(999, "Return Value");  // 无切片
}
```

## 总结

**对象切片问题的核心**：当派生类对象被赋值给基类对象时，编译器只复制基类部分的内存，派生类特有的数据成员和虚函数表信息都会丢失。

**关键预防措施**：
1. **使用指针或引用**而不是值传递/赋值
2. **在异常处理中**直接抛出临时对象
3. **在容器中**使用智能指针而不是直接存储对象
4. **考虑使用 Clone 模式**进行多态复制

理解对象切片对于编写正确的面向对象 C++ 代码至关重要，特别是在涉及多态和异常处理的场景中。