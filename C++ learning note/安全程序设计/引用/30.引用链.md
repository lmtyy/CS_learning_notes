是的，**完全合法**。

这段代码做了以下几件事：

1.  `int a = 10;` - 创建了一个整型变量 `a` 并初始化为 `10`
2.  `int& b = a;` - 创建了一个引用 `b`，它**绑定到**变量 `a`（`b` 是 `a` 的别名）
3.  `int& c = b;` - 创建了一个引用 `c`，它**绑定到**引用 `b` 所引用的对象，也就是变量 `a`

## 关键理解

**引用本身不是对象**，它只是另一个对象的别名。当你写 `int& c = b;` 时，你不是在让 `c` 引用 `b` 这个"引用"，而是在让 `c` 引用 `b` 所引用的那个原始对象（即 `a`）。

## 验证代码

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int& b = a;  // b 是 a 的引用
    int& c = b;  // c 是 b 的引用，实际上也是 a 的引用
    
    cout << "a: " << a << ", &a: " << &a << endl;
    cout << "b: " << b << ", &b: " << &b << endl;  
    cout << "c: " << c << ", &c: " << &c << endl;
    
    // 修改任意一个，所有都会改变
    a = 20;
    cout << "After changing a to 20:" << endl;
    cout << "a: " << a << ", b: " << b << ", c: " << c << endl;
    
    c = 30;
    cout << "After changing c to 30:" << endl;
    cout << "a: " << a << ", b: " << b << ", c: " << c << endl;
    
    return 0;
}
```

## 输出结果：
```
a: 10, &a: 0x7ffd2d5a5a4c
b: 10, &b: 0x7ffd2d5a5a4c  // 地址与 a 相同
c: 10, &c: 0x7ffd2d5a5a4c  // 地址与 a 相同

After changing a to 20:
a: 20, b: 20, c: 20

After changing c to 30:
a: 30, b: 30, c: 30
```

## 重要结论：

1.  **`b` 和 `c` 都是 `a` 的别名**，它们共享相同的内存地址
2.  **通过任何一个引用修改值，都会影响所有相关的变量**
3.  **引用链是允许的**，最终都指向最初的原始对象
4.  **这不同于指针**：如果是指针，你需要解引用才能访问值，但引用会自动"穿透"到最终的对象

这种引用链在C++中是合法且常见的用法，特别是在函数参数传递和返回值优化中经常出现。