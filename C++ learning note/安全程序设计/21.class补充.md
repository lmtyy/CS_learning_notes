**完全不是！** 这是一个非常常见的误解。

使用了 `class` 关键字，**你仍然可以传入任何数据类型**，包括基本数据类型（如 `int`, `double`, `char`）、枚举、结构体等。`class` 在这里只是一个历史遗留的语法符号，并不限制实际传入的类型。

### 示例证明

```cpp
#include <iostream>
using namespace std;

// 使用 class 关键字声明模板
template <class T>
T add(T a, T b) {
    return a + b;
}

// 使用 class 关键字的类模板
template <class T>
class Container {
private:
    T value;
public:
    Container(T v) : value(v) {}
    void print() { cout << value << endl; }
};

int main() {
    // 1. 传入基本数据类型 - 完全没问题！
    cout << add(5, 3) << endl;        // T = int，输出 8
    cout << add(3.14, 2.71) << endl;  // T = double，输出 5.85
    
    // 2. 传入结构体（不是类）
    struct Point { int x; int y; };
    Point p1 = {1, 2}, p2 = {3, 4};
    // 注意：这里需要为 Point 重载 + 运算符才能编译
    // cout << add(p1, p2) << endl; 
    
    // 3. 使用类模板
    Container<int> intContainer(42);     // T = int
    Container<double> doubleContainer(3.14); // T = double
    Container<char> charContainer('A');  // T = char
    
    intContainer.print();    // 输出 42
    doubleContainer.print(); // 输出 3.14
    charContainer.print();   // 输出 A
    
    return 0;
}
```

### 为什么会有这种混淆？

这种混淆来源于 `class` 关键字在 C++ 中的**多重角色**：

1.  **定义类**：`class MyClass { ... };`（这是主要的含义）
2.  **模板参数声明**：`template <class T>`（这是历史遗留的语法选择）

在模板的上下文中，`class T` 的准确含义是：**"T 是一个类型的占位符"**，而不是 "T 必须是一个类"。

### 历史原因

在模板刚被引入 C++ 时，只使用了 `class` 关键字。后来人们发现这会造成语义上的混淆（因为确实可以传入非类类型），所以在 C++98 之后的标准中引入了 `typename` 关键字作为替代，使其意图更加清晰。

```cpp
// 历史写法（仍然有效）
template <class T>

// 现代推荐写法（更清晰）
template <typename T>
```

### 结论

-   **`template <class T>`**：可以传入**任何类型**（类、结构体、基本类型等）
-   **`template <typename T>`**：也可以传入**任何类型**，并且语义上更准确

**最佳实践**：为了代码清晰性和可读性，**推荐始终使用 `typename`**，这样就不会让阅读代码的人产生您刚才那样的疑惑。