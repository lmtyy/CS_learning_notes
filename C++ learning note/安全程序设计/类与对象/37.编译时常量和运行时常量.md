好的，我们来详细讲解一下 C++ 中的编译时常量和运行时常量。这是理解 C++ 性能、元编程和语言特性的一个重要基础。

核心区别在于：**值是在编译阶段就被计算确定，还是在程序运行时才被计算确定**。

---

### 1. 编译时常量

编译时常量指的是，其值在**代码编译期间**就已经被编译器完全确定并固化在二进制文件中的常量。因为值在编译期已知，编译器可以利用这个特性进行大量优化（如直接内联替换、参与编译期计算、用于模板元编程等）。

#### 主要特点和例子：

**a. `constexpr` 变量 (C++11 引入)**
这是定义编译时常量的**现代、首选方式**。`constexpr` 明确告诉编译器，这个变量必须在编译期就可求值。

```cpp
constexpr int max_size = 100; // 编译时常量
constexpr double pi = 3.1415926535;

// 数组大小、模板参数等需要编译期常量的地方，都可以使用
int arr[max_size];
std::array<int, max_size> my_array;
```

**b. `const` 初始化的原始字面量或常量表达式**
在某些简单情况下，用 `const` 定义的变量也可能成为编译时常量，但这并非绝对保证，取决于初始化表达式。

```cpp
const int buffer_size = 1024; // 通常会被编译器视为编译时常量
const char* const greeting = "Hello, World!"; // 指针和指向的内容都是常量

// 可以用于数组大小（在C++中，数组大小必须是编译期常量）
int another_array[buffer_size];
```

**c. 枚举值**
枚举项的值在编译期是确定的。

```cpp
enum Colors { RED = 0xFF0000, GREEN = 0x00FF00, BLUE = 0x0000FF };
// RED, GREEN, BLUE 都是编译时常量
```

**d. 模板参数**
传递给模板的参数必须是编译期可知的。

```cpp
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};
// 模板特化
template<>
struct Factorial<0> {
    static const int value = 1;
};

// 调用 Factorial<5>::value 会在编译期计算出 120
```

**编译器对编译时常量的优化：**
当编译器遇到 `int x = max_size * 2;` 时，它不会生成任何乘法指令。它会直接计算 `100 * 2 = 200`，然后将指令变为 `int x = 200;`，就像你直接写了 200 一样。这就是**常量传播**优化。

---

### 2. 运行时常量

运行时常量指的是，其值只有在**程序运行起来之后**才能被确定的常量。虽然它的值在初始化后不可改变（是常量），但为了得到这个初始值，需要在运行时进行计算或读取。

#### 主要特点和例子：

**a. `const` 变量，但其初始值在运行时才能确定**
这是运行时常量最典型的例子。

```cpp
int get_user_input() {
    int x;
    std::cin >> x;
    return x;
}

int main() {
    const int user_value = get_user_input(); // 运行时常量！
    // user_value 的值在编译期完全未知，只有在运行时从用户输入获取后才知道。
    // 但一旦初始化，它的值就不能再改变了。

    // int arr[user_value]; // 错误！user_value 不是编译期常量，不能用作数组大小
    return 0;
}
```

**b. 函数参数中的 `const` 值**
函数参数在调用时才会被传递，因此它必然是运行时的。

```cpp
void process_data(const std::size_t size) { // size 是一个运行时常量
    // 在函数内部，size 的值是固定的（常量），但这个值来自函数外部的调用者，
    // 只有在运行时才知道。
    // std::array<int, size> arr; // 错误！size 不是编译期常量
    std::vector<int> vec(size); // 正确！vector 的大小可以在运行时确定
}
```

**运行时常量的“常量性”：**
运行时常量的“不变”是由编译器在**编译时通过语法检查来保证**的。编译器会阻止任何在代码中显式修改该变量的企图。但它不涉及编译期的优化计算。

---

### 对比总结表

| 特性 | 编译时常量 | 运行时常量 |
| :--- | :--- | :--- |
| **确定时间** | **编译期** | **运行期** |
| **关键字** | `constexpr`, `consteval` (C++20), `const` (有时) | `const` |
| **可用场景** | 数组大小、模板参数、`case` 标签、位域长度等 | 任何需要初始化后不变，但初值在运行时才知道的场景 |
| **优化** | **强力优化**：常量传播、直接内联、消除死代码 | **无特殊优化**，仅保证值不变 |
| **例子** | `constexpr int sz = 10; int arr[sz];` | `const int x = std::rand();` |

---

### 进阶：`const` 的模糊性与 `constexpr` 的必要性

在 C++11 之前，`const` 身兼两职，它既可以表示编译时常量，也可以表示运行时常量，这完全取决于其初始化表达式。这给程序员和编译器都带来了歧义。

`constexpr` 的引入**解决了这个歧义**：
*   **`constexpr`**：我**保证**这是一个编译时常量，请放心地用于需要编译期值的地方，并尽情优化。
*   **`const`**：我只是一个运行时**只读**的变量，别修改我就行。我可能是编译时常量，也可能不是（别指望我一定是）。

**现代 C++ 最佳实践：**
*   如果你需要一个**真正的编译期常量**，总是优先使用 **`constexpr`**。
*   如果你只需要一个在运行时初始化后**不再改变**的变量，使用 **`const`**。

### `consteval` (C++20)

C++20 进一步引入了 `consteval` 关键字，用于指定函数**必须**在编译期求值，产生一个编译时常量。如果无法在编译期求值，则会导致编译错误。它比 `constexpr` 函数的要求更严格。

```cpp
consteval int compile_time_square(int n) {
    return n * n;
}

constexpr int x = compile_time_square(5); // OK，编译期计算
// int y = compile_time_square(std::rand()); // 错误！参数不是常量，无法在编译期计算
```

### 总结

*   **编译时常量**：值在**编译时**已知，用于优化和需要编译期值的语境。用 **`constexpr`** 定义。
*   **运行时常量**：值在**运行时**才知，但初始化后不变。用 **`const`** 定义。
*   理解两者的区别对于编写高效、正确的 C++ 代码至关重要，尤其是在使用模板、容器和进行元编程时。