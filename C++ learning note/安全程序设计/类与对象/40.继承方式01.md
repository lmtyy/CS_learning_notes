好的，我们来详细讲解一下 C++ 中的三种继承方式：`public`、`protected` 和 `private`。

这三种继承方式的核心功能是**控制从基类继承而来的成员在派生类中的访问权限**。它们就像是三个不同严格程度的“过滤器”，决定了基类的`public`和`protected`成员到了派生类会变成什么样子。

---

### 1. 基础知识回顾：类成员的访问权限

在理解继承之前，必须先清楚类自身的访问限定符：

*   **`public` (公有成员)：** 类内部、外部代码（如`main`函数）都可以访问。
*   **`protected` (保护成员)：** 类内部和它的**派生类内部**可以访问，外部代码不能访问。
*   **`private` (私有成员)：** 只有**类内部**可以访问，派生类和外部代码都不能访问。**无论以何种方式继承，基类的 `private` 成员在派生类中都是不可见的**（虽然它确实被继承了，占用内存，但不能直接访问）。

---

### 2. 三种继承方式的作用规则

继承的语法是：`class Derived : [inheritance-type] Base`
其中的 `[inheritance-type]` 就是三种继承方式。

规则可以总结为一张表，它说明了基类成员在派生类中的访问权限将如何变化：

| 基类中的原始访问权限 | 继承方式 | 在派生类中变更后的访问权限 |
| :------------------- | :------- | :------------------------- |
| `public`             | `public` | **`public`**               |
| `protected`          | `public` | **`protected`**            |
| `public`             | `protected` | **`protected`**          |
| `protected`          | `protected` | **`protected`**          |
| `public`             | `private` | **`private`**              |
| `protected`          | `private` | **`private`**              |

**核心记忆口诀：**
1.  **`public` 继承：** 基类成员权限**原样继承**（`public`还是`public`，`protected`还是`protected`）。
2.  **`protected` 继承：** 基类的`public`和`protected`成员**都变成 `protected`**。
3.  **`private` 继承：** 基类的`public`和`protected`成员**都变成 `private`**。

**重要提示：** 无论哪种继承，基类的 `private` 成员在派生类中都是**不可见（无法直接访问）** 的。

---

### 3. 详细说明与代码示例

#### (1) Public 继承（最常用）

*   **含义：** “是一个（is-a）”的关系。例如，`Student` (派生类) 是一种 `Person` (基类)。
*   **规则：** 基类的公有成员在派生类中仍然是公有的，保护成员仍然是保护的。
*   **用途：** 用于表示派生类是基类的一种特化，它支持多态，是设计接口和实现继承的主要方式。

```cpp
class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

// Public 继承
class DerivedPublic : public Base {
public:
    void access() {
        publicVar = 10;      // OK: public -> public
        protectedVar = 20;   // OK: protected -> protected
        // privateVar = 30;  // Error: private member is inaccessible
    }
};

int main() {
    DerivedPublic d;
    d.publicVar = 100; // OK: 仍然是 public
    // d.protectedVar = 200; // Error: 在派生类中是 protected，外部不能访问
    // d.privateVar = 300;   // Error: 永远不可访问
    return 0;
}
```

#### (2) Protected 继承

*   **含义：** “实现继承”关系。派生类想要使用基类的实现，但**不暴露**基类的接口（公有成员）。这是一种“is-implemented-in-terms-of”的关系。
*   **规则：** 基类的公有成员和保护成员在派生类中都变为保护成员。
*   **用途：** 比较少见。通常用于你希望派生类及其后续派生类能使用基类的功能，但不想让外部代码通过派生类对象直接使用基类的公有接口。

```cpp
// Protected 继承
class DerivedProtected : protected Base {
public:
    void access() {
        publicVar = 10;      // OK: public -> protected (现在在派生类内部是protected)
        protectedVar = 20;   // OK: protected -> protected
        // privateVar = 30;  // Error: inaccessible
    }
};

int main() {
    DerivedProtected d;
    // d.publicVar = 100; // Error: publicVar 在派生类中已变为 protected，外部不能访问
    // d.protectedVar = 200; // Error: 同样是 protected
    // d.privateVar = 300;   // Error: inaccessible
    return 0;
}
```

#### (3) Private 继承

*   **含义：** 另一种更强的“实现继承”关系。强调“用...来实现”，但基类的所有功能都**只服务于派生类的内部实现**，甚至对派生类的子类也不暴露。它类似于“有一个”（组合）的关系，但有时比组合更节省空间或更强大。
*   **规则：** 基类的公有成员和保护成员在派生类中都变为私有成员。
*   **用途：** 比保护继承更少见。当你确定基类的功能只会被当前派生类使用，而不会被它的派生类再次使用时。

```cpp
// Private 继承
class DerivedPrivate : private Base {
public:
    void access() {
        publicVar = 10;      // OK: public -> private (现在在派生类内部是private)
        protectedVar = 20;   // OK: protected -> private
        // privateVar = 30;  // Error: inaccessible
    }
};

// 尝试从私有继承的类再派生
class DerivedFromPrivate : public DerivedPrivate {
public:
    void tryAccess() {
        // publicVar = 1;    // Error: 在 DerivedPrivate 中已是 private，不可继承
        // protectedVar = 2; // Error: 同上
    }
};

int main() {
    DerivedPrivate d;
    // d.publicVar = 100; // Error: publicVar 在派生类中已变为 private，外部不能访问
    // d.protectedVar = 200; // Error: 同样是 private
    return 0;
}
```

---

### 4. 总结与建议

| 特性           | Public 继承      | Protected 继承 | Private 继承 |
| :------------- | :--------------- | :------------- | :----------- |
| **关系类型**     | Is-a             | Implemented-in-terms-of | Implemented-in-terms-of |
| **基类public成员** | 在派生类中为 `public`  | 在派生类中为 `protected` | 在派生类中为 `private` |
| **基类protected成员** | 在派生类中为 `protected` | 在派生类中为 `protected` | 在派生类中为 `private` |
| **基类private成员** | 不可见             | 不可见           | 不可见         |
| **常见程度**     | **极其常见**       | 少见            | 很少见        |

**最佳实践建议：**

1.  **优先使用 `public` 继承：** 当你需要建立“是一个”的关系并使用多态时（例如，使用虚函数）。这是面向对象编程中最主要的方式。
2.  **优先使用组合（包含对象）而非 `private`/`protected` 继承：** 如果你只是想使用另一个类的功能（“有一个”的关系），而不是建立一种类型上的关系，那么将一个类作为成员变量（组合）通常比私有/保护继承更清晰、耦合度更低。
    ```cpp
    // 优先使用这种方式 (组合)
    class MyClass {
    private:
        Base m_base; // 包含一个Base对象，使用其功能
    public:
        void doSomething() { /* use m_base */ }
    };

    // 而不是这样 (private继承)
    class MyClass : private Base {
    public:
        void doSomething() { /* use Base's functionality */ }
    };
    ```
3.  **在特定情况下使用 `private` 继承：** 当你需要重写基类的虚函数，或者需要访问基类的保护成员时，私有继承可能比组合更合适。有时出于空基优化的考虑（EBO, Empty Base Optimization），也会使用私有继承。

理解这三种继承方式的关键在于思考你希望派生类与基类之间建立什么样的关系，以及你希望如何向外部代码暴露基类的接口。