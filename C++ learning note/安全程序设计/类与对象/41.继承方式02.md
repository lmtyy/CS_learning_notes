问得非常好！这是一个关键的区别点。

**答案是：可见，但权限被“降级”了。**

使用 `private` 继承的派生类，其内部**可以访问**基类的所有非私有（即 `public` 和 `protected`) 成员，但这些成员的访问权限在派生类内部全部被“降级”为 `private`。

让我们分解来看：

### 1. “可见”意味着可以访问

派生类的成员函数（包括构造函数、析构函数等）内部，可以直接使用基类的 `public` 和 `protected` 成员（变量和函数），就像使用自己的成员一样。这是“实现继承”的核心——派生类能够复用基类的代码。

### 2. “降级”意味着权限变更

虽然可以访问，但这些继承来的成员在派生类中的**访问权限**被强制改变了。无论它们在基类中是 `public` 还是 `protected`，到了派生类中，**一律变成 `private`**。

这意味着：
*   这些成员**只能在派生类的内部**使用。
*   派生类的对象（外部代码）**不能**访问这些成员。
*   如果从这个 `private` 继承的派生类再派生出新的类（孙子类），那么**孙子类内部也无法访问**这些来自“爷爷”基类的成员（因为它们在其父类，即我们的派生类中，已经是 `private` 的了，而 `private` 成员是不可继承的）。

---

### 代码示例

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int m_private; // 无论如何都不可见
protected:
    int m_protected;
    void protectedFunc() { cout << "Base::protectedFunc()" << endl; }
public:
    int m_public;
    void publicFunc() { cout << "Base::publicFunc()" << endl; }

    Base() : m_private(1), m_protected(2), m_public(3) {}
};

// 私有继承
class Derived : private Base { // 注意这里是 private 继承
public:
    void showAccess() {
        // m_private = 10;   // ERROR: 基类私有成员，永远不可见
        m_protected = 20;  // OK: 基类的protected成员可见，但在Derived内变为private
        m_public = 30;     // OK: 基类的public成员可见，但在Derived内变为private

        protectedFunc();   // OK: 基类的protected方法可见，但在Derived内变为private
        publicFunc();      // OK: 基类的public方法可见，但在Derived内变为private

        cout << "m_protected = " << m_protected << endl;
        cout << "m_public = " << m_public << endl;
    }
};

class GrandChild : public Derived {
public:
    void tryInherit() {
        // 所有从Base继承来的成员都无法访问
        // 因为在父类Derived中，它们已经全部是private的了
        // m_protected = 1; // Error
        // m_public = 2;    // Error
        // protectedFunc(); // Error
        // publicFunc();    // Error
    }
};

int main() {
    Derived d;

    d.showAccess(); // OK: showAccess是Derived的public方法

    // 但是，不能通过对象直接访问任何从Base继承来的成员
    // 因为它们现在在Derived类中都是private的
    // d.m_public = 100;    // Error
    // d.m_protected = 200; // Error
    // d.publicFunc();      // Error
    // d.protectedFunc();   // Error

    return 0;
}
```

### 总结对比

| 行为 | 基类私有成员 (`m_private`) | 基类非私有成员 (`m_public`, `m_protected`) |
| :--- | :--- | :--- |
| **在派生类内部是否可见？** | **绝对不可见** | **可见** |
| **在派生类中的访问权限** | (不适用) | **一律变为 `private`** |
| **派生类对象能否访问？** | 不能 | **不能** (因为现在它们是派生类的私有成员) |
| **能否继续继承给孙子类？** | 不能 | **不能** (因为现在它们是派生类的私有成员) |

所以，你的问题的核心在于区分 **“可见性/可访问性”** 和 **“访问权限”**。
*   `private` 继承解决了**可见性**问题：让派生类内部能看到并使用基类的非私有实现。
*   同时，它严格限制了**访问权限**：将这些实现细节完全隐藏，变为派生类自己的私有物，不再对外暴露。这正是“实现继承”而非“接口继承”的典型特征。