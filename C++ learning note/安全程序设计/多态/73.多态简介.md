好的，我们来详细介绍一下 C++ 中的多态。

### 1. 什么是多态？

**多态** 是面向对象编程的三大核心特性之一，另外两个是**封装**和**继承**。

从字面上理解，多态的意思是“多种形态”。在 C++ 中，它指的是**当不同的对象收到相同的消息时，会产生不同的行为**。

简单来说，就是**使用一个统一的接口，来操作不同的对象，从而执行不同的操作**。

### 2. 多态的分类

C++ 中的多态主要分为两类：

1.  **编译时多态**：在程序编译期间就能确定调用哪个函数。也称为**静态多态**。
2.  **运行时多态**：在程序运行期间才能确定调用哪个函数。也称为**动态多态**。

---

### 3. 编译时多态

编译时多态主要通过**函数重载**和**运算符重载**来实现。

#### a. 函数重载

在同一个作用域内，可以有一组具有**相同函数名**但**参数列表不同**的函数。编译器根据调用时传入的实参来决定调用哪个具体的函数。

```cpp
#include <iostream>
using namespace std;

class Print {
public:
    // 函数重载
    void show(int i) {
        cout << "整数: " << i << endl;
    }
    void show(double f) {
        cout << "浮点数: " << f << endl;
    }
    void show(const char* s) {
        cout << "字符串: " << s << endl;
    }
};

int main() {
    Print obj;
    obj.show(5);        // 调用 show(int)
    obj.show(3.14);     // 调用 show(double)
    obj.show("Hello");  // 调用 show(const char*)
    return 0;
}
```

**输出：**
```
整数: 5
浮点数: 3.14
字符串: Hello
```

#### b. 运算符重载

通过重新定义运算符（如 `+`, `-`, `<<` 等）对于自定义类型（如类）的操作，使其具有新的功能。

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 运算符重载：重载 ‘+’ 运算符
    Complex operator + (const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }

    void display() {
        cout << real << " + " << imag << "i" << endl;
    }
};

int main() {
    Complex c1(3.0, 4.0), c2(1.0, 2.0);
    Complex c3 = c1 + c2; // 使用重载的 ‘+’ 运算符
    c3.display(); // 输出：4 + 6i
    return 0;
}
```

---

### 4. 运行时多态

运行时多态是 C++ 中更核心、更强大的多态概念。它主要通过**虚函数**来实现。

#### 核心机制：虚函数

1.  **基类中声明虚函数**：在成员函数前加上 `virtual` 关键字。
2.  **派生类中重写虚函数**：派生类提供一个与基类虚函数**签名完全相同**的函数（函数名、参数列表、返回类型都相同）。C++11 中可以使用 `override` 关键字来显式地表明重写，提高代码清晰度和安全性。
3.  **通过基类指针或引用调用**：使用一个**基类类型的指针或引用**指向一个**派生类对象**，然后通过这个指针或引用调用虚函数。此时，调用的是派生类中重写的函数。

#### 关键概念：动态绑定

运行时多态的本质是**动态绑定**（或晚期绑定）。这意味着函数调用不是在编译时确定的，而是在程序运行时，根据指针或引用所指向的**对象的实际类型**来决定的。

#### 示例代码

```cpp
#include <iostream>
using namespace std;

// 基类
class Animal {
public:
    // 虚函数
    virtual void speak() {
        cout << "Animal makes a sound." << endl;
    }
    // 虚析构函数（非常重要！）
    virtual ~Animal() {
        cout << "Animal destructor." << endl;
    }
};

// 派生类 Dog
class Dog : public Animal {
public:
    // 重写基类的虚函数
    void speak() override { // 使用 override 确保正确重写
        cout << "Dog says: Woof!" << endl;
    }
    ~Dog() override {
        cout << "Dog destructor." << endl;
    }
};

// 派生类 Cat
class Cat : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Cat says: Meow!" << endl;
    }
    ~Cat() override {
        cout << "Cat destructor." << endl;
    }
};

int main() {
    // 1. 使用基类指针
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->speak(); // 输出：Dog says: Woof!
    animal2->speak(); // 输出：Cat says: Meow!

    // 2. 使用基类引用
    Dog myDog;
    Cat myCat;

    Animal& ref1 = myDog;
    Animal& ref2 = myCat;

    ref1.speak(); // 输出：Dog says: Woof!
    ref2.speak(); // 输出：Cat says: Meow!

    delete animal1;
    delete animal2;
    return 0;
}
```

**输出：**
```
Dog says: Woof!
Cat says: Meow!
Dog says: Woof!
Cat says: Meow!
Dog destructor.
Animal destructor.
Cat destructor.
Animal destructor.
```

#### 虚析构函数

请注意上面代码中的 `virtual ~Animal()`。这是一个非常重要的细节。

*   **为什么需要虚析构函数？**
    如果基类的析构函数不是虚函数，那么当通过一个基类指针删除一个派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致**派生类对象中的资源无法被正确释放**，造成内存泄漏。
*   **规则**：如果一个类有任何虚函数，那么它就应该有一个虚析构函数。

---

### 5. 纯虚函数和抽象类

有时，基类中的虚函数无法给出一个有意义的实现，只是为了提供一个统一的接口。这时可以将其声明为**纯虚函数**。

*   **纯虚函数**：在声明末尾加上 `= 0`。
*   **抽象类**：包含至少一个纯虚函数的类。
    *   抽象类**不能实例化对象**。
    *   它的派生类**必须重写**所有纯虚函数，否则这个派生类也会成为抽象类。

```cpp
#include <iostream>
using namespace std;

// 抽象基类
class Shape {
protected:
    double width, height;
public:
    Shape(double w, double h) : width(w), height(h) {}
    // 纯虚函数，提供接口
    virtual double getArea() const = 0; // 纯虚函数
    virtual ~Shape() = default; // 使用默认析构函数
};

// 派生类 Rectangle，必须实现 getArea
class Rectangle : public Shape {
public:
    Rectangle(double w, double h) : Shape(w, h) {}
    double getArea() const override {
        return width * height;
    }
};

// 派生类 Triangle，必须实现 getArea
class Triangle : public Shape {
public:
    Triangle(double w, double h) : Shape(w, h) {}
    double getArea() const override {
        return width * height / 2;
    }
};

int main() {
    // Shape s(1,2); // 错误！不能创建抽象类的对象

    Shape* shape1 = new Rectangle(5, 4);
    Shape* shape2 = new Triangle(5, 4);

    cout << "Rectangle area: " << shape1->getArea() << endl; // 输出：20
    cout << "Triangle area: " << shape2->getArea() << endl;  // 输出：10

    delete shape1;
    delete shape2;
    return 0;
}
```

---

### 总结

| 特性 | 编译时多态 | 运行时多态 |
| :--- | :--- | :--- |
| **实现方式** | 函数重载、运算符重载 | 虚函数、函数重写 |
| **绑定时间** | 编译时（早期绑定） | 运行时（晚期绑定） |
| **灵活性** | 较低 | 高 |
| **性能** | 较高（无运行时开销） | 较低（有虚函数表查找开销） |
| **核心关键字** | 无 | `virtual`, `override` |

**多态的优势：**

1.  **代码复用**：可以编写出处理基类通用接口的代码，这些代码能自动适用于所有派生类。
2.  **可扩展性**：添加新的派生类时，无需修改已有的、基于基类接口的代码。符合**开闭原则**（对扩展开放，对修改封闭）。
3.  **接口统一**：使得代码更清晰、更易于管理和维护。

希望这个介绍能帮助你全面理解 C++ 中的多态！