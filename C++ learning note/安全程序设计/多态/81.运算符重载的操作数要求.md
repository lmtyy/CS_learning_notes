好的，我们来详细讲解 C++ 中运算符重载的操作数要求。这是理解如何正确重载运算符的关键。

## 1. 基本操作数规则

### 核心限制
**运算符重载必须至少有一个操作数是用户自定义类型（类或枚举类型）。**

```cpp
// 可以重载
MyClass operator+(const MyClass& a, const MyClass& b); // ✓ 两个都是自定义类型
MyClass operator+(const MyClass& a, int b);           // ✓ 一个是自定义类型

// 不能重载  
int operator+(int a, int b); // ✗ 两个都是内置类型
```

## 2. 操作数数量要求

不同运算符有固定的操作数数量，重载时必须遵守：

### 一元运算符（1个操作数）
```cpp
class MyClass {
public:
    // 前缀 ++（成员函数形式）
    MyClass& operator++() {
        // ... 
        return *this;
    }
    
    // 负号（全局函数形式）
    friend MyClass operator-(const MyClass& obj);
};

MyClass obj;
++obj;  // 一元运算符：一个操作数
-obj;   // 一元运算符：一个操作数
```

### 二元运算符（2个操作数）
```cpp
class MyClass {
public:
    // 加法（成员函数形式）
    MyClass operator+(const MyClass& other) const;
    
    // 相等比较（全局函数形式）
    friend bool operator==(const MyClass& a, const MyClass& b);
};

MyClass a, b;
a + b;  // 二元运算符：两个操作数
a == b; // 二元运算符：两个操作数
```

### 特殊：函数调用运算符 `()`（可变参数）
```cpp
class Functor {
public:
    // 可以接受任意数量和类型的参数
    int operator()(int a, int b) {
        return a + b;
    }
    
    void operator()(const std::string& s) {
        std::cout << s << std::endl;
    }
};

Functor f;
f(1, 2);        // 两个参数
f("hello");     // 一个参数
```

## 3. 成员函数 vs 全局函数的操作数差异

这是最重要的区别！

### 成员函数形式
- **左操作数**：隐式的 `this` 指针
- **右操作数**：函数的参数
- **调用方式**：`a @ b` 等价于 `a.operator@(b)`

```cpp
class Complex {
    double real, imag;
public:
    // 成员函数：左操作数是 *this，右操作数是参数
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
};

Complex a, b, c;
c = a + b;  // 等价于 a.operator+(b)
```

### 全局函数形式
- **左操作数**：第一个参数
- **右操作数**：第二个参数  
- **调用方式**：`a @ b` 等价于 `operator@(a, b)`

```cpp
class Complex {
    double real, imag;
public:
    friend Complex operator+(const Complex& a, const Complex& b);
};

// 全局函数：两个操作数都是显式参数
Complex operator+(const Complex& a, const Complex& b) {
    return Complex(a.real + b.real, a.imag + b.imag);
}

Complex a, b, c;
c = a + b;  // 等价于 operator+(a, b)
```

## 4. 必须作为成员函数重载的运算符

以下运算符**必须**作为成员函数重载：

### `=` 赋值运算符
```cpp
class MyClass {
public:
    MyClass& operator=(const MyClass& other) {
        if (this != &other) {
            // 执行深拷贝等操作
        }
        return *this;
    }
};
```

### `()` 函数调用运算符
```cpp
class Multiplier {
    int factor;
public:
    Multiplier(int f) : factor(f) {}
    
    int operator()(int x) const {
        return x * factor;
    }
};

Multiplier times2(2);
int result = times2(5); // 返回 10
```

### `[]` 下标运算符
```cpp
class Array {
    int data[10];
public:
    int& operator[](size_t index) {
        return data[index];
    }
    
    const int& operator[](size_t index) const {
        return data[index];
    }
};

Array arr;
arr[3] = 42;  // 调用非常量版本
```

### `->` 成员访问运算符
```cpp
class SmartPtr {
    MyClass* ptr;
public:
    SmartPtr(MyClass* p) : ptr(p) {}
    
    MyClass* operator->() const {
        return ptr;
    }
};

SmartPtr ptr(new MyClass);
ptr->someMethod();  // 等价于 (ptr.operator->())->someMethod()
```

### 类型转换运算符
```cpp
class MyClass {
    int value;
public:
    operator int() const {  // 转换为 int
        return value;
    }
    
    operator std::string() const {  // 转换为 string
        return std::to_string(value);
    }
};

MyClass obj;
int x = obj;           // 调用 operator int()
std::string s = obj;   // 调用 operator std::string()
```

## 5. 对称性操作数的处理

对于需要对称性的运算符（如 `+`, `==`, `<` 等），推荐使用全局函数：

### 问题示例：混合类型运算
```cpp
class Complex {
    double real, imag;
public:
    Complex(double r, double i = 0) : real(r), imag(i) {}
    
    // 成员函数版本
    Complex operator+(double x) const {  // 可以处理 Complex + double
        return Complex(real + x, imag);
    }
    
    // 但是不能处理 double + Complex！
};

Complex c(1, 2);
Complex result1 = c + 3.0;  // ✓ 可以：c.operator+(3.0)
Complex result2 = 3.0 + c;  // ✗ 错误：3.0.operator+(c)
```

### 解决方案：全局函数重载
```cpp
class Complex {
    double real, imag;
public:
    Complex(double r, double i = 0) : real(r), imag(i) {}
    
    // 声明为友元以便访问私有成员
    friend Complex operator+(const Complex& a, const Complex& b);
    friend Complex operator+(const Complex& a, double b);
    friend Complex operator+(double a, const Complex& b);
};

// 全局函数实现所有组合
Complex operator+(const Complex& a, const Complex& b) {
    return Complex(a.real + b.real, a.imag + b.imag);
}

Complex operator+(const Complex& a, double b) {
    return Complex(a.real + b, a.imag);
}

Complex operator+(double a, const Complex& b) {
    return Complex(a + b.real, b.imag);  // 对称性！
}

Complex c(1, 2);
Complex r1 = c + 3.0;  // ✓ operator+(c, 3.0)
Complex r2 = 3.0 + c;  // ✓ operator+(3.0, c) - 现在可以工作了！
```

## 6. 输入输出运算符的特殊要求

`<<` 和 `>>` 必须作为全局函数，因为左操作数是流对象：

```cpp
class MyClass {
    int value;
public:
    MyClass(int v) : value(v) {}
    
    // 必须声明为友元全局函数
    friend std::ostream& operator<<(std::ostream& os, const MyClass& obj);
    friend std::istream& operator>>(std::istream& is, MyClass& obj);
};

// 左操作数是ostream，右操作数是MyClass
std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
    os << "MyClass(" << obj.value << ")";
    return os;  // 必须返回流引用以支持链式调用
}

std::istream& operator>>(std::istream& is, MyClass& obj) {
    is >> obj.value;
    return is;
}

MyClass obj(42);
std::cout << obj << std::endl;  // 输出: MyClass(42)
```

## 总结

| 运算符类别 | 推荐形式 | 关键要求 |
|------------|----------|----------|
| 赋值类 (`=`, `+=`, `-=`) | 成员函数 | 返回左值引用 |
| 算术类 (`+`, `-`, `*`, `/`) | 全局函数 | 保持对称性 |
| 关系类 (`==`, `!=`, `<`, `>`) | 全局函数 | 保持对称性 |
| 输入输出 (`<<`, `>>`) | 全局函数 | 左操作数是流 |
| 下标 (`[]`), 调用 (`()`), 箭头 (`->`) | 必须成员函数 | - |
| 递增递减 (`++`, `--`) | 成员函数 | 区分前缀后缀 |

理解这些操作数要求是写出正确、直观的运算符重载的关键！