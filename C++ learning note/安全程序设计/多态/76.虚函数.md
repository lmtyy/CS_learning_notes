好的，我们来深入讲解 C++ 的虚函数。这是 C++ 实现运行时多态的核心机制。

## 1. 虚函数的基本概念

**虚函数**是在基类中使用 `virtual` 关键字声明的成员函数，它允许在派生类中被重写。当通过基类指针或引用调用虚函数时，会根据实际对象的类型来调用相应的函数。

### 基本语法

```cpp
class Base {
public:
    virtual void show() {  // 虚函数声明
        cout << "Base show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {  // 重写虚函数
        cout << "Derived show()" << endl;
    }
};
```

## 2. 虚函数的工作原理：虚函数表

C++ 通过**虚函数表**来实现动态绑定。这是理解虚函数的关键。

### 虚函数表机制

- 每个包含虚函数的类都有一个**虚函数表**
- 每个该类的对象都有一个指向虚函数表的**虚表指针**
- 虚函数表中存储了该类所有虚函数的地址

```cpp
class Animal {
public:
    virtual void speak() { cout << "Animal sound" << endl; }
    virtual void eat() { cout << "Animal eating" << endl; }
    virtual ~Animal() {}
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!" << endl; }
    void eat() override { cout << "Dog eating" << endl; }
};
```

内存布局示意图：
```
Animal 对象:        Dog 对象:
[vptr]       -->   Animal虚表:        [vptr]       -->   Dog虚表:
[其他成员]          [Animal::speak地址] [其他成员]          [Dog::speak地址]
                   [Animal::eat地址]                     [Dog::eat地址]
                   [Animal::~Animal地址]                 [Dog::~Dog地址]
```

## 3. 虚函数的使用细节

### 通过指针和引用调用

```cpp
int main() {
    Animal* animal;
    
    Dog dog;
    Cat cat;  // 假设有 Cat 类
    
    animal = &dog;
    animal->speak();  // 输出: Woof! (调用 Dog::speak)
    
    animal = &cat; 
    animal->speak();  // 输出: Meow! (调用 Cat::speak)
    
    // 通过引用
    Animal& ref = dog;
    ref.speak();      // 输出: Woof!
}
```

### 虚析构函数

**这是极其重要的细节！**

```cpp
class Base {
public:
    // 非虚析构函数 - 危险！
    ~Base() { cout << "Base destructor" << endl; }
};

class Derived : public Base {
public:
    ~Derived() { cout << "Derived destructor" << endl; }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // 只调用 Base::~Base()，Derived 析构函数不会被调用！
                 // 内存泄漏！
}
```

**正确做法：**

```cpp
class Base {
public:
    virtual ~Base() { cout << "Base destructor" << endl; }  // 虚析构函数
};

class Derived : public Base {
public:
    ~Derived() override { cout << "Derived destructor" << endl; }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // 正确调用 Derived::~Derived() 然后 Base::~Base()
}
```

## 4. 纯虚函数和抽象类

### 纯虚函数

纯虚函数是没有实现的虚函数，使类成为抽象类。

```cpp
class Shape {
public:
    // 纯虚函数
    virtual double area() const = 0;
    virtual void draw() const = 0;
    
    // 普通成员函数
    void printInfo() const {
        cout << "Area: " << area() << endl;
    }
    
    virtual ~Shape() = default;
};
```

### 抽象类

- 包含至少一个纯虚函数的类是抽象类
- 不能创建抽象类的对象
- 派生类必须实现所有纯虚函数

```cpp
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    
    // 必须实现纯虚函数
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    void draw() const override {
        cout << "Drawing circle with radius " << radius << endl;
    }
};

int main() {
    // Shape s;  // 错误：不能创建抽象类对象
    Circle c(5.0);
    c.printInfo();  // 输出: Area: 78.5397
}
```

## 5. override 和 final 关键字

### override (C++11)

明确表示要重写基类的虚函数，提高代码安全性。

```cpp
class Base {
public:
    virtual void func(int x) { /* ... */ }
};

class Derived : public Base {
public:
    // void func(float x) { /* ... */ }  // 错误！本想重写，但参数不同
    void func(int x) override { /* ... */ }  // 正确，明确要重写
};
```

### final (C++11)

阻止进一步的继承或重写。

```cpp
class Base {
public:
    virtual void func() final { }  // 不能重写
};

class Derived : public Base {
public:
    // void func() override { }  // 错误！func 是 final
};

class NoFurther final {  // 类不能被继承
    // ...
};

// class Extended : public NoFurther { };  // 错误！NoFurther 是 final
```

## 6. 虚函数的访问控制

虚函数可以有不同的访问权限，但调用时取决于对象的静态类型。

```cpp
class Base {
private:
    virtual void secret() { cout << "Base secret" << endl; }
public:
    void callSecret() { secret(); }  // 可以调用，因为在这个类中是私有的
};

class Derived : public Base {
public:
    void secret() override { cout << "Derived secret" << endl; }  // 可以重写为public
};

int main() {
    Derived d;
    d.callSecret();  // 输出: "Derived secret"
    // d.secret();    // 错误：secret 在 Base 中是 private
}
```

## 7. 虚函数与默认参数

**重要**：默认参数是静态绑定的，不是动态绑定的！

```cpp
class Base {
public:
    virtual void show(int x = 10) {
        cout << "Base: " << x << endl;
    }
};

class Derived : public Base {
public:
    void show(int x = 20) override {
        cout << "Derived: " << x << endl;
    }
};

int main() {
    Base* obj = new Derived();
    obj->show();  // 输出: "Derived: 10" (不是 20!)
                  // 默认参数来自 Base，函数实现来自 Derived
}
```

## 8. 性能考虑

虚函数调用比普通函数调用有额外开销：
- 需要通过虚表指针间接查找函数地址
- 通常不能被内联优化
- 每个对象有额外的虚表指针内存开销

```cpp
// 普通函数调用 - 高效
obj.normalFunction();

// 虚函数调用 - 有额外开销
obj.virtualFunction();  // 需要：1. 取vptr 2. 查虚表 3. 间接调用
```

## 9. 最佳实践

1. **如果类要作为基类被使用，提供虚析构函数**
2. **使用 `override` 明确重写意图**
3. **考虑使用 `final` 阻止不必要的继承**
4. **避免在虚函数中使用默认参数**
5. **只为需要多态行为的函数声明为 virtual**
6. **抽象类的析构函数应该是虚的**

```cpp
// 良好的虚函数使用示例
class Document {
public:
    virtual void open() = 0;        // 纯虚函数
    virtual void save() = 0;        // 纯虚函数
    virtual void print() { }        // 虚函数，有默认实现
    virtual ~Document() = default;  // 虚析构函数
};

class TextDocument : public Document {
public:
    void open() override { /* 实现 */ }
    void save() override { /* 实现 */ }
    // 可以使用基类的 print() 实现
};
```

理解虚函数是掌握 C++ 多态的关键，它提供了运行时灵活性，但也需要仔细考虑性能和设计影响。