在 C++ 中，大多数运算符都可以被重载，但有一些运算符是**不能被重载**的。以下是不能被重载的运算符列表：

## 不能被重载的运算符

### 1. 成员访问运算符 - `.` (点运算符)
```cpp
obj.member;  // 不能被重载
```

### 2. 成员指针访问运算符 - `.*`
```cpp
obj.*ptr_to_member;  // 不能被重载
```

### 3. 作用域解析运算符 - `::`
```cpp
Class::static_member;  // 不能被重载
Namespace::member;
```

### 4. 条件运算符 - `?:` (三元运算符)
```cpp
condition ? expr1 : expr2;  // 不能被重载
```

### 5. `sizeof` 运算符
```cpp
sizeof(type);    // 不能被重载
sizeof(expr);
```

### 6. `typeid` 运算符
```cpp
typeid(type);    // 不能被重载
typeid(expr);
```

### 7. 转换运算符的语法形式
虽然可以创建转换函数，但不能重载特定的转换语法。

## 可以重载的运算符示例

为了对比，这里列出一些常见的可重载运算符：

```cpp
class MyClass {
public:
    // 算术运算符
    MyClass operator+(const MyClass& other);
    MyClass operator-(const MyClass& other);
    
    // 比较运算符
    bool operator==(const MyClass& other);
    bool operator<(const MyClass& other);
    
    // 赋值运算符
    MyClass& operator=(const MyClass& other);
    
    // 下标运算符
    int& operator[](int index);
    
    // 函数调用运算符
    void operator()(int param);
    
    // 转换运算符
    operator int() const;
    
    // new/delete 运算符
    void* operator new(size_t size);
    void operator delete(void* ptr);
};
```

## 重要说明

- **不能创建新的运算符**：只能重载语言中已存在的运算符
- **不能改变运算符的优先级和结合性**
- **不能改变运算符的操作数个数**
- **至少有一个操作数必须是用户定义类型**（不能全部是内置类型）

这些限制确保了运算符重载不会破坏语言的基本语法规则和类型系统。