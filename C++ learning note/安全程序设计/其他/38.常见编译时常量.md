好的，以下是 C++ 中会被视为**编译时常量**的各种情况的详细列表和示例：

---

### 1. 字面量
所有字面量本身就是编译时常量。
```cpp
42          // 整数字面量
3.14159     // 浮点字面量
'A'         // 字符字面量
"Hello"     // 字符串字面量（类型是 const char[6]）
true        // 布尔字面量
nullptr     // 指针字面量
```

### 2. `constexpr` 变量
明确声明为 `constexpr` 的变量一定是编译时常量。
```cpp
constexpr int max_size = 100;
constexpr double pi = 3.1415926535;
constexpr const char* name = "John Doe";
```

### 3. 枚举值
枚举项的值在编译期确定。
```cpp
enum Colors { RED = 1, GREEN = 2, BLUE = 4 };
enum class Status { OK = 0, ERROR = 1 };
// RED, GREEN, BLUE, Status::OK, Status::ERROR 都是编译时常量
```

### 4. `sizeof` 和 `alignof` 运算符的结果
这些运算符在编译期求值。
```cpp
constexpr size_t int_size = sizeof(int);
constexpr size_t double_align = alignof(double);
```

### 5. 使用 `constexpr` 函数计算的结果
如果 `constexpr` 函数的所有参数都是编译期常量，那么它的返回值也是编译期常量。
```cpp
constexpr int square(int x) { return x * x; }
constexpr int area = square(10);  // 100，编译时常量

constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}
constexpr int fact_5 = factorial(5);  // 120，编译时常量
```

### 6. 模板参数和非类型模板参数的值
```cpp
template<int N>
struct ArrayWrapper {
    static constexpr int size = N;
};

// 42 是编译时常量模板参数
ArrayWrapper<42> arr;

// 模板中的静态常量
constexpr int template_value = ArrayWrapper<10>::size;  // 10，编译时常量
```

### 7. 使用 `static const` 或 `const` 在类中初始化的整型静态成员
```cpp
class Constants {
public:
    static const int max_connections = 100;  // 编译时常量
    static constexpr double version = 2.0;   // 编译时常量
};

const int buffer_size = Constants::max_connections;  // 100，编译时常量
```

### 8. 地址常量表达式（有限制）
某些情况下，对象的地址也可以是编译时常量。
```cpp
constexpr const char* str = "Hello";  // "Hello" 的地址是编译时常量

extern const int global_var;
constexpr const int* global_ptr = &global_var;  // 如果 global_var 有合适的链接性
```

### 9. 使用 `consteval` 函数的结果 (C++20)
`consteval` 函数必须在编译期求值，其结果自然是编译时常量。
```cpp
consteval int compile_time_add(int a, int b) {
    return a + b;
}
constexpr int result = compile_time_add(10, 20);  // 30，编译时常量
```

### 10. 某些标准库定义的常量
许多标准库常量被定义为 `constexpr`。
```cpp
#include <numbers>
#include <limits>

constexpr double pi = std::numbers::pi;  // C++20，编译时常量
constexpr int max_int = std::numeric_limits<int>::max();  // 编译时常量
```

### 11. 条件运算符 (`?:`) 如果操作数是编译时常量
```cpp
constexpr bool debug = true;
constexpr int log_level = debug ? 3 : 1;  // 3，编译时常量
```

### 12. 数组大小（在需要编译期常量的上下文中）
```cpp
constexpr int size = 10;
int arr[size];  // size 必须是编译时常量

// 或者直接使用字面量
int another_arr[5];  // 5 是编译时常量
```

---

### 什么情况下 `const` 变量是编译时常量？

只有当 `const` 变量的初始化表达式本身是编译期常量表达式时：
```cpp
const int a = 42;           // 编译时常量（字面量初始化）
const int b = a * 2;        // 编译时常量（a 是编译时常量）
const int c = sizeof(int);  // 编译时常量

// 以下不是编译时常量
int get_value();
const int d = get_value();  // 运行时常量
const int e = std::rand();  // 运行时常量
```

### 测试方法：在需要编译期常量的上下文中使用

如果一个值可以用在以下需要编译期常量的场景中，那么它就是编译时常量：

```cpp
// 1. 数组大小
int array[value];  // 如果编译通过，value 是编译时常量

// 2. 模板非类型参数
template<int N> struct Test {};
Test<value> test;  // 如果编译通过，value 是编译时常量

// 3. switch case 标签
switch (0) {
    case value: break;  // 如果编译通过，value 是编译时常量
}

// 4. 静态断言
static_assert(value == 42, "Message");  // 如果编译通过，value 是编译时常量
```

**总结**：编译时常量的关键在于其值**必须在编译阶段就能被编译器完全确定**，无需等到程序运行时。