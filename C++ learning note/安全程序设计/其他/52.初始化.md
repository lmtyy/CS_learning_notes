**初始化** 是在变量创建时为其赋予初始值的过程。与赋值不同，初始化发生在变量获得存储空间的同时。

## 1. 初始化 vs 赋值

```cpp
int x = 10;     // 初始化：创建 x 的同时给值
x = 20;         // 赋值：x 已经存在，改变其值

std::string s1("hello");  // 初始化
std::string s2;
s2 = "world";   // 赋值
```

---

## 2. C++ 中的初始化方式

### (1) 直接初始化
```cpp
int x(10);              // 传统直接初始化
std::string s("hello");
std::vector<int> v(5);  // 包含 5 个默认构造的元素
```

### (2) 拷贝初始化
```cpp
int x = 10;             // 拷贝初始化
std::string s = "hello";
std::vector<int> v = {1, 2, 3};
```

### (3) 统一初始化（C++11 起）
```cpp
int x{10};              // 直接列表初始化
int y = {20};           // 拷贝列表初始化
std::vector<int> v{1, 2, 3};  // 包含 3 个元素：1, 2, 3

// 注意与构造函数参数的区别：
std::vector<int> v1(5);    // 5 个元素，都是 0
std::vector<int> v2{5};    // 1 个元素，值为 5
```

### (4) 默认初始化
```cpp
int x;                  // 默认初始化（内置类型值不确定）
std::string s;          // 默认初始化（调用默认构造函数，空字符串）
```

### (5) 值初始化
```cpp
int x{};                // 值初始化为 0
int* ptr{};             // 值初始化为 nullptr
std::vector<int> v{};   // 空向量

int arr[5]{};           // 所有元素值初始化为 0
```

---

## 3. 类成员的初始化

### 默认成员初始化（C++11）
```cpp
class MyClass {
private:
    int x = 10;         // 默认成员初始化
    std::string s{"hello"};
    double d{};         // 值初始化为 0.0
public:
    MyClass() = default;
    MyClass(int val) : x(val) {}  // 构造函数初始化列表
};
```

### 构造函数初始化列表
```cpp
class Person {
private:
    std::string name;
    int age;
public:
    // 初始化列表（真正的初始化）
    Person(const std::string& n, int a) : name(n), age(a) {}
    
    // 错误方式：这是赋值，不是初始化！
    // Person(const std::string& n, int a) {
    //     name = n;  // 赋值，name 已经被默认构造过了
    //     age = a;   // 赋值
    // }
};
```

---

## 4. 各种类型的初始化特性

### 内置类型
```cpp
int a;          // 默认初始化：值不确定（垃圾值）
int b{};        // 值初始化：0
int c{42};      // 直接初始化：42
int d = 42;     // 拷贝初始化：42

static int e;   // 静态存储期：值初始化为 0
```

### 类类型
```cpp
class Example {
public:
    Example() : x(0) { std::cout << "默认构造\n"; }
    Example(int val) : x(val) { std::cout << "参数构造\n"; }
    Example(const Example& other) : x(other.x) { std::cout << "拷贝构造\n"; }
private:
    int x;
};

Example ex1;            // 默认初始化：调用默认构造函数
Example ex2(10);        // 直接初始化：调用参数构造函数  
Example ex3 = ex2;      // 拷贝初始化：调用拷贝构造函数
Example ex4{20};        // 直接列表初始化
Example ex5 = {30};     // 拷贝列表初始化
```

### 数组初始化
```cpp
int arr1[3];            // 默认初始化：元素值不确定
int arr2[3]{};          // 值初始化：所有元素为 0
int arr3[3]{1, 2};      // 前两个元素为 1, 2，第三个为 0
int arr4[]{1, 2, 3};    // 编译器推导大小为 3
```

---

## 5. 初始化的特殊规则

### 静态初始化
```cpp
// 编译时常量初始化（静态初始化）
constexpr int SIZE = 100;
const int MAX_VALUE = 999;

// 零初始化
static int global_var;    // 零初始化为 0
```

### 动态初始化
```cpp
// 运行时初始化
int getValue() { return 42; }
int x = getValue();      // 动态初始化

// 动态内存的初始化
int* ptr = new int(10);  // 初始化为 10
int* arr = new int[5](); // 所有元素值初始化为 0
```

---

## 6. C++17 后的新特性

### 类模板参数推导（CTAD）
```cpp
std::pair p(1, 2.0);     // 推导为 std::pair<int, double>
std::vector v{1, 2, 3};  // 推导为 std::vector<int>
```

### 强制拷贝省略
```cpp
Example createExample() {
    return Example(42);  // C++17 保证无拷贝/移动
}

Example ex = createExample(); // 直接初始化，无临时对象
```

---

## 7. 初始化的重要性

### 避免未定义行为
```cpp
int x;          // 危险：值不确定
std::cout << x; // 未定义行为！

int y{};        // 安全：初始化为 0
std::cout << y; // 输出 0
```

### 性能优化
```cpp
// 好的做法：直接初始化
std::string s1("hello");

// 不好的做法：默认构造 + 赋值
std::string s2;
s2 = "hello";   // 多了一次赋值操作
```

---

## 总结

- **初始化** = 创建变量时给初始值
- **赋值** = 改变已存在变量的值
- **推荐使用统一初始化** `{}`：更安全、更一致
- **类成员优先使用初始化列表**：效率更高
- **总是初始化变量**：避免未定义行为

理解各种初始化方式对于写出正确、高效的 C++ 代码至关重要！