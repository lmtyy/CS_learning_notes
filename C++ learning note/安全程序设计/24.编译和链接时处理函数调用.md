这是一个非常好的问题！它触及了C++编译和链接过程的核心。

简单直接的回答是：**两者都有，但主要的重担是在编译时。**

更详细的解释是，C++处理函数调用是一个分步协作的过程，编译器和链接器各司其职：

---

### 1. 编译时 (Compiler's Job)

编译器处理**单个源文件**（.cpp）。当它遇到一个函数调用时，它会做以下几件事：

*   **名称修饰 (Name Mangling)：** 编译器将函数名（包括参数类型、类名、命名空间等信息）转换成一个编译器内部唯一的、链接器可识别的名称。例如，`int foo(double, char)` 可能被修饰为 `_Z3foodc`。这是为了支持函数重载。
*   **语法和类型检查：** 编译器检查函数调用的语法是否正确，以及实参的类型是否与函数声明的形参类型匹配（或可以转换）。如果函数声明未知，在较老的C++标准中会假设它返回`int`并发出警告，但在现代C++（C++99之后）中，这通常是一个错误。
*   **生成目标代码中的“占位符”：** 编译器**并不知道**函数的具体实现（即它的地址）在哪里。它只知道函数的声明（在头文件中通过 `extern` 得知）。因此，它会在生成的目标文件（.obj 或 .o）中创建一个**未解析的引用 (Unresolved External)** 或者说一个“空白”，并记下“这里需要填入函数 `_Z3foodc` 的地址”。

**所以，在编译时，函数调用被解析为一个符号引用，但该符号的地址是未知的。**

**例外：内联函数和模板**
*   如果函数被声明为 `inline`，编译器可能会在编译时直接尝试将函数调用替换为函数体（内联展开）。
*   模板也是在编译时进行实例化的。当你调用一个模板函数时，编译器会根据具体的类型参数生成一份对应的代码。

---

### 2. 链接时 (Linker's Job)

链接器处理**所有编译器生成的目标文件**和**库文件**。它的主要任务之一就是**解析这些未定义的引用**。

*   **符号解析 (Symbol Resolution)：** 链接器扫描所有目标文件和库文件，建立一个全局的符号表。当它看到某个目标文件说“我需要 `_Z3foodc` 的地址”时，它就去这个全局表里查找。
*   **地址分配 (Address Binding)：**
    *   如果找到了该符号的定义（比如在另一个.cpp文件或静态库中定义了`int foo(double, char) { ... }`），链接器就会计算出该函数在最终可执行文件或库中的**绝对地址**或相对地址。
    *   然后，链接器回到那个发出调用的目标文件中，**用计算出的真实地址填充之前留下的“空白”**。
*   **处理错误：**
    *   如果链接器在所有提供的目标文件和库中都找不到该符号的定义，它就会报出著名的**链接错误 (Linker Error)**，例如 `undefined reference to 'foo(double, char)'` 或 `unresolved external symbol _Z3foodc`。
    *   如果找到了多个相同的符号定义（违反了One Definition Rule），则会报 **重复定义 (Duplicate Symbol)** 错误。

---

### 总结与类比

| 阶段 | 负责者 | 任务 | 输入 | 输出 | 如果找不到函数 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **编译时** | **编译器** | 检查语法和类型，生成符号引用（占位符） | 单个 .cpp 文件 + 头文件 | 目标文件 (.obj/.o) | **编译错误** (如果声明缺失) |
| **链接时** | **链接器** | 合并所有目标文件，解析符号引用，填入真实地址 | 所有目标文件 + 库文件 | 可执行文件 (.exe) 或库 | **链接错误** |

一个很好的类比是**写论文和整理参考文献**：

*   **编译** 就像你**撰写论文的某一章**。你引用了很多其他书籍或论文（函数调用），你只是在正文里写上了 `[引用1]`（生成符号引用），但你手头并没有那本书，也不知道它在图书馆的哪个具体位置（函数地址）。
*   **链接** 就像你**完成所有章节后整理参考文献列表**。你拿着所有 `[引用X]` 的列表，去图书馆（所有的目标文件和库）里一本一本地找到这些书，确认它们存在，并在最终的论文中把 `[引用1]` 替换成具体的页码和书名（填入真实地址）。如果图书馆里根本没有这本书，你就无法完成论文（链接错误）。

因此，可以说函数调用的**解析和最终完成**是在链接时，但大量的前期准备工作（检查、生成待填的引用）是在编译时完成的。