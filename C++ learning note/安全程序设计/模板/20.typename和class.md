您问到了一个非常好的细节！在大多数情况下，`typename` 和 `class` 在模板参数声明中**确实是可以互换的**，没有功能上的区别。但是，它们并非完全等同，了解它们的细微差别有助于写出更清晰、更准确的代码。

### 核心区别

| 特性 | `class` | `typename` |
| :--- | :--- | :--- |
| **历史背景** | 先被引入C++ | 后来被加入标准，用于解决歧义 |
| **字面含义** | 暗示模板参数应该是一个“类类型” | 更中性，明确表示这是一个“类型名” |
| **适用性** | 基本类型（`int`, `double`）也可以用，但字面意思不匹配 | 更通用、更准确，任何类型都能很好地描述 |
| **其他用途** | 仅用于声明模板类型参数 | **还能用于告诉编译器一个依赖名称是类型**（这是关键区别！） |

---

### 1. 在模板参数声明中（可互换）

在这里，两者完全一样。编译器不会区别对待。

```cpp
// 以下两种写法完全等效
template <class T> void func1(T arg) { }
template <typename T> void func2(T arg) { }
```

**为什么推荐使用 `typename`？**
-   **更直观**：模板参数 `T` 可以是任何类型（`int`, `double`, `MyClass`），而不仅仅是类（`class`）。`typename` 更准确地表达了“类型名”这个概念。
-   **一致性**：在模板内部解决“依赖名称”问题时，你必须使用 `typename`。为了保持代码风格一致，在参数声明中也使用 `typename` 是更好的选择。

---

### 2. 在模板内部（不可互换！这是关键区别）

这是 `typename` 有**唯一作用**而 `class` 无法替代的地方。它用于告诉编译器：“一个依赖于模板参数的标识符是一个类型”，这称为**依赖类型名**。

看这个例子：

```cpp
template <class T>
class MyClass {
    T::subType * ptr; // 这行代码有歧义！
};
```

编译器看到 `T::subType * ptr` 时，会产生困惑：
1.  **可能是一个乘法操作**：如果 `T::subType` 是一个静态成员变量（例如 `static int subType;`），那么这就是在计算 `(T::subType) * ptr`。
2.  **可能是一个指针声明**：如果 `T::subType` 是一个类型（例如一个内部类 typedef），那么这就是在声明一个 `T::subType*` 类型的指针 `ptr`。

由于 `T` 在实例化之前是未知的，编译器无法判断哪种情况是正确的。默认情况下，C++ 标准规定编译器必须假设这种**依赖名称**（依赖于模板参数 `T` 的名称）**不是类型**，除非你用 `typename` 关键字明确告诉它。

**解决方案：使用 `typename`**

```cpp
template <class T> // 这里用 class 声明参数没问题
class MyClass {
    typename T::subType * ptr; // 正确！使用 typename 明确告诉编译器 subType 是一个类型
};
```

现在，编译器清楚地知道 `T::subType` 是一个类型，因此 `ptr` 被声明为一个指针。

**另一个常见例子（与 `typedef` 一起使用）：**

```cpp
template <typename T>
void foo() {
    // 告诉编译器 std::vector<T>::iterator 是一个类型，而不是别的什么东西
    typedef typename std::vector<T>::iterator VecIterator;

    VecIterator it; // 现在可以正常声明迭代器变量
}
```

**在这种情况下，你绝对不能使用 `class` 来代替 `typename`：**

```cpp
typedef class std::vector<T>::iterator VecIterator; // 错误！语法无效
```

---

### 总结与最佳实践

1.  **功能上**：在声明模板参数时，`template <class T>` 和 `template <typename T>` **完全等价**，可以互换。
2.  **语义上**：**优先使用 `typename`**。因为它更准确（`T` 可以是任何类型，不一定是类），并且是现代 C++ 的推荐风格。
3.  **特殊场景**：在模板内部，当需要指明一个**依赖名称是类型**时，**必须使用 `typename`**。`class` 关键字在此处无效。

所以，您的资料里说的“`typename` 更直观”是完全正确的建议。养成使用 `typename` 的习惯可以让你的代码意图更清晰，也能避免在需要用到它的特殊场景时产生混淆。