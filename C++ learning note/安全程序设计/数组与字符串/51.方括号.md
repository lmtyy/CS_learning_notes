这是一个很好的问题！虽然数组参数退化成指针，但方括号操作符 `[]` 实际上**既可以用于数组，也可以用于指针**。让我详细解释：

## 1. 方括号的本质

在 C/C++ 中，`arr[i]` 等价于 `*(arr + i)`。这是一个**语法糖**，对数组和指针都适用。

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;  // 数组退化为指针

// 以下四行完全等价：
cout << arr[2] << endl;    // 30
cout << ptr[2] << endl;    // 30
cout << *(arr + 2) << endl; // 30  
cout << *(ptr + 2) << endl; // 30
```

---

## 2. 指针的方括号操作原理

当数组退化为指针后，指针仍然支持 `[]` 操作，因为编译器会进行地址计算：

```cpp
void func(int* arr) {  // 数组退化为指针
    // arr[2] 被编译器转换为：*(arr + 2)
    // 1. 计算偏移：arr + 2 * sizeof(int)
    // 2. 解引用获取该地址的值
    cout << arr[2] << endl; // 正常工作！
}

int main() {
    int myArray[5] = {10, 20, 30, 40, 50};
    func(myArray); // 输出 30
    return 0;
}
```

---

## 3. 内存布局角度理解

假设数组在内存中的布局：
```
地址:   0x1000  0x1004  0x1008  0x100C  0x1010
值:     [10]    [20]    [30]    [40]    [50]
索引:   arr[0]  arr[1]  arr[2]  arr[3]  arr[4]
```

当数组退化为指针时：
- `arr` 保存的是 `0x1000`（首地址）
- `arr[2]` 计算为 `*(0x1000 + 2*4) = *(0x1008)`，得到 30

---

## 4. 编译器视角

从编译器角度看，数组访问和指针访问生成相似的机器代码：

```cpp
// 源代码
int array_access(int arr[]) {
    return arr[3];
}

int pointer_access(int* ptr) {
    return ptr[3];
}

// 编译器可能生成的伪汇编（概念性）：
// array_access:
//   mov eax, [rdi + 12]  ; rdi 是 arr 参数，12 = 3 * 4(bytes)
//   ret

// pointer_access:  
//   mov eax, [rdi + 12]  ; 完全相同的指令！
//   ret
```

---

## 5. 重要区别：虽然语法相同，但类型信息不同

尽管访问语法相同，但退化的指针**丢失了数组长度信息**：

```cpp
void demonstrateDifference(int* ptr) {
    // 可以语法上使用 ptr[i]，但编译器不知道数组边界
    // 以下代码编译通过，但可能越界访问！
    for (int i = 0; i < 100; i++) {  // 危险：不知道实际大小
        cout << ptr[i] << endl;      // 可能访问非法内存
    }
}

int main() {
    int smallArray[3] = {1, 2, 3};
    demonstrateDifference(smallArray); // 灾难！
    return 0;
}
```

---

## 6. 多维数组的特殊情况

对于多维数组，只有第一维会退化：

```cpp
void func(int matrix[][3]) {  // 退化为 int (*matrix)[3]
    // matrix[i][j] 仍然工作，因为第二维大小已知
    // 等价于：*(*(matrix + i) + j)
    cout << matrix[1][2] << endl;
}

int main() {
    int arr[2][3] = {{1,2,3}, {4,5,6}};
    func(arr); // 输出 6
    return 0;
}
```

这里 `matrix` 退化为"指向含有3个int的数组的指针"，而不是 `int**`。

---

## 7. 总结

- **为什么能用方括号**：因为 `arr[i]` 本质是 `*(arr + i)`，这种指针算术对任何指针类型都有效
- **关键区别**：数组知道自己的大小，退化的指针不知道
- **安全建议**：总是传递数组大小时，或使用 `std::array`/`std::vector`

```cpp
// 安全的方式：显式传递大小
void safeFunction(int* arr, size_t size) {
    for (size_t i = 0; i < size; i++) {
        cout << arr[i] << " ";  // 安全访问
    }
}
```

所以退化成指针后还能用 `[]` 不是因为"还是数组"，而是因为 C/C++ 的指针本身就支持这种语法糖！