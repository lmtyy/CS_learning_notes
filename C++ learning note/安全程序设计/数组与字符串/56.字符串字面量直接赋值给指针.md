您观察得非常仔细！这是一个很重要的区别。让我详细解释这种特殊语法背后的原理。

## 1. 字符串字面量的特殊处理

```cpp
const char* str1 = "Hello";  // 特殊语法
const char* str2 = &"Hello"; // 错误！不能这样写
```

实际上，字符串字面量 `"Hello"` 本身就是一个**常量字符数组**，在内存中拥有自己的地址。

## 2. 数组到指针的隐式转换

```cpp
// 编译器背后的实际过程
const char hidden_array[] = {'H', 'e', 'l', 'l', 'o', '\0'};
const char* str1 = hidden_array;  // 数组名退化为指针
```

**数组名在大多数情况下会隐式转换为指向其首元素的指针**，所以不需要显式使用 `&`。

## 3. 对比其他类型的字面量

```cpp
int x = 10;          // 整数字面量直接赋值给变量
int* ptr = &x;       // 需要 & 获取变量地址

// 但数字字面量不能直接赋值给指针
// int* ptr2 = 10;   // 错误！

const char* str = "Hello";  // 字符串字面量可以直接赋值给指针
```

## 4. 验证字符串字面量的地址

```cpp
#include <iostream>
using namespace std;

int main() {
    const char* str1 = "Hello";
    const char* str2 = "Hello";
    
    cout << "str1: " << (void*)str1 << endl;
    cout << "str2: " << (void*)str2 << endl;
    cout << "是否相同地址: " << (str1 == str2) << endl;
    
    // 字符串字面量的实际类型
    cout << "类型大小: " << sizeof("Hello") << endl; // 6 bytes (包含\0)
    
    return 0;
}
```

输出可能是：
```
str1: 0x400a00
str2: 0x400a00  
是否相同地址: 1
类型大小: 6
```

## 5. 编译器优化：字符串池化

编译器通常会将相同的字符串字面量合并存储（字符串池化）：

```cpp
const char* s1 = "test";
const char* s2 = "test";
const char* s3 = "test";

// s1, s2, s3 很可能指向同一个内存地址
```

## 6. 与字符数组的对比

```cpp
// 字符串字面量赋值
const char* str1 = "Hello";  // 指向只读内存

// 字符数组初始化  
char str2[] = "Hello";       // 在栈上创建可修改的副本
char* str3 = str2;           // 需要 & 吗？不需要！

// 因为 str2 是数组名，会自动退化为指针
char* str4 = str2;           // 正确，等价于 &str2[0]
char* str5 = &str2[0];       // 显式写法
```

## 7. 历史演变和现代C++

### C++98/03（不推荐）
```cpp
char* str = "Hello";  // 曾经允许，但危险！
// 可能允许修改只读内存，导致未定义行为
```

### C++11 起（推荐）
```cpp
const char* str = "Hello";    // 正确，安全
// 或者
auto str = "Hello";           // 自动推导为 const char*
```

## 8. 底层原理分析

编译时，字符串字面量被存储在程序的**只读数据段**：

```cpp
// 编译器生成的近似代码
.section .rodata
.LC0:
    .string "Hello"

.text
main:
    movl    $.LC0, %eax    // 将字符串地址加载到寄存器
    movl    %eax, -8(%ebp) // 存储到指针变量
```

## 总结

`const char* str = "Hello"` 的特殊性在于：

1. **字符串字面量是数组**：`"Hello"` 实际上是 `const char[6]`
2. **数组到指针 decay**：在需要指针的语境下，数组名自动转换为指针
3. **编译器魔法**：编译器处理字符串字面量的存储和地址分配
4. **类型安全**：现代C++要求使用 `const char*` 确保只读性

这就是为什么字符串字面量可以直接赋值给指针，而其他类型通常需要显式取址的原因。