在 C++ 中，数组作为函数参数是一个重要但容易混淆的话题。我来详细讲解几种情况和背后的原理。

## 1. 基本语法和现象

### 示例 1：数组参数退化为指针
```cpp
void func(int arr[5]) {  // 这里的 5 实际上被编译器忽略
    cout << sizeof(arr) << endl; // 输出指针大小（如 8），不是数组大小
}

int main() {
    int myArr[5] = {1, 2, 3, 4, 5};
    cout << sizeof(myArr) << endl; // 输出 20（5 * 4）
    func(myArr); // 输出 8（指针大小）
    return 0;
}
```

**关键点**：数组作为函数参数时，会**退化为指向首元素的指针**。

---

## 2. 等价的函数声明

以下三种声明是**完全等价**的：
```cpp
void func(int arr[5]);
void func(int arr[]);  
void func(int* arr);    // 最诚实的写法
```

编译器都会把它们当作 `int* arr` 来处理。

---

## 3. 需要数组大小信息时的解决方案

### 方案 1：显式传递大小参数（最常用）
```cpp
void processArray(int* arr, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        cout << arr[i] << " ";
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    processArray(arr, sizeof(arr)/sizeof(arr[0]));
    return 0;
}
```

### 方案 2：使用模板获取大小（C++）
```cpp
template <size_t N>
void processArray(int (&arr)[N]) {  // 引用传递，不会退化
    for (size_t i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << "Array size: " << N << endl;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    processArray(arr); // 编译器自动推导 N=5
    return 0;
}
```

**优点**：不需要手动传递大小，类型安全。

---

## 4. 多维数组作为参数

### 正确写法：必须指定除第一维外所有维度的大小
```cpp
// 正确：第二维必须指定大小
void printMatrix(int matrix[][3], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}

// 错误：不能只写 int matrix[][]
// 错误：不能只写 int** matrix（内存布局不同）
```

### 模板版本（更安全）：
```cpp
template <size_t Rows, size_t Cols>
void printMatrix(int (&matrix)[Rows][Cols]) {
    for (size_t i = 0; i < Rows; ++i) {
        for (size_t j = 0; j < Cols; ++j) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}
```

---

## 5. 数组引用传递（不退化）

使用引用可以保持数组类型信息：
```cpp
void func(int (&arr)[5]) {  // 必须精确匹配大小
    cout << sizeof(arr) << endl; // 输出 20（真正的数组大小）
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    func(arr);
    
    // int arr2[10] = {};
    // func(arr2); // 错误：大小不匹配
    return 0;
}
```

---

## 6. 现代 C++ 推荐做法

### 使用 `std::array`（替代原生数组）
```cpp
#include <array>

void processStdArray(const std::array<int, 5>& arr) {
    cout << "Size: " << arr.size() << endl;
    for (int elem : arr) {
        cout << elem << " ";
    }
}

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    processStdArray(arr);
    return 0;
}
```

### 使用 `std::vector`（动态大小）
```cpp
#include <vector>

void processVector(const std::vector<int>& vec) {
    cout << "Size: " << vec.size() << endl;
    for (int elem : vec) {
        cout << elem << " ";
    }
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    processVector(vec);
    return 0;
}
```

---

## 7. 关键总结

| 传递方式 | 语法 | 是否退化 | 大小信息 |
|----------|------|----------|-----------|
| 值传递 | `int arr[]` | 是（退化为指针） | 丢失 |
| 指针传递 | `int* arr` | 是 | 需要额外参数 |
| 引用传递 | `int (&arr)[N]` | 否 | 保留 |
| `std::array` | `const std::array<int,N>&` | 否 | 保留 |
| `std::vector` | `const std::vector<int>&` | 否 | 保留 |

**最佳实践建议**：
1. 优先使用 `std::vector` 或 `std::array`
2. 如果必须用原生数组，使用引用传递或显式传递大小
3. 避免在函数参数中写 `int arr[]` 这种误导性语法

理解数组参数退化的机制对于避免缓冲区溢出和其他内存错误非常重要！