非常好的问题！这确实是一个值得深入探讨的设计选择。

## 1. 返回值的作用

`strcpy` 和 `strcat` 返回 `char*` 主要是为了**支持链式操作**（chaining）。

### 链式操作示例
```cpp
#include <cstring>
#include <iostream>
using namespace std;

int main() {
    char path[100];
    
    // 链式操作 - 一行代码完成多次拼接
    strcpy(strcat(strcat(strcpy(path, "/home"), "/user"), "/documents");
    
    cout << path << endl;  // 输出: /home/user/documents
    
    return 0;
}
```

## 2. 对比有无返回值的情况

### 有返回值（实际设计）：
```cpp
char result[100];
strcpy(strcat(strcpy(result, "Hello"), " World"), "!");
// result = "Hello World!"
```

### 如果设计为 void（假设）：
```cpp
char result[100];
strcpy(result, "Hello");
strcat(result, " World"); 
strcat(result, "!");
// 需要三行代码
```

## 3. 历史背景和设计哲学

### C语言的设计理念
- **简洁性**：鼓励编写紧凑的代码
- **效率**：减少临时变量和中间步骤
- **函数式风格**：函数可以嵌套调用

### 当时的编程环境
- 内存有限，代码量要尽量小
- 编译器优化能力有限，手动优化更重要

## 4. 实际应用场景

### 文件路径构建
```cpp
char fullpath[256];
strcpy(strcat(strcpy(fullpath, basepath), "/"), filename);
```

### 字符串初始化
```cpp
char buffer[100];
// 一次性初始化和拼接
strcat(strcpy(buffer, "Error: "), error_message);
```

## 5. 现代C++中的替代方案

### 使用 `std::string`（推荐）
```cpp
#include <string>
using namespace std;

string path = string("/home") + "/user" + "/documents";
// 或者
string path;
path.append("/home").append("/user").append("/documents");
```

### 流操作
```cpp
#include <sstream>
using namespace std;

ostringstream oss;
oss << "/home" << "/user" << "/documents";
string path = oss.str();
```

## 6. 返回值的具体值

这些函数返回的是**目标字符串的指针**：

```cpp
char dest[100];
char* result = strcpy(dest, "Hello");

cout << (result == dest) << endl;  // 输出 1（true）
cout << result << endl;            // 输出 Hello
```

## 7. 争议和问题

### 优点
- **代码简洁**：减少临时变量
- **表达力强**：一行代码完成复杂操作
- **符合UNIX哲学**：做一件事并做好

### 缺点
- **可读性差**：嵌套调用难以理解
- **调试困难**：难以设置断点
- **错误处理复杂**：难以单独处理每个步骤的错误
- **安全性问题**：容易导致缓冲区溢出

## 8. 安全版本的发展

### 传统版本（不安全）
```cpp
char buffer[10];
strcpy(buffer, "This is too long!");  // 缓冲区溢出！
```

### 安全版本（C11）
```cpp
char buffer[10];
strcpy_s(buffer, sizeof(buffer), "Hello");  // 带长度检查
```

### 现代C++做法
```cpp
std::string buffer = "This can be as long as needed";
```

## 9. 为什么现代代码不推荐这种设计

### 可读性对比
```cpp
// 传统C风格（不推荐）
strcpy(strcat(strcpy(path, base), "/"), file);

// 现代清晰写法（推荐）
std::string path = std::string(base) + "/" + file;

// 或者分步明确写法
std::string path = base;
path += "/";
path += file;
```

### 安全性对比
```cpp
// 危险：可能缓冲区溢出
char path[100];
strcpy(path, very_long_string);

// 安全：自动管理内存
std::string path = very_long_string;
```

## 10. 总结

**为什么设计为返回 `char*`：**
- ✅ 历史原因：C语言追求简洁和链式操作
- ✅ 实用价值：在某些场景下确实方便
- ✅ 设计一致性：符合C标准库的设计哲学

**现代编程的建议：**
- 🔴 避免在C++中过度使用这种链式操作
- ✅ 优先使用 `std::string` 和现代C++特性
- ✅ 如果必须使用C字符串，考虑安全性版本
- ✅ 重视代码可读性和可维护性

这个设计是特定历史环境下的产物，在现代C++开发中，我们更推荐使用更安全、更易读的替代方案。