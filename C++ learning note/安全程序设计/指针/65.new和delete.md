好的，我们来详细讲解C++中的 `new` 和 `delete` 运算符。

## 1. 基本概念

`new` 和 `delete` 是C++中用于**动态内存管理**的运算符，它们替代了C语言中的 `malloc()` 和 `free()` 函数。

### 主要区别对比：
| 特性 | C的malloc/free | C++的new/delete |
|------|----------------|-----------------|
| 内存分配 | 只分配原始内存 | 分配内存并调用构造函数 |
| 内存释放 | 只释放内存 | 调用析构函数并释放内存 |
| 返回值 | `void*` 需要强制转换 | 返回正确类型的指针 |
| 异常处理 | 返回NULL | 抛出 `std::bad_alloc` 异常 |

## 2. 基本用法

### 单个对象的动态分配
```cpp
#include <iostream>
using namespace std;

class Person {
public:
    string name;
    int age;
    
    Person(string n, int a) : name(n), age(a) {
        cout << "构造函数被调用" << endl;
    }
    
    ~Person() {
        cout << "析构函数被调用" << endl;
    }
    
    void introduce() {
        cout << "我是" << name << ", 今年" << age << "岁" << endl;
    }
};

int main() {
    // 使用new动态分配一个Person对象
    Person* p = new Person("张三", 25);
    
    p->introduce();  // 输出: 我是张三, 今年25岁
    
    // 使用delete释放内存
    delete p;
    
    return 0;
}
```

### 数组的动态分配
```cpp
int main() {
    // 分配基本类型数组
    int* arr = new int[10];
    
    for (int i = 0; i < 10; i++) {
        arr[i] = i * i;
    }
    
    // 释放数组 - 注意使用delete[]
    delete[] arr;
    
    // 分配对象数组
    Person* people = new Person[3]{
        Person("李四", 20),
        Person("王五", 30),
        Person("赵六", 40)
    };
    
    // 释放对象数组
    delete[] people;
    
    return 0;
}
```

## 3. new 的不同形式

### 3.1 普通的new
```cpp
int* p1 = new int(42);        // 分配一个int并初始化为42
Person* p2 = new Person("Alice", 25);  // 调用构造函数
```

### 3.2 不抛出异常的new (nothrow)
```cpp
#include <new>  // 需要包含这个头文件

int* p = new(nothrow) int[1000000000];
if (p == nullptr) {
    cout << "内存分配失败，但不抛出异常" << endl;
}
```

### 3.3 定位new (placement new)
在已分配的内存上构造对象：
```cpp
#include <new>

char buffer[sizeof(Person)];  // 预分配内存

// 在buffer位置构造Person对象
Person* p = new(buffer) Person("定位new", 99);
p->introduce();

// 需要显式调用析构函数
p->~Person();
```

## 4. 注意事项和最佳实践

### 4.1 必须配对使用
```cpp
// 正确用法
int* p1 = new int;
delete p1;

int* arr = new int[10];
delete[] arr;  // 注意是delete[]不是delete

// 错误用法 - 会导致未定义行为
int* p2 = new int;
// delete[] p2;  // 错误！应该用delete

int* arr2 = new int[10];
// delete arr2;  // 错误！应该用delete[]
```

### 4.2 内存泄漏问题
```cpp
void memory_leak() {
    int* p = new int(100);
    // 忘记delete p; - 内存泄漏！
    // 函数结束时指针p被销毁，但指向的内存没有被释放
}

void no_leak() {
    int* p = new int(100);
    // 使用内存...
    delete p;  // 正确释放
}
```

### 4.3 悬空指针问题
```cpp
int* create_number() {
    int* p = new int(42);
    return p;  // 返回动态分配的内存 - 调用者需要负责释放
}

void dangling_pointer_example() {
    int* ptr = create_number();
    cout << *ptr << endl;  // 正常使用
    
    delete ptr;  // 释放内存
    // 现在ptr成为悬空指针
    
    // cout << *ptr << endl;  // 危险！未定义行为
    
    ptr = nullptr;  // 好习惯：释放后立即设为nullptr
}
```

## 5. 现代C++的改进

### 5.1 智能指针（推荐使用）
```cpp
#include <memory>

void smart_pointer_example() {
    // 使用unique_ptr - 独占所有权
    std::unique_ptr<Person> p1 = std::make_unique<Person>("智能指针", 30);
    
    // 使用shared_ptr - 共享所有权
    std::shared_ptr<Person> p2 = std::make_shared<Person>("共享指针", 35);
    
    // 不需要手动delete - 自动管理生命周期
}
```

### 5.2 异常安全
```cpp
// 不安全的代码
void unsafe_function() {
    Person* p = new Person("测试", 20);
    some_function_that_might_throw();  // 如果这里抛出异常...
    delete p;  // 这行不会执行，内存泄漏！
}

// 安全的代码 - 使用智能指针
void safe_function() {
    auto p = std::make_unique<Person>("测试", 20);
    some_function_that_might_throw();  // 即使抛出异常，内存也会自动释放
}
```

## 6. 完整示例

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Resource {
private:
    string name;
    
public:
    Resource(string n) : name(n) {
        cout << "资源 " << name << " 被创建" << endl;
    }
    
    ~Resource() {
        cout << "资源 " << name << " 被销毁" << endl;
    }
    
    void use() {
        cout << "使用资源: " << name << endl;
    }
};

int main() {
    cout << "=== 传统new/delete用法 ===" << endl;
    {
        Resource* res = new Resource("传统方式");
        res->use();
        delete res;  // 必须手动释放
    }
    
    cout << "\n=== 智能指针用法 ===" << endl;
    {
        auto res = make_unique<Resource>("智能指针");
        res->use();
        // 自动释放，不需要delete
    }
    
    cout << "\n=== 数组用法 ===" << endl;
    {
        int size = 3;
        Resource** resources = new Resource*[size];
        
        for (int i = 0; i < size; i++) {
            resources[i] = new Resource("对象_" + to_string(i));
        }
        
        for (int i = 0; i < size; i++) {
            resources[i]->use();
        }
        
        // 先删除每个对象，再删除数组
        for (int i = 0; i < size; i++) {
            delete resources[i];
        }
        delete[] resources;
    }
    
    return 0;
}
```

## 总结

1. **new/delete** 是C++动态内存管理的基础
2. **必须配对使用**：`new` ↔ `delete`，`new[]` ↔ `delete[]`
3. **现代C++推荐使用智能指针**来避免内存管理错误
4. **遵循RAII原则**：资源获取即初始化，确保异常安全
5. **释放后设为nullptr** 可以避免悬空指针问题

在实际开发中，除非有特殊需求，否则应该优先使用智能指针而不是原始的 `new/delete`。