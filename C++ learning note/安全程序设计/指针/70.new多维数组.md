在C++中使用 `new` 创建动态二维数组有几种方法，我来详细讲解每种方法的实现和特点。

## 1. 方法一：指针数组方式（最常用）

### 1.1 基本用法
```cpp
#include <iostream>
using namespace std;

int main() {
    int rows = 3, cols = 4;
    
    // 步骤1：创建行指针数组
    int** arr = new int*[rows];
    
    // 步骤2：为每一行分配列数组
    for (int i = 0; i < rows; i++) {
        arr[i] = new int[cols];
    }
    
    // 初始化数据
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] = i * cols + j;  // 0,1,2,3,4,5...
        }
    }
    
    // 打印数组
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    
    // 释放内存：先释放每一行，再释放行指针数组
    for (int i = 0; i < rows; i++) {
        delete[] arr[i];  // 释放每一行
    }
    delete[] arr;  // 释放行指针数组
    
    return 0;
}
```

### 1.2 封装成函数
```cpp
#include <iostream>
using namespace std;

// 创建动态二维数组
int** create2DArray(int rows, int cols) {
    int** arr = new int*[rows];
    for (int i = 0; i < rows; i++) {
        arr[i] = new int[cols]();  // 使用()进行零初始化
    }
    return arr;
}

// 释放动态二维数组
void delete2DArray(int** arr, int rows) {
    for (int i = 0; i < rows; i++) {
        delete[] arr[i];
    }
    delete[] arr;
}

// 打印二维数组
void print2DArray(int** arr, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << arr[i][j] << "\t";
        }
        cout << endl;
    }
}

int main() {
    int rows = 4, cols = 5;
    
    int** matrix = create2DArray(rows, cols);
    
    // 初始化数据
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = (i + 1) * (j + 1);
        }
    }
    
    cout << "动态二维数组内容：" << endl;
    print2DArray(matrix, rows, cols);
    
    delete2DArray(matrix, rows);
    
    return 0;
}
```

## 2. 方法二：连续内存方式（性能更好）

### 2.1 单块连续内存
```cpp
#include <iostream>
using namespace std;

int main() {
    int rows = 3, cols = 4;
    
    // 分配单块连续内存
    int* flatArray = new int[rows * cols];
    
    // 使用二维索引访问
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            flatArray[i * cols + j] = i * cols + j;
        }
    }
    
    // 打印数组
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << flatArray[i * cols + j] << " ";
        }
        cout << endl;
    }
    
    // 只需一次delete[]
    delete[] flatArray;
    
    return 0;
}
```

### 2.2 封装访问类
```cpp
#include <iostream>
using namespace std;

class Matrix {
private:
    int rows, cols;
    int* data;
    
public:
    Matrix(int r, int c) : rows(r), cols(c) {
        data = new int[rows * cols]();  // 零初始化
    }
    
    ~Matrix() {
        delete[] data;
    }
    
    // 重载()运算符以便使用matrix(i, j)语法
    int& operator()(int i, int j) {
        return data[i * cols + j];
    }
    
    const int& operator()(int i, int j) const {
        return data[i * cols + j];
    }
    
    void print() const {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                cout << (*this)(i, j) << "\t";
            }
            cout << endl;
        }
    }
    
    int getRows() const { return rows; }
    int getCols() const { return cols; }
};

int main() {
    Matrix mat(3, 4);
    
    // 使用类似二维数组的语法
    for (int i = 0; i < mat.getRows(); i++) {
        for (int j = 0; j < mat.getCols(); j++) {
            mat(i, j) = (i + 1) * (j + 1);
        }
    }
    
    cout << "矩阵内容：" << endl;
    mat.print();
    
    return 0;
}
```

## 3. 方法三：混合方式（指针数组+连续内存）

```cpp
#include <iostream>
using namespace std;

int main() {
    int rows = 3, cols = 4;
    
    // 分配连续的内存块
    int* dataBlock = new int[rows * cols];
    
    // 分配行指针数组
    int** arr = new int*[rows];
    
    // 让每个行指针指向连续内存的相应位置
    for (int i = 0; i < rows; i++) {
        arr[i] = &dataBlock[i * cols];
    }
    
    // 现在可以像普通二维数组一样使用
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] = i * cols + j;
        }
    }
    
    // 打印
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    
    // 释放内存：先释放指针数组，再释放数据块
    delete[] arr;
    delete[] dataBlock;
    
    return 0;
}
```

## 4. 自定义类型的动态二维数组

### 4.1 对象数组
```cpp
#include <iostream>
#include <string>
using namespace std;

class Student {
public:
    string name;
    int score;
    
    Student() : name(""), score(0) {}
    Student(string n, int s) : name(n), score(s) {}
    
    void display() const {
        cout << name << ": " << score;
    }
};

int main() {
    int classes = 2, students = 3;
    
    // 创建Student的二维数组
    Student*** school = new Student**[classes];
    
    for (int i = 0; i < classes; i++) {
        school[i] = new Student*[students];
        for (int j = 0; j < students; j++) {
            school[i][j] = new Student("学生_" + to_string(i) + "_" + to_string(j), 
                                      (i + 1) * (j + 1) * 10);
        }
    }
    
    // 显示数据
    for (int i = 0; i < classes; i++) {
        cout << "班级 " << i + 1 << ":" << endl;
        for (int j = 0; j < students; j++) {
            school[i][j]->display();
            cout << "  ";
        }
        cout << endl;
    }
    
    // 释放内存
    for (int i = 0; i < classes; i++) {
        for (int j = 0; j < students; j++) {
            delete school[i][j];
        }
        delete[] school[i];
    }
    delete[] school;
    
    return 0;
}
```

## 5. 初始化技巧

### 5.1 使用列表初始化（C++11）
```cpp
#include <iostream>
using namespace std;

int main() {
    int rows = 2, cols = 3;
    
    int** arr = new int*[rows];
    for (int i = 0; i < rows; i++) {
        arr[i] = new int[cols]{1, 2, 3};  // 每行初始化为{1,2,3}
    }
    
    // 或者动态初始化
    int** arr2 = new int*[rows] {
        new int[cols]{1, 2, 3},
        new int[cols]{4, 5, 6}
    };
    
    // 打印
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << arr2[i][j] << " ";
        }
        cout << endl;
    }
    
    // 释放
    for (int i = 0; i < rows; i++) {
        delete[] arr[i];
        delete[] arr2[i];
    }
    delete[] arr;
    delete[] arr2;
    
    return 0;
}
```

## 6. 内存管理最佳实践

### 6.1 使用RAII类自动管理
```cpp
#include <iostream>
#include <memory>
using namespace std;

class Dynamic2DArray {
private:
    int** data;
    int rows, cols;
    
public:
    Dynamic2DArray(int r, int c) : rows(r), cols(c) {
        data = new int*[rows];
        for (int i = 0; i < rows; i++) {
            data[i] = new int[cols]();
        }
        cout << "创建 " << rows << "x" << cols << " 数组" << endl;
    }
    
    ~Dynamic2DArray() {
        for (int i = 0; i < rows; i++) {
            delete[] data[i];
        }
        delete[] data;
        cout << "释放 " << rows << "x" << cols << " 数组" << endl;
    }
    
    // 禁用拷贝（或实现深拷贝）
    Dynamic2DArray(const Dynamic2DArray&) = delete;
    Dynamic2DArray& operator=(const Dynamic2DArray&) = delete;
    
    int* operator[](int index) {
        return data[index];
    }
    
    const int* operator[](int index) const {
        return data[index];
    }
    
    int getRows() const { return rows; }
    int getCols() const { return cols; }
};

int main() {
    // 使用RAII类，自动管理内存
    Dynamic2DArray arr(3, 4);
    
    for (int i = 0; i < arr.getRows(); i++) {
        for (int j = 0; j < arr.getCols(); j++) {
            arr[i][j] = i * arr.getCols() + j;
        }
    }
    
    // 打印
    for (int i = 0; i < arr.getRows(); i++) {
        for (int j = 0; j < arr.getCols(); j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    
    // 不需要手动释放，析构函数自动处理
    return 0;
}
```

## 总结

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 指针数组 | 语法简单直观 | 内存不连续，多次分配 | 一般用途 |
| 连续内存 | 内存局部性好，一次分配 | 访问语法复杂 | 性能要求高 |
| 混合方式 | 语法简单且内存连续 | 实现稍复杂 | 需要平衡性能和易用性 |

**推荐做法：**
1. **一般情况**：使用方法一（指针数组）
2. **性能关键**：使用方法二（连续内存）+ 封装类
3. **生产环境**：使用RAII类或标准库容器

**重要提醒：**
- 始终配对使用 `new[]` 和 `delete[]`
- 释放时顺序：先内后外（先列后行）
- 考虑使用 `std::vector` 或智能指针来避免手动内存管理