这是一个非常核心且容易混淆的问题。简单直接的回答是：

**在几乎所有的现代计算机系统中，一个内存地址（二进制数）唯一对应的是一个字节（Byte），而不是一个字。**

但这只是基础，理解其背后的原理和细节更为重要。下面我们来详细解释。

---

### 1. 核心概念：字节寻址

现代计算机体系结构普遍采用 **“字节寻址”**。

*   **定义**：内存被划分为一系列连续的、以字节为单位的存储空间，每个字节都有一个唯一的地址（一个二进制数）。
*   **好比**：把内存想象成一栋巨大的公寓楼，**每一个字节就是楼里的一个单间**，而**地址就是每个单间的门牌号**。CPU要找数据，就是通过这个“门牌号”来定位的。

### 2. 那么“字”如何存储和寻址？

既然地址对应的是字节，那么比字节大的数据（如一个字、一个双字）如何存放呢？答案是：**占用多个连续的地址**。

*   **例子**：在一个32位系统（字长为32位，即4个字节）中，CPU要读取一个“字”。
    1.  CPU需要4个字节的数据。
    2.  它会使用一个**起始地址**（比如 `0x1000`），这个地址是这4个字节中第一个字节的地址。
    3.  这个“字”就占据了从 `0x1000` 到 `0x1003` 这四个连续的内存位置。

所以，当我们说“CPU从地址0x1000读取一个字”时，它实际上是从0x1000开始，连续读取了4个字节，然后将它们组合成一个完整的32位数。

### 3. 为什么是字节，而不是字？

采用字节作为最小可寻址单位的主要原因是 **灵活性**。

*   如果以“字”为寻址单位（比如在32位机器上，一个地址对应4字节），那么当你只需要读取或修改一个字符（char类型，占1字节）时，你也必须把整个4字节的字读出来，修改其中的一个字节，再把整个字写回去。这非常低效。
*   字节寻址使得程序可以高效地处理各种大小的数据，无论是单个字符（1字节）、短整数（2字节）、普通整数（4字节）还是长整数（8字节）。

### 4. 重要的例外与历史

虽然字节寻址是主流，但理解“字寻址”有助于你明白为什么现在是这个样子。

*   **早期计算机**：一些非常早期的计算机，或者某些特殊用途的硬件，确实采用过 **“字寻址”** 。在那个时代，计算机主要用来进行科学计算，处理的数据大多是固定长度的“字”，字符处理的需求不突出。
*   **地址空间的区别**：
    *   在**字节寻址**的机器上，如果你的地址总线是32位，你可以访问 2^32 个**字节**，也就是4GB的内存。
    *   在**字寻址**的机器上（假设字长为32位），同样是32位地址总线，你可以访问 2^32 个**字**。因为每个字是4字节，所以总内存容量是 2^32 * 4 Byte = 16GB。**但请注意，你无法直接访问这16GB里的某一个字节**。

### 5. 总结与类比

让我们用一个表格来清晰总结：

| 特性 | **字节寻址（现代主流）** | **字寻址（早期/特殊用途）** |
| :--- | :--- | :--- |
| **一个地址对应** | **一个字节（8位）** | **一个字（字长，如32位）** |
| **灵活性** | **高**，可高效处理字符等小数据 | **低**，处理小数据效率低下 |
| **数据访问** | 可精确访问任意一个字节 | 只能以“字”为单位进行访问 |
| **地址空间计算** | 32位地址 -> 4GB (**字节**) | 32位地址 -> 4G **字** (如字长32位，则总容量为16GB) |

**最终答案**：

**在你今天接触到的几乎所有计算机（x86, ARM, RISC-V等）中，一个内存地址（二进制数）指向的是一个字节的存储空间。当CPU需要读取一个字时，它会通过一个起始地址，连续读取多个字节来组合而成。**