好的！这个图是一个非常清晰的 **“字扩展”** 示例，我来为你专门、详细地讲解这个过程。

---

### 字扩展的核心目标

**目标**：增加存储器的**容量**（存储单元的数量），而**不改变**存储器的**数据位宽**。

在这个例子中：
*   **现有零件**：多片 `8K × 4位` 的RAM芯片。
    *   `8K`：表示有 8192 个存储单元。
    *   `× 4位`：表示每个存储单元已经可以存储4个比特。
*   **目标产品**：构造一个 `32K × 4位` 的存储器。
    *   `32K`：单元数量需要扩大为原来的4倍（32K / 8K = 4）。
    *   `× 4位`：数据位宽保持不变（仍是4位）。

### 字扩展的实现方法

如图所示，我们使用 **4片** `8K × 4位` 的芯片来共同覆盖一个更大的地址空间。

**==连接规则（“两统一异”原则）==：**

1.  **数据线统一连接**
    *   所有4片芯片的**4位数据线（D0-D3）** 都**并联**在一起，并连接到CPU数据总线的低4位上。
    *   **为什么？** 因为位宽不变，每次读写都是4位。并且在任何时刻，**只应有一个芯片**向数据总线输出数据，所以数据线可以共享。

2.  **读写控制信号统一连接**
    *   所有4片芯片的**读写控制信号** 都**并联**在一起，接到CPU的 `WE` 线上。
    *   **为什么？** 保证所有芯片在同一时刻都处于相同的操作状态（全部读或全部写），但实际上只有被选中的那片芯片会真正执行操作。

3.  **==地址线部分统一、部分异质（用于片选）==**
    *   这是字扩展最核心、最巧妙的地方。
    *   **低位地址线统一连接**：所有4片芯片的**地址引脚（A0-A12）** 都并联在一起，连接到CPU地址总线的 **A0-A12** 上。
        *   **为什么？** 这 **13根** 地址线用于寻址每个芯片**内部**的 `8K` (2^13 = 8192) 个单元。我们称这部分地址为 **“片内地址”**。
    *   **高位地址线用于生成片选**：CPU的地址总线还有更高的位（这里是 **A13和A14**）。这两根线被送入一个 **2-4译码器**。
        *   **为什么？** 这 **2根** 地址线用于区分我们要访问**哪一片**芯片。我们称这部分地址为 **“片选地址”**。
        *   一个2-4译码器有2个输入，4个输出。在任何时候，它的4个输出中**只有1个是有效的（低电平）**，其余3个为无效（高电平）。这个有效的输出信号就用来激活对应的那一片存储芯片。

### 地址空间分配

让我们来看看这个32K × 4的存储器是如何被映射到CPU的地址空间中的：

| CPU地址 (A14 A13 A12...A0) | 2-4译码器输出 | 被选中的芯片 | 访问的地址范围 (十进制) | 访问的地址范围 (十六进制) |
| :--- | :--- | :--- | :--- | :--- |
| **0 0** x xxxx xxxx xxxx | **Y0** (有效) | 芯片 1 | 0 - 8K-1 | 0x0000 - 0x1FFF |
| **0 1** x xxxx xxxx xxxx | **Y1** (有效) | 芯片 2 | 8K - 16K-1 | 0x2000 - 0x3FFF |
| **1 0** x xxxx xxxx xxxx | **Y2** (有效) | 芯片 3 | 16K - 24K-1 | 0x4000 - 0x5FFF |
| **1 1** x xxxx xxxx xxxx | **Y3** (有效) | 芯片 4 | 24K - 32K-1 | 0x6000 - 0x7FFF |

*注：表中的 'x' 代表片内地址 A12-A0，可以从 0 变化到 8191。*

### 工作过程模拟

假设CPU要**读取**内存地址 `0x5234`（二进制为 `0101 0010 0011 0100`）。

1.  **解析地址**：CPU将地址 `0x5234` 分解：
    *   高位（片选地址）：**A14 A13 = `1 0`**
    *   低位（片内地址）：**A12-A0 = `1 0010 0011 0100`** (即十进制 4660)

2.  **发送信号**：
    *   CPU将片内地址 (`4660`) 送到地址总线 A0-A12，所有4片芯片都收到了这个地址。
    *   CPU将片选地址 (`1, 0`) 送到 A14, A13，输入给 **2-4译码器**。

3.  **芯片选择**：
    *   2-4译码器根据输入 `10`，激活其 **Y2** 输出线（假设低电平有效），其他输出（Y0, Y1, Y3）无效。
    *   **只有芯片3** 的 `CE` 引脚被激活，芯片3被选中。芯片1, 2, 4 因未被选中而处于高阻态，其数据线与总线断开。

4.  **执行操作**：
    *   CPU发出**读命令**（`WE` 信号为高电平）。
    *   **被选中的芯片3** 根据片内地址 `4660`，将其内部该单元存储的4位数据放到数据总线（D0-D3）上。
    *   CPU从数据总线上读取到这4位数据。

**写入过程**与之类似，只有被片选信号选中的芯片才会执行写入操作。

### 总结

**==字扩展的本质==**：将多个容量小的芯片 **==串联==** 到不同的地址区间上，通过**高位地址线译码**产生的**片选信号**来唯一选中其中一个芯片工作。它解决了 **“地址空间小”** 的问题。

你可以把它想象成：
> 一栋大楼（32K容量）被分成了4个楼层（每层8K容量）。**楼层号（A14, A13）** 就是片选地址，通过一个楼层控制器（2-4译码器）来决定电梯停靠哪一层。**房间号（A0-A12）** 就是片内地址，在同一层的所有房间都共享这个编号系统。无论你要去哪个房间，都必须先通过楼层控制器到达正确的楼层。