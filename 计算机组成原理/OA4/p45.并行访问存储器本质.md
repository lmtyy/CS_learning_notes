好的，我们来深入讲解你课件中这两句关于 **并行访问存储器实质** 的总结。这两句话非常精炼，点破了之前讲的“单体多字”方式的本质。

---

## 第一句话：结构上的转变

> **“把 m 字 w 位的存储器改变成 m/n 字 n×w 位的存储器。”**

### 我们来拆解这句话：

- **原始存储器（传统方式）**：
  - 容量：`m` 个存储单元
  - 字长：每个单元 `w` 位
  - 总容量 = `m × w` 位

- **并行访问存储器（单体多字方式）**：
  - 容量：`m/n` 个存储单元
  - 字长：每个单元 `n × w` 位
  - 总容量 = `(m/n) × (n × w) = m × w` 位

**核心转变**：
- **单元数量变少**：从 `m` 个单元变成了 `m/n` 个单元。
- **每个单元的“宽度”变大**：从 `w` 位变成了 `n × w` 位。

### 举例说明：
假设原来有一个存储器：
- `m = 1024` 个地址
- 每个地址存放 `w = 8` 位（1个字节）

现在采用 **4体并行（n=4）的单体多字方式**：
- 新的存储器被组织成 `1024 / 4 = 256` 个存储单元。
- 每个单元存放 `4 × 8 = 32` 位数据。
- 当你访问一个地址（比如地址0）时，你不再只得到8位数据，而是会一次性得到**4个连续地址**（地址0,1,2,3）的数据，总共32位。

**实质**：这是一种 **逻辑上的“打包”**。它没有改变总容量，但改变了访问的粒度和每次访问能获取的数据量。

---

## 第二句话：地址码的划分

> **“把地址码分成两部分，一部分选址，一部分选择数据。”**

在进行了上述的结构转变后，CPU发出的原始地址码需要被重新解释。

### 地址码的划分：

我们继续用上面的例子（m=1024, w=8, n=4）：
- CPU的原始地址线需要能寻址 1024 个单元，所以需要 10 位地址线（2^10=1024）。

在并行访问存储器中：
1.  **选址部分（高位地址）**：
    - 由于现在只有 256 个“宽单元”，所以只需要 **8 位地址线** (2^8=256) 来选择具体是哪一个“宽单元”。
    - 这8位地址就是原始10位地址中的 **高位部分**。

2.  **选择数据部分（低位地址）**：
    - 当你读出一个32位的“宽字”后，CPU可能只需要其中的某一个8位字节。
    - 因此，需要原始地址中的 **低2位** 来指明这个32位宽字中的 **哪一个8位字节** 是CPU真正需要的。
    - 低2位地址（00, 01, 10, 11）分别对应这个宽字中的第1、2、3、4个字节。

### 工作流程：
1.  CPU发出地址，比如 `00000010 11`（二进制）。
2.  地址控制器将地址拆分：
    - **高位 `00000010`**：送入地址寄存和译码器，选中第 `00000010`（十进制2）号“宽单元”。
    - **低位 `11`**：作为“字节选择”信号。
3.  存储器将第2号宽单元（包含原始地址2,3,4,5的数据）整个读出。
4.  根据低位 `11`，从读出的32位数据中，选出最后8位（对应原始地址5的数据）送给CPU。

---

## 总结与联系

这两句话共同揭示了并行访问存储器的核心实质：

1.  **第一句话** 描述了 **物理/逻辑结构的重组**：通过将多个窄存储单元“并联”成一个宽的存储单元，来实现一次访问获取多个数据。
2.  **第二句话** 描述了 **为此结构服务的地址寻址机制**：必须将地址重新划分，一部分用于寻址重组后的宽单元，另一部分用于从宽单元中挑选出目标数据。

这种设计完美地解释了 **“单体多字”** 的工作方式。它的优点是**高带宽**，缺点是**灵活性差**（必须一次性读取整个“包”，即使你只需要其中的一小部分）。这正好与更灵活但控制更复杂的 **“多体并行”** 方式形成对比。