好的，这份资料是关于 **正数补码的移位规则**，分为单符号位和双符号位两种情况。我来为你清晰地梳理一下。

---

## 1. 单符号位正数补码移位

对于一个正数，其补码与原码相同。

**规则：**
- **左移**：各位左移，**最低位补 0**，最高位（符号位）被移出，用 0 填补符号位（因为正数左移后仍应为正数，且不能溢出）。
- **右移**：各位右移，**最高位（符号位）保持不变**，数值位右移，**最低位丢弃**。

**例子：**
- 初始：`0 0111` （十进制 7）
- **左移**：`0 1110` （符号位 0 不变，末位补 0 → 十进制 14，相当于 ×2）
- **右移**：`0 0011` （符号位 0 不变，最低位 1 丢弃 → 十进制 3，相当于 ÷2）

---

## 2. 双符号位正数补码移位

双符号位用于扩大表示范围并方便判断溢出。

**规则：**
- **左移**：整体左移，**最低位补 0**，**第一符号位（真正的符号）保持不变**，第二符号位被数值最高位覆盖。
- **右移**：整体右移，**最高位（第一符号位）保持不变**并复制到第二符号位，数值位右移，最低位丢弃。

**例子：**
- 初始：`00 0111` （十进制 7）
- **左移一次**：`00 1110` （十进制 14）
- **左移两次**：`01 1100` （此时第一符号位仍是 0，但第二符号位变为 1，可能表示即将溢出）
- **右移一次**：`00 0011` （十进制 3）

---

## 3. 资料中的例子解析

我们来看资料里给出的具体运算：

**初始值（双符号位）：** `000111` （即 `00 0111` = 7）

1. **左移一次**：
   - `000111` → `001110` （`00 1110` = 14）
   - 规则：数符（第一符号位 0）不变，空位（最低位）补 0。

2. **再左移一次**：
   - `001110` → `011100` （`01 1100` = 28）
   - 此时第二符号位变为 1，若再左移可能溢出。

3. **右移一次**：
   - `011100` → `001110` （`00 1110` = 14）
   - 规则：第一符号位 0 保持不变，并复制到第二符号位，最低位丢弃。

4. **再右移一次**：
   - `001110` → `000111` （`00 0111` = 7）
   - 回到初始值。

---

## 4. 易错点提醒

资料最后特别指出易错处：

- `001110` 左移：  
  正确应为 `011100`  
  错误可能：`011100` 写成 `010000` 或其他，误改变了符号位或补位不对。

- `011100` 右移：  
  正确应为 `001110`  
  错误可能：只保留一个符号位，或补位错误。

**核心原则：**
- **单符号位**：符号位绝对不变，空位补 0。
- **双符号位**：第一符号位绝对不变，右移时它复制到第二符号位，空位补 0。

---

## 5. 总结

正数补码移位相对简单，关键是：
1. **保持符号位不变**（单符号位就是符号位，双符号位是第一符号位）。
2. **空位一律补 0**。
3. 双符号位的设计是为了在运算过程中通过观察第二符号位的变化来提前发现溢出风险。