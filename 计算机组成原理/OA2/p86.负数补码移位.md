好的，这份资料是关于 **负数补码的移位规则**，同样分为单符号位和双符号位。它与正数补码移位的最大区别在于 **右移时空位补1**。我来为你详细解析。

---

## 1. 单符号位负数补码移位

对于一个负数，其补码表示的特点是：符号位为 1，数值位是原码“取反加1”的结果。

**规则：**
- **左移**：各位左移，**最低位补 0**，最高位（符号位）被移出，但**用原符号位 1 填补**（实际上硬件设计会保持符号位不变，这里指数值高位左移，符号位保持 1）。
- **右移**：各位右移，**最高位（符号位）保持不变**，数值位右移，**空出的高位补 1**（因为负数的符号位是 1）。

**例子（资料中）：**
- 初始：`1 1011` （求原码：取反加1 → `1 0101` = -5）
- **左移**：`1 0110` （取反加1 → `1 1010` = -10，相当于 ×2）
- **右移**：`1 1101` （取反加1 → `1 0011` = -3，相当于 ÷2，注意 -5 ÷ 2 = -3 在整数除法中成立）

---

## 2. 双符号位负数补码移位

双符号位的负数，其两个符号位都是 1（例如 `11` 表示负数）。

**规则：**
- **左移**：整体左移，**最低位补 0**，**第一符号位（真正的符号 1）保持不变**，第二符号位被数值最高位覆盖。
- **右移**：整体右移，**最高位（第一符号位 1）保持不变**并复制到第二符号位，数值位右移，**空出的高位补 1**。

**例子（资料中）：**
- 初始：`11 0110`
- **左移一次**：`11 0110` → `10 1100` （第一符号位保持 1，第二符号位被覆盖为 0，数值左移，末位补 0）
- **右移一次**：`10 1100` → `11 0110` （第二符号位要移回来）
- **再右移**：`11 0110` → `11 1011` （高位补 1，最低位丢弃）

---

## 3. 资料中的例子逐步解析

**初始值（双符号位）：** `110110` （即 `11 0110` = -10）

1. **左移一次**：
   - `110110` → `101100` （`10 1100`）
   - 规则：数符（第一符号位 1）不变，空位（最低位）补 0。

2. **再左移一次（可能溢出）**：
   - `101100` → `011000` （`01 1000`）
   - 此时第一符号位被数值位覆盖成 0，表示已经溢出（负数变成正数）。

3. **右移一次**：
   - `110110` → `111011` （`11 1011` = -5）
   - 规则：第一符号位 1 保持不变，并复制到第二符号位，空出的高位补 1，最低位丢弃。

4. **再右移一次**：
   - `111011` → `111101` （`11 1101` = -3）
   - 继续高位补 1。

---

## 4. 易错点提醒

资料最后用简写指出易错处：

- `110110` 左移：  
  正确应为 `101100`  
  易错：可能错误地补 1 或者改变符号位。

- `101100` 右移：  
  正确应为 `110110`（如果回移）或 `111011`（如果继续右移）  
  易错：右移时空位补 0（错误），应该补 1。

**核心原则（负数补码）：**
- **左移**：低位补 0。
- **右移**：高位补 1（符号位扩展）。
- **符号位不变**（单符号位就是符号位，双符号位是第一符号位）。

---

## 5. 总结

负数补码移位的要诀：
1. **左移与正数相同**：空位补 0。
2. **右移与正数不同**：空位补 1（因为要维持负数的符号扩展）。
3. 双符号位在左移时，若数值位把第一符号位覆盖成 0，则表示溢出（负数变成了正数）。