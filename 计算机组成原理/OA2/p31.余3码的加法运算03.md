您这个问题问到了点子上，触及了计算机运算中一个最根本的概念：**不同抽象层级的分工**。

简单直接的回答是：**因为这个“1”是一个“进位信号”，而不是一个“需要存储的十进制数位”。** 它处于不同的抽象层级。

让我们来详细拆解一下：

### 1. 角色不同：数据 vs. 控制信号

*   **需要余3码表示的是什么？** 是最终运算结果中的**每一位十进制数字**。比如结果13，它的十位“1”和个位“3”都是需要被存储或显示的数据。这些数据必须被编码（如用余3码）才能被计算机处理。
*   **这个进位的“1”是什么？** 它是加法器电路在完成个位计算后，产生的一个**物理电信号**。这个信号的作用是**通知下一级电路（十位加法器）**：“我这边溢出了，你需要在自己的计算结果上加1”。它是一个**控制信号**或**状态信号**，而不是数据本身。

**类比：算盘**
你用算盘计算 `7+6`。
1.  你在个位档拨上7颗珠子，再拨上6颗珠子。个位档满10了。
2.  **你的大脑会产生一个念头：“个位满十了，需要向十位进一”**。这个“念头”就是**进位信号**。
3.  然后，你**执行**这个念头：在十位档拨上1颗珠子，再把个位档剩下的3颗珠子留下。
4.  最终，十位档的“1”和个位档的“3”才是**结果数据**。

在这里，**你大脑产生的“进位念头”本身，不需要在算盘上表示出来**。它只是一个临时的、用于指导下一步操作的控制指令。

### 2. 生命周期不同：临时 vs. 持久

*   **进位信号（这个“1”）**：它的生命周期非常短暂。它只在个位运算完成之后、十位运算开始之前这个瞬间存在并起作用。一旦十位加法器利用这个信号完成了自身的计算，这个进位信号的使命就结束了，它本身不会被存储到最终的结果寄存器里。
*   **结果数据（十位的“1”）**：这个数据是需要被持久化保存的，可能是存回内存，也可能是准备送给显示器。它有更长的生命周期，所以必须有一个规范的编码形式（如余3码）。

### 3. 硬件实现的角度看

计算机的运算是由**加法器**这种硬件电路完成的。一个带进位链的多位加法器是这样工作的：

*   **最低位加法器**：输入是A₀和B₀，以及进位输入Cin（通常为0）。它输出结果S₀和进位输出Cout。
*   **这个Cout**会**直接连接**到**下一位加法器**的**进位输入Cin**上。
*   **下一位加法器**：输入是A₁, B₁和上一位来的Cin。它输出S₁和新的Cout。

在这个过程中，进位就像接力棒一样，从低位传到高位。它始终是电路内部的一根导线上的**高电平（代表1）或低电平（代表0）**。这根导线的作用就是传递“是否需要加1”这个信息。**硬件电路不需要把导线上的电压值再翻译成余3码**，它直接使用这个电压值作为输入之一。

### 总结

我们可以用一张表来清晰对比：

| 特征 | 进位的“1” (进位信号) | 十位的“1” (结果数据) |
| :--- | :--- | :--- |
| **身份** | **控制信号 / 状态标志** | **需要存储的数值数据** |
| **作用** | 指导高位运算的**指令** | 运算结果的**组成部分** |
| **生命周期** | **临时**，运算过程中瞬时存在 | **持久**，需要被保存或输出 |
| **表示形式** | 物理电信号（高/低电压） | 二进制编码（如余3码 `0100`） |
| **类比** | 算盘运算时大脑产生的“进位”念头 | 算盘上十位档拨的那一颗珠子 |

所以，结论就是：**余3码是一种“数据编码格式”，用于表示“数值”。而进位是一个“控制信号”，用于连接运算步骤。两者处在不同的逻辑层次上，因此进位不需要被编码成余3码。** 它的唯一任务就是去触发高位加法器执行“加1”操作，而这个操作最终会产生出一个新的、用余3码表示的十位数字。