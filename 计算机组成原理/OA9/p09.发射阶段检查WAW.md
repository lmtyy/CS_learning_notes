这是一个非常好的问题，也是理解记分板关键设计思想的核心。很多人的直觉是：WAW（写后写）应该在“写回”阶段检查才对，为什么在“发射”阶段就管了呢？

让我们来深入拆解一下。

### 核心原因：维护“寄存器目标”的唯一性

记分板的核心设计思想是：**在指令发射的瞬间，就为它的“结果”（即要写入的寄存器）在记分板中建立一个“预订”或“锁”**。

这个“预订”意味着：
1.  **这个寄存器即将被这条指令写入。**
2.  **在它写入之前，任何后续指令都不能再预订这个寄存器。**

如果在发射时不检查WAW，就会发生以下情况：

#### 举一个例子：
假设我们有两条指令都写同一个寄存器 R1。

```
指令A： MUL.D  F1, F2, F3   ; 计算一个值，写入F1（耗时多个周期）
指令B： ADD.D  F1, F4, F5   ; 计算另一个值，也写入F1（耗时1个周期）
```

**情景1：发射时不检查WAW（错误的设计）**
1.  指令A发射。记分板记录：`Destination = F1`。
2.  由于ADD.D的源操作数F4, F5都就绪，且功能单元空闲，指令B也立即发射。记分板也记录：`Destination = F1`。现在有两条指令都宣称自己要写F1。
3.  ADD.D执行速度更快，先计算完成。
4.  ADD.D进入写回阶段，将结果写入F1。
5.  此时，F1中的值是ADD.D的结果。
6.  过了很久，MUL.D终于计算完成，它也进入写回阶段，将结果写入F1。
7.  **最终，F1中的值是MUL.D的结果，ADD.D的结果被覆盖了！**

**问题所在：** 这造成了错误的执行结果。从程序语义上讲，F1应该保存的是最后一条指令（ADD.D）的结果，但实际保存的却是更早的指令（MUL.D）的结果。这就是WAW冒险导致的错误。

---

**情景2：发射时检查WAW（正确的设计）**
1.  指令A发射。记分板记录：`Destination = F1`。
2.  指令B准备发射。它也要写F1。记分板检查发现：**“等等，F1已经被之前某条指令预订为写入目标了，虽然它还没写，但这个‘名分’已经被占了”**。
3.  因此，记分板**阻止指令B发射**。指令B在发射阶段停滞。
4.  直到指令A完成写回，释放了对F1的“预订”。
5.  指令B现在可以发射了，它成功预订F1，然后执行、写回。
6.  **最终，F1中的值是正确的指令B（ADD.D）的结果。**

### 为什么不在写回阶段解决？

因为到写回阶段就太晚了！WAW冒险的本质是**程序逻辑顺序**被破坏。记分板通过**按序发射**来维护这个顺序。

- **发射阶段**是决定“谁可以开始执行”的**调度关口**。一旦通过这个关口，指令就获得了执行和写回的“权利”。
- 如果在写回阶段才解决，就意味着两条指令都获得了写回的权利，那么谁先写回就由它们的执行速度决定了，这破坏了程序的原始顺序。

### 类比理解

可以把记分板想象成一个**酒店前台**，寄存器是**房间**，写操作是**入住**。

- **WAW**：两个客人都预订了同一个房间（比如301房）。
- **错误做法**：让两个客人都拿到301房的钥匙。谁先到谁先入住，后到的人会把先到的人赶走，自己入住。这显然乱了套。
- **正确做法（记分板）**：第一位客人（指令A）办理入住时，前台就在房间状态表上标记“301房-已预订”。第二位客人（指令B）也要301房时，前台看到已预订，就让他**在柜台前等待**，直到第一位客人**退房**（指令A写回完成，清除预订），才为第二位客人办理入住。

### 总结

在记分板中，**发射阶段检查WAW**是为了：

1.  **维护程序正确性**：确保寄存器最终的值是由程序中最后一条写该寄存器的指令决定的，而不是由执行速度决定的。
2.  **简化控制逻辑**：在指令进入乱序执行的核心管道（读操作数、执行）之前，就解决好所有的**目标冲突**。这样，在执行和写回阶段，就只需要关心数据就绪问题（RAW）和资源冲突，而不用再操心指令间的“写顺序”问题。
3.  **实现按序发射**：这是记分板机制的基础。通过按序发射并检查结构冒险（WAR/WAW），它才能在允许乱序执行和乱序完成的同时，保证最终结果的正确性。