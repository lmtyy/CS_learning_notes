Java自带的堆是通过 `PriorityQueue` 类实现的。以下是常用的堆操作：

## 1. 创建堆

```java
// 最小堆（默认）
PriorityQueue<Integer> minHeap = new PriorityQueue<>();

// 最大堆 - 使用比较器
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

// 自定义比较器的堆
PriorityQueue<Pair> customHeap = new PriorityQueue<>((a, b) -> {
    return b.times.compareTo(a.times);  // 按times降序
});

// 指定初始容量
PriorityQueue<Integer> heap = new PriorityQueue<>(100);
```

## 2. 基本操作

### 添加元素
```java
PriorityQueue<Integer> heap = new PriorityQueue<>();

// 添加元素 - 两种方式
heap.offer(5);    // 推荐，返回boolean
heap.add(3);      // 同样可以，但失败时抛异常

heap.offer(8);
heap.offer(1);
heap.offer(4);
```

### 访问堆顶元素
```java
// 查看堆顶元素（不删除）
Integer top = heap.peek();  // 返回1（最小堆的最小值）
System.out.println(top);    // 输出: 1

// 堆为空时返回null
PriorityQueue<Integer> emptyHeap = new PriorityQueue<>();
Integer result = emptyHeap.peek();  // 返回null
```

### 删除堆顶元素
```java
// 删除并返回堆顶元素
Integer removed = heap.poll();  // 返回1，堆中剩余: [3, 4, 5, 8]
System.out.println(removed);    // 输出: 1

// 堆为空时返回null
Integer fromEmpty = emptyHeap.poll();  // 返回null
```

## 3. 其他常用操作

### 检查堆大小和空状态
```java
int size = heap.size();        // 获取元素个数
boolean isEmpty = heap.isEmpty();  // 检查是否为空

System.out.println("Size: " + size);      // 输出: Size: 4
System.out.println("Empty: " + isEmpty);  // 输出: Empty: false
```

### 检查元素是否存在
```java
boolean contains = heap.contains(5);  // 检查是否包含元素5
System.out.println(contains);          // 输出: true
```

### 清空堆
```java
heap.clear();          // 清空所有元素
System.out.println(heap.isEmpty());  // 输出: true
```

### 转换为数组
```java
Object[] array = heap.toArray();           // 转换为Object数组
Integer[] typedArray = heap.toArray(new Integer[0]);  // 转换为指定类型数组
```

## 4. 遍历堆

```java
PriorityQueue<Integer> heap = new PriorityQueue<>();
heap.offer(5);
heap.offer(3);
heap.offer(8);
heap.offer(1);

// 方法1: 依次弹出（按顺序）
System.out.println("按顺序遍历:");
while (!heap.isEmpty()) {
    System.out.print(heap.poll() + " ");  // 输出: 1 3 5 8
}

// 重新添加元素
heap.offer(5);
heap.offer(3);
heap.offer(8);
heap.offer(1);

// 方法2: 转换为数组（不保证顺序）
System.out.println("\n转换为数组:");
Object[] array = heap.toArray();
for (Object num : array) {
    System.out.print(num + " ");  // 可能不是有序的
}

// 方法3: 使用迭代器（不保证顺序）
System.out.println("\n使用迭代器:");
Iterator<Integer> iterator = heap.iterator();
while (iterator.hasNext()) {
    System.out.print(iterator.next() + " ");  // 可能不是有序的
}
```

## 5. 实际应用示例

### Top K 问题
```java
// 找出前K个最大的元素
public List<Integer> topKMax(int[] nums, int k) {
    // 使用最小堆
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    
    for (int num : nums) {
        if (heap.size() < k) {
            heap.offer(num);
        } else if (num > heap.peek()) {
            heap.poll();
            heap.offer(num);
        }
    }
    
    // 转换为列表
    List<Integer> result = new ArrayList<>();
    while (!heap.isEmpty()) {
        result.add(heap.poll());
    }
    return result;
}
```

### 使用自定义对象
```java
class Student implements Comparable<Student> {
    String name;
    int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.score, other.score);  // 按分数升序
    }
}

// 使用
PriorityQueue<Student> studentHeap = new PriorityQueue<>();
studentHeap.offer(new Student("Alice", 85));
studentHeap.offer(new Student("Bob", 92));
studentHeap.offer(new Student("Charlie", 78));

// 按分数从低到高弹出
while (!studentHeap.isEmpty()) {
    Student s = studentHeap.poll();
    System.out.println(s.name + ": " + s.score);
}
// 输出:
// Charlie: 78
// Alice: 85  
// Bob: 92
```

## 重要注意事项

1. **遍历顺序**：直接遍历堆不保证有序，只有 `poll()` 能保证顺序
2. **线程安全**：`PriorityQueue` 不是线程安全的
3. **null元素**：不允许添加 `null` 元素
4. **初始容量**：默认容量为11，可以指定初始容量

这些就是Java自带堆（PriorityQueue）的常用操作！