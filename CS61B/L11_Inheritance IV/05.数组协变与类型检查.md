问得非常好！这是理解Java数组和泛型差异的关键。我们来详细拆解这几个概念。

### 1. 数组的“协变（Covariant）”是什么意思？

**协变**描述的是类型之间的关系：如果 `Child` 是 `Parent` 的子类，那么 `Child[]` 也被认为是 `Parent[]` 的子类。

**举个例子就明白了：**

```java
class Parent { }
class Child extends Parent { }

public class Test {
    public static void main(String[] args) {
        // 这是合法的！因为 Child[] 是 Parent[] 的子类型
        Parent[] parentArray = new Child[5]; 

        // 这也是合法的，因为 String 是 Object 的子类
        Object[] objArray = new String[10]; 
    }
}
```
这种设计在早期Java中是为了让数组操作更加灵活，允许编写处理多种类型数组的通用方法。

---

### 2. 数组“会记住其元素类型”是什么意思？

这是Java数组的一个**运行时特性**。虽然你可以将一个 `Child[]` 赋值给一个 `Parent[]` 的引用，但数组对象本身在内存中会记住它最初被创建时指定的具体类型（在这个例子里是 `Child`）。

**JVM会在运行时检查所有对数组的赋值操作，确保你放入的元素类型与数组创建时的类型兼容。**

---

### 3. “绕过数组的运行时类型检查”是什么意思？

现在我们结合前两点，来看一个会出问题的场景：

```java
Object[] objArray = new String[5]; // 合法：协变。objArray 运行时仍然是 String[]
objArray[0] = "Hello"; // 成功：String 放入 String[]，类型匹配
objArray[1] = Integer.valueOf(123); // 运行时抛出 ArrayStoreException！
```

**发生了什么？**
1.  `objArray` 的**编译时类型**是 `Object[]`，所以编译器允许你放入任何 `Object` 的子类（包括 `Integer`）。
2.  但 `objArray` 的**运行时类型**仍然是 `String[]`，它“记住”了自己本应存储字符串。
3.  当JVM执行 `objArray[1] = Integer.valueOf(123)` 时，它会进行运行时检查，发现试图将一个 `Integer` 放入一个 `String[]`，这违反了规则，于是立即抛出 `ArrayStoreException`。

**“绕过”就是指：** 如果允许创建泛型数组，我们就有可能利用泛型的擦除机制，在编译期绕过编译器的类型检查，最终导致本应类型安全的泛型代码在运行时抛出 `ArrayStoreException`，这违背了泛型的核心目标。

---

### 4. 要是我有一个Object数组，我不能存各种各样的子类是吗？

**不，你完全可以！但有一个非常重要的前提。**

如果你**真正创建**的是一个 `Object[]`，而不是其他类型的数组（如 `String[]`）被向上转型为 `Object[]`，那么你可以在里面存放任何对象。

**这是完全合法且安全的：**

```java
// 正确示例：创建一个真正的 Object[] 数组
Object[] trueObjectArray = new Object[5];

// 可以存放任何 Object 的子类，因为数组本身就是为存储任何对象而创建的
trueObjectArray[0] = "Hello";      // String
trueObjectArray[1] = Integer.valueOf(123); // Integer
trueObjectArray[2] = new ArrayList<>(); // ArrayList
trueObjectArray[3] = new Child();     // 自定义子类
// 所有操作都不会抛出 ArrayStoreException
```

**关键区别在于：**
- `Object[] objArray = new String[5];`
  - **创建的是 `String[]`**，只是用 `Object[]` 引用它。**运行时检查基于 `String`**。
- `Object[] trueObjectArray = new Object[5];`
  - **创建的是 `Object[]`**。**运行时检查基于 `Object`**，而任何Java对象都是 `Object`，所以检查永远通过。

### 总结对比表

| 特性 | 真正的 `Object[]` | 其他数组伪装成的 `Object[]` (如 `String[]`) |
| :--- | :--- | :--- |
| **创建方式** | `new Object[size]` | `new String[size]` 然后赋给 `Object[]` 引用 |
| **运行时类型** | `Object[]` | `String[]` |
| **能否存放多种类型** | **可以** | **不可以** |
| **运行时检查** | 检查是否为 `Object`（总是通过） | 检查是否为 `String`（或其子类） |
| **安全性** | **安全** | **不安全，可能抛出 `ArrayStoreException`** |

所以，结论是：**一个真正的、自己创建的 `Object[]` 是存储各种对象的完美容器。** 问题只出在当你把一个特定类型的数组（如 `String[]`）向上转型为 `Object[]` 后，又试图放入不兼容的类型时。编译器可能发现不了这个错误，但JVM在运行时会抓住它。