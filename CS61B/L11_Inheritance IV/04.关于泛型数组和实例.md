您问到了一个非常核心且容易混淆的点！您说得对，类型擦除确实会将 `T` 替换为 `Object` 或它的边界，那么为什么 `new T[size]` 和 `new T()` 仍然是非法的呢？

原因在于：**类型安全（Type Safety）**。编译器禁止这些操作，**恰恰是为了防止在类型擦除后引入运行时错误**。

让我们分别深入探讨这两个限制。

---

### 1. 为什么不能创建泛型数组 (`new T[size]`)

假设编译器允许我们写这样的代码：
```java
public class Container<T> {
    // 假设这是合法的
    private T[] array = new T[10]; 

    public T get(int index) {
        return array[index];
    }
    
    public void set(int index, T item) {
        array[index] = item;
    }
}
```

根据类型擦除规则，`T` 会被替换为 `Object`。编译后的代码实际上会变成：
```java
public class Container {
    // 擦除后：一个普通的 Object 数组
    private Object[] array = new Object[10]; 

    public Object get(int index) {
        return array[index];
    }
    
    // 注意这里！参数类型也被擦除为 Object
    public void set(int index, Object item) {
        array[index] = item;
    }
}
```

现在问题来了：**数组在 Java 中是“协变（Covariant）”且会记住其元素类型的**。

这意味着：
1.  `String[]` 是 `Object[]` 的子类型。
2.  如果你有一个 `String[]` 数组，JVM 会在运行时检查你放入的元素是否是 `String` 或它的子类。如果你尝试放入一个 `Integer`，会抛出 `ArrayStoreException`。

**看看如果允许泛型数组会发什么：**

```java
// 假设上面的代码是合法的
Container<String> stringContainer = new Container<>();
// 获取到的 array 在运行时其实是 Object[]
Object[] runtimeArray = stringContainer.array; 

// 这里编译器不会报错，因为 runtimeArray 的类型是 Object[]，
// 而 Integer 是 Object 的子类，符合数组的协变规则。
// 但这破坏了 stringContainer 的泛型契约！它本应只存储 String。
runtimeArray[0] = 123; // 这会在运行时抛出 ArrayStoreException!
```

**结论：**
编译器禁止 `new T[size]`，是为了防止你通过泛型类的内部机制，绕过数组的运行时类型检查，从而破坏泛型所保证的类型安全。它迫使你使用 `ArrayList` 这样的集合类，或者用 `(T[]) new Object[size]` 这种方式（并压制警告），由开发者自己来保证类型安全。

---

### 2. 为什么不能创建泛型实例 (`new T()`)

同样，假设这是合法的：
```java
public class Creator<T> {
    public T create() {
        // 假设这是合法的
        return new T(); 
    }
}
```

经过类型擦除后，代码会变成：
```java
public class Creator {
    public Object create() {
        // 擦除后：这变成了 new Object()
        return new Object(); 
    }
}
```

现在考虑它的使用：
```java
Creator<String> stringCreator = new Creator<>();
// 我们期望得到一个 String
String myString = stringCreator.create(); 
// 但实际上，运行时调用的是 new Object()
// 这会导致 ClassCastException：无法将 Object 转换为 String
```

**这里的关键问题是：**
`new T()` 的意图是调用类型 `T` 的构造函数。但 `T` 在编译时只是一个占位符，它的具体类型千变万化（`String`, `Integer`, 或任何自定义类）。编译器无法知道：
1.  **`T` 是否有默认的无参构造函数？**（可能构造函数是私有的，或者需要参数）。
2.  **即使有无参构造函数，具体是哪个？** 在 `create()` 方法被编译时，根本不知道要生成哪个类的 `new` 字节码。

**结论：**
编译器禁止 `new T()` 是因为它无法在编译时确定具体要实例化哪个类，也无法生成正确的字节码。如果允许，必然会导致运行时 `ClassCastException`，这完全违背了泛型提供编译时类型安全的初衷。

### 总结对比

| 操作 | 为什么非法 | 根本原因 |
| :--- | :--- | :--- |
| **`new T[size]`** | 破坏了数组的运行时类型安全机制。允许它会导致可能抛出 `ArrayStoreException`，违背了泛型的类型安全承诺。 | **数组的协变性和运行时类型检查**与泛型的擦除机制不兼容。 |
| **`new T()`** | 编译器无法确定 `T` 的具体类型，因此无法生成正确的创建对象的字节码。允许它必然会导致 `ClassCastException`。 | **泛型在运行时没有具体类型信息**，而实例化需要完全确定的类型。 |

所以，这两个限制**不是类型擦除带来的技术限制**（理论上擦除后变成 `new Object[size]` 和 `new Object()` 是能生成字节码的），而是 **Java 语言设计者为了保持类型安全而主动施加的编译期限制**。它们是一种保护机制，防止你写出看起来正确但实际上在运行时必然或很可能出错