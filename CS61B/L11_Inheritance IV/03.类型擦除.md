好的，我们来详细讲解一下 Java 中的**类型擦除 (Type Erasure)**。

### 1. 什么是类型擦除？

**类型擦除是 Java 编译器应用在泛型上的一种机制，它会在编译期间“擦除”所有泛型类型信息，以确保与旧版本 Java（Java 5 之前）的字节码兼容。**

简单来说，**泛型只存在于编译阶段，用于进行严格的类型检查，一旦代码编译完成，生成的字节码文件中所有泛型信息都会被移除或替换**。运行时，JVM 看到的只是原始类型（Raw Type），并不知道泛型的存在。

### 2. 为什么需要类型擦除？

主要目的是为了**实现平滑的向后兼容性（Backward Compatibility）**。

在 Java 5 引入泛型之前，集合类（如 `ArrayList`, `HashMap`）都是使用 `Object` 来存储元素的。这意味着你需要进行繁琐且不安全的强制类型转换。

```java
// Java 5 之前的代码
List list = new ArrayList();
list.add("Hello");
// 需要手动强制转换，容易在运行时抛出 ClassCastException
String s = (String) list.get(0);
```

Java 设计者希望将泛型引入语言，但又不想破坏已有的庞大生态（比如已经编译好的 JAR 文件）。类型擦除允许新的泛型代码和遗留的非泛型代码无缝地互操作。

*   **新代码可以使用泛型集合：** `List<String>`
*   **旧代码仍然可以使用原始集合：** `List`
*   它们本质上都是同一个类 `List`，所以可以互相传递和操作。

### 3. 类型擦除是如何工作的？

编译器会执行以下擦除规则：

1.  **将泛型类型参数替换为其边界（Bound）。**
    *   如果泛型参数是**无界**的（如 `<T>`），则替换为 `Object`。
    *   如果泛型参数是**有界**的（如 `<T extends Number>`），则替换为它的边界（这里是 `Number`）。

2.  **在必要的地方插入类型转换**，以保证类型安全。
3.  **生成桥接方法（Bridge Methods）** 以保持多态性（尤其在泛型类继承或实现接口时）。

---

#### 示例 1：无界泛型的擦除

**编译前（源代码）：**
```java
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

// 使用
Box<String> stringBox = new Box<>();
stringBox.setValue("Hello");
String value = stringBox.getValue(); // 不需要强制转换
```

**编译后（效果等同于）：**
```java
public class Box { // T 被擦除了
    private Object value; // T 被替换为 Object

    public void setValue(Object value) { // 参数变为 Object
        this.value = value;
    }

    public Object getValue() { // 返回类型变为 Object
        return value;
    }
}

// 使用
Box stringBox = new Box();
stringBox.setValue("Hello");
// 编译器自动插入强制转换！
String value = (String) stringBox.getValue();
```
可以看到，编译器在调用 `getValue()` 的地方，自动为我们插入了 `(String)` 的强制转换，这样我们写代码时就不用自己写了，既安全又方便。

---

#### 示例 2：有界泛型的擦除

**编译前（源代码）：**
```java
public class NumberBox<T extends Number> {
    private T number;

    public void setNumber(T number) {
        this.number = number;
    }

    public T getNumber() {
        return number;
    }
}
```

**编译后（效果等同于）：**
```java
public class NumberBox { // T 被擦除了
    private Number number; // T 被替换为它的上界 Number

    public void setNumber(Number number) { // 参数变为 Number
        this.number = number;
    }

    public Number getNumber() { // 返回类型变为 Number
        return number;
    }
}
```

---

### 4. 类型擦除带来的局限性

由于运行时类型信息被擦除，导致了一些限制：

1.  **不能使用基本类型作为泛型参数**
    *   例如 `List<int>` 是非法的，必须使用 `List<Integer>`。因为擦除后是 `Object`，而 `Object` 不能存储 `int` 这样的基本类型。

2.  **instanceof 和 getClass()**
    *   无法使用 `instanceof` 检查泛型类型。
    *   `getClass()` 返回的类信息不包含泛型参数。
    ```java
    List<String> list1 = new ArrayList<>();
    List<Integer> list2 = new ArrayList<>();
    // 编译后都是 ArrayList，结果为 true
    System.out.println(list1.getClass() == list2.getClass());
    ```

3.  **不能创建泛型数组**
    *   `new T[size]` 是非法的，因为运行时不知道 `T` 的具体类型。

4.  **不能创建泛型实例**
    *   `new T()` 是非法的，原因同上。

5.  **不能重载方法，如果它们的擦除类型相同**
    ```java
    // 编译错误！擦除后两个方法都变成 print(ArrayList list)
    public void print(ArrayList<String> list) {}
    public void print(ArrayList<Integer> list) {}
    ```

### 5. 如何绕过类型擦除？（获取运行时泛型类型）

虽然类型擦除是主流，但在某些特定情况下，编译器会将泛型信息保留在字节码的元数据（Metadata）中，这被称为**泛型反射**。这通常发生在：

*   **类的泛型参数**：通过反射可以获取到类的泛型父类或泛型接口的信息。
*   **字段的泛型类型**：可以获取字段声明的泛型类型。
*   **方法的泛型参数**：可以获取方法参数或返回值的泛型类型。

**示例：**
```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public abstract class GenericType<T> {
    private T value;

    public GenericType() {
        // 获取父类的泛型参数
        Type superClass = getClass().getGenericSuperclass();
        ParameterizedType pt = (ParameterizedType) superClass;
        // 获取第一个泛型参数的实际类型
        Type actualType = pt.getActualTypeArguments()[0];
        System.out.println("实际的泛型类型是: " + actualType);
    }
}

// 使用
public class StringType extends GenericType<String> { }

new StringType(); // 输出：实际的泛型类型是: class java.lang.String
```
这种方式通常用于框架开发（如 Spring, Gson, Jackson），它们通过这种技巧来在运行时确定你想要的类型。

### 总结

| 特性 | 编译时 | 运行时 |
| :--- | :--- | :--- |
| **泛型类型检查** | **有**，编译器确保类型安全 | **无**，类型信息被擦除 |
| **代码表现** | `List<String>` | `List` (原始类型) |
| **类型转换** | 不需要显式转换 | 编译器自动插入强制转换 |
| **主要目的** | 提供类型安全，减少 `ClassCastException` | 与旧版本 Java 字节码兼容 |

**核心思想：** 类型擦除是 Java 泛型实现的一种折中方案，它用编译时的严格检查换来了运行时的兼容性。它让你写代码时更安全，但也在运行时失去了一些灵活性。