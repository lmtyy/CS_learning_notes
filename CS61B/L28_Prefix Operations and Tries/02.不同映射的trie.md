# Trie 使用不同数据结构的变体实现

## 1. 使用哈希表替代数组的Trie

### 实现代码

```java
import java.util.*;

class HashTrieNode {
    private Map<Character, HashTrieNode> children;
    private boolean isEndOfWord;
    
    public HashTrieNode() {
        this.children = new HashMap<>();
        this.isEndOfWord = false;
    }
    
    public boolean containsKey(char ch) {
        return children.containsKey(ch);
    }
    
    public HashTrieNode get(char ch) {
        return children.get(ch);
    }
    
    public void put(char ch, HashTrieNode node) {
        children.put(ch, node);
    }
    
    public void setEnd() {
        isEndOfWord = true;
    }
    
    public boolean isEnd() {
        return isEndOfWord;
    }
    
    public Map<Character, HashTrieNode> getChildren() {
        return children;
    }
    
    public void removeChild(char ch) {
        children.remove(ch);
    }
    
    public boolean hasChildren() {
        return !children.isEmpty();
    }
}

public class HashTrie {
    private HashTrieNode root;
    
    public HashTrie() {
        root = new HashTrieNode();
    }
    
    // 插入单词
    public void insert(String word) {
        HashTrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (!node.containsKey(ch)) {
                node.put(ch, new HashTrieNode());
            }
            node = node.get(ch);
        }
        node.setEnd();
    }
    
    // 搜索完整单词
    public boolean search(String word) {
        HashTrieNode node = searchPrefix(word);
        return node != null && node.isEnd();
    }
    
    // 搜索前缀
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private HashTrieNode searchPrefix(String prefix) {
        HashTrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            if (!node.containsKey(ch)) {
                return null;
            }
            node = node.get(ch);
        }
        return node;
    }
    
    // 删除单词
    public boolean delete(String word) {
        return delete(root, word, 0);
    }
    
    private boolean delete(HashTrieNode current, String word, int index) {
        if (index == word.length()) {
            if (!current.isEnd()) {
                return false; // 单词不存在
            }
            current.setEnd(); // 移除结束标记
            return !current.hasChildren(); // 如果没有子节点，可以删除
        }
        
        char ch = word.charAt(index);
        HashTrieNode node = current.get(ch);
        if (node == null) {
            return false; // 单词不存在
        }
        
        boolean shouldDeleteCurrentNode = delete(node, word, index + 1);
        
        if (shouldDeleteCurrentNode) {
            current.removeChild(ch);
            return !current.hasChildren() && !current.isEnd();
        }
        return false;
    }
    
    // 获取所有单词
    public List<String> getAllWords() {
        List<String> results = new ArrayList<>();
        traverse(root, new StringBuilder(), results);
        return results;
    }
    
    // 获取以指定前缀开头的所有单词
    public List<String> getAllWordsWithPrefix(String prefix) {
        List<String> results = new ArrayList<>();
        HashTrieNode node = searchPrefix(prefix);
        if (node != null) {
            traverse(node, new StringBuilder(prefix), results);
        }
        return results;
    }
    
    private void traverse(HashTrieNode node, StringBuilder current, List<String> results) {
        if (node.isEnd()) {
            results.add(current.toString());
        }
        
        // 按字母顺序遍历
        node.getChildren().entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .forEach(entry -> {
                current.append(entry.getKey());
                traverse(entry.getValue(), current, results);
                current.deleteCharAt(current.length() - 1);
            });
    }
    
    // 获取Trie中单词数量
    public int size() {
        return countWords(root);
    }
    
    private int countWords(HashTrieNode node) {
        int count = 0;
        if (node.isEnd()) {
            count++;
        }
        for (HashTrieNode child : node.getChildren().values()) {
            count += countWords(child);
        }
        return count;
    }
}
```

## 2. 使用二叉搜索树（TreeMap）的Trie

### 实现代码

```java
import java.util.*;

class BSTTrieNode {
    private TreeMap<Character, BSTTrieNode> children;
    private boolean isEndOfWord;
    
    public BSTTrieNode() {
        this.children = new TreeMap<>();
        this.isEndOfWord = false;
    }
    
    public boolean containsKey(char ch) {
        return children.containsKey(ch);
    }
    
    public BSTTrieNode get(char ch) {
        return children.get(ch);
    }
    
    public void put(char ch, BSTTrieNode node) {
        children.put(ch, node);
    }
    
    public void setEnd() {
        isEndOfWord = true;
    }
    
    public boolean isEnd() {
        return isEndOfWord;
    }
    
    public TreeMap<Character, BSTTrieNode> getChildren() {
        return children;
    }
    
    public void removeChild(char ch) {
        children.remove(ch);
    }
    
    public boolean hasChildren() {
        return !children.isEmpty();
    }
}

public class BSTTrie {
    private BSTTrieNode root;
    
    public BSTTrie() {
        root = new BSTTrieNode();
    }
    
    // 插入单词
    public void insert(String word) {
        BSTTrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (!node.containsKey(ch)) {
                node.put(ch, new BSTTrieNode());
            }
            node = node.get(ch);
        }
        node.setEnd();
    }
    
    // 搜索完整单词
    public boolean search(String word) {
        BSTTrieNode node = searchPrefix(word);
        return node != null && node.isEnd();
    }
    
    // 搜索前缀
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private BSTTrieNode searchPrefix(String prefix) {
        BSTTrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            if (!node.containsKey(ch)) {
                return null;
            }
            node = node.get(ch);
        }
        return node;
    }
    
    // 删除单词
    public boolean delete(String word) {
        return delete(root, word, 0);
    }
    
    private boolean delete(BSTTrieNode current, String word, int index) {
        if (index == word.length()) {
            if (!current.isEnd()) {
                return false;
            }
            current.setEnd();
            return !current.hasChildren();
        }
        
        char ch = word.charAt(index);
        BSTTrieNode node = current.get(ch);
        if (node == null) {
            return false;
        }
        
        boolean shouldDeleteCurrentNode = delete(node, word, index + 1);
        
        if (shouldDeleteCurrentNode) {
            current.removeChild(ch);
            return !current.hasChildren() && !current.isEnd();
        }
        return false;
    }
    
    // 按字母顺序获取所有单词
    public List<String> getAllWords() {
        List<String> results = new ArrayList<>();
        traverse(root, new StringBuilder(), results);
        return results;
    }
    
    // 按字母顺序获取以指定前缀开头的所有单词
    public List<String> getAllWordsWithPrefix(String prefix) {
        List<String> results = new ArrayList<>();
        BSTTrieNode node = searchPrefix(prefix);
        if (node != null) {
            traverse(node, new StringBuilder(prefix), results);
        }
        return results;
    }
    
    private void traverse(BSTTrieNode node, StringBuilder current, List<String> results) {
        if (node.isEnd()) {
            results.add(current.toString());
        }
        
        // TreeMap已经按key排序，直接遍历即可
        for (Map.Entry<Character, BSTTrieNode> entry : node.getChildren().entrySet()) {
            current.append(entry.getKey());
            traverse(entry.getValue(), current, results);
            current.deleteCharAt(current.length() - 1);
        }
    }
    
    // 获取字典序最小的单词
    public String getFirstWord() {
        BSTTrieNode node = root;
        StringBuilder sb = new StringBuilder();
        
        while (!node.isEnd() && node.hasChildren()) {
            char firstChar = node.getChildren().firstKey();
            sb.append(firstChar);
            node = node.get(firstChar);
        }
        
        return sb.toString();
    }
    
    // 获取字典序最大的单词
    public String getLastWord() {
        BSTTrieNode node = root;
        StringBuilder sb = new StringBuilder();
        
        while (node.hasChildren()) {
            char lastChar = node.getChildren().lastKey();
            sb.append(lastChar);
            node = node.get(lastChar);
        }
        
        return sb.toString();
    }
}
```

## 3. 性能对比测试

```java
public class TrieComparison {
    public static void main(String[] args) {
        // 测试数据
        String[] words = {"apple", "application", "app", "banana", "bat", "cat", "car", "card"};
        
        // 测试三种Trie实现
        testArrayTrie(words);
        testHashTrie(words);
        testBSTTrie(words);
    }
    
    static void testArrayTrie(String[] words) {
        long startTime = System.nanoTime();
        
        Trie trie = new Trie();
        for (String word : words) {
            trie.insert(word);
        }
        
        long endTime = System.nanoTime();
        System.out.println("Array Trie - 插入时间: " + (endTime - startTime) + " ns");
        
        // 测试搜索
        startTime = System.nanoTime();
        boolean found = trie.search("apple");
        endTime = System.nanoTime();
        System.out.println("Array Trie - 搜索时间: " + (endTime - startTime) + " ns");
    }
    
    static void testHashTrie(String[] words) {
        long startTime = System.nanoTime();
        
        HashTrie trie = new HashTrie();
        for (String word : words) {
            trie.insert(word);
        }
        
        long endTime = System.nanoTime();
        System.out.println("Hash Trie - 插入时间: " + (endTime - startTime) + " ns");
        
        // 测试搜索
        startTime = System.nanoTime();
        boolean found = trie.search("apple");
        endTime = System.nanoTime();
        System.out.println("Hash Trie - 搜索时间: " + (endTime - startTime) + " ns");
    }
    
    static void testBSTTrie(String[] words) {
        long startTime = System.nanoTime();
        
        BSTTrie trie = new BSTTrie();
        for (String word : words) {
            trie.insert(word);
        }
        
        long endTime = System.nanoTime();
        System.out.println("BST Trie - 插入时间: " + (endTime - startTime) + " ns");
        
        // 测试搜索
        startTime = System.nanoTime();
        boolean found = trie.search("apple");
        endTime = System.nanoTime();
        System.out.println("BST Trie - 搜索时间: " + (endTime - startTime) + " ns");
        
        // 测试有序遍历
        System.out.println("BST Trie 所有单词(有序): " + trie.getAllWords());
        System.out.println("最小单词: " + trie.getFirstWord());
        System.out.println("最大单词: " + trie.getLastWord());
    }
}
```

## 4. 三种实现方式的对比分析

| 特性 | 数组Trie | 哈希表Trie | BST Trie |
|------|----------|------------|----------|
| **内存使用** | 固定大小，可能浪费空间 | 动态分配，空间效率高 | 动态分配，平衡的空间使用 |
| **访问速度** | O(1) 直接索引 | O(1) 平均情况 | O(log k) k为字符集大小 |
| **字符范围** | 需要预定义字符集 | 支持所有Unicode字符 | 支持所有Comparable字符 |
| **有序遍历** | 需要额外排序 | 需要额外排序 | 天然有序 |
| **实现复杂度** | 简单 | 中等 | 中等 |
| **适用场景** | 小字符集、已知字符范围 | 大字符集、动态字符 | 需要有序遍历的场景 |

## 5. 使用示例

```java
public class AdvancedTrieExample {
    public static void main(String[] args) {
        // 哈希表Trie示例
        HashTrie hashTrie = new HashTrie();
        hashTrie.insert("hello");
        hashTrie.insert("world");
        hashTrie.insert("hell");
        hashTrie.insert("hero");
        
        System.out.println("所有单词: " + hashTrie.getAllWords());
        System.out.println("以'he'开头的单词: " + hashTrie.getAllWordsWithPrefix("he"));
        
        // BST Trie示例
        BSTTrie bstTrie = new BSTTrie();
        bstTrie.insert("zoo");
        bstTrie.insert("apple");
        bstTrie.insert("banana");
        bstTrie.insert("cat");
        
        System.out.println("有序单词: " + bstTrie.getAllWords());
        System.out.println("最小单词: " + bstTrie.getFirstWord());
        System.out.println("最大单词: " + bstTrie.getLastWord());
    }
}
```

## 总结

- **数组Trie**：适合字符集固定且较小的场景，性能最好
- **哈希表Trie**：适合字符集动态或较大的场景，灵活性高
- **BST Trie**：适合需要有序遍历的场景，在有序性和性能间取得平衡

选择哪种实现取决于具体的应用需求和性能要求。