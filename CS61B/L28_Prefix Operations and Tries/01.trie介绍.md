# Trie（字典树）数据结构介绍（Java实现）

## 什么是Trie？

Trie（发音为"try"），也称为前缀树或字典树，是一种专门用于处理字符串搜索的树形数据结构。它的核心思想是利用字符串的公共前缀来减少查询时间，提高搜索效率。

## Trie的特点

- **高效的前缀搜索**：可以快速找到所有以某个前缀开头的字符串
- **空间换时间**：通过共享前缀来节省存储空间
- **多模式匹配**：支持同时搜索多个模式
- **自动补全**：非常适合实现搜索建议和自动补全功能

## Java实现

### 1. Trie节点类

```java
class TrieNode {
    private TrieNode[] children;
    private boolean isEndOfWord;
    
    public TrieNode() {
        this.children = new TrieNode[26]; // 假设只包含小写字母
        this.isEndOfWord = false;
    }
    
    public boolean containsKey(char ch) {
        return children[ch - 'a'] != null;
    }
    
    public TrieNode get(char ch) {
        return children[ch - 'a'];
    }
    
    public void put(char ch, TrieNode node) {
        children[ch - 'a'] = node;
    }
    
    public void setEnd() {
        isEndOfWord = true;
    }
    
    public boolean isEnd() {
        return isEndOfWord;
    }
}
```

### 2. Trie类完整实现

```java
public class Trie {
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    // 插入单词
    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            char currentChar = word.charAt(i);
            if (!node.containsKey(currentChar)) {
                node.put(currentChar, new TrieNode());
            }
            node = node.get(currentChar);
        }
        node.setEnd();
    }
    
    // 搜索完整单词
    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEnd();
    }
    
    // 搜索前缀
    public boolean startsWith(String prefix) {
        TrieNode node = searchPrefix(prefix);
        return node != null;
    }
    
    // 搜索前缀的辅助方法
    private TrieNode searchPrefix(String prefix) {
        TrieNode node = root;
        for (int i = 0; i < prefix.length(); i++) {
            char currentChar = prefix.charAt(i);
            if (node.containsKey(currentChar)) {
                node = node.get(currentChar);
            } else {
                return null;
            }
        }
        return node;
    }
    
    // 删除单词
    public void delete(String word) {
        delete(root, word, 0);
    }
    
    private boolean delete(TrieNode current, String word, int index) {
        if (index == word.length()) {
            if (!current.isEnd()) {
                return false;
            }
            current.setEnd();
            return isEmpty(current);
        }
        
        char ch = word.charAt(index);
        TrieNode node = current.get(ch);
        if (node == null) {
            return false;
        }
        
        boolean shouldDeleteCurrentNode = delete(node, word, index + 1) && !node.isEnd();
        
        if (shouldDeleteCurrentNode) {
            current.put(ch, null);
            return isEmpty(current);
        }
        return false;
    }
    
    private boolean isEmpty(TrieNode node) {
        for (int i = 0; i < 26; i++) {
            if (node.get((char)('a' + i)) != null) {
                return false;
            }
        }
        return true;
    }
    
    // 获取所有以指定前缀开头的单词
    public List<String> getAllWordsWithPrefix(String prefix) {
        List<String> results = new ArrayList<>();
        TrieNode node = searchPrefix(prefix);
        if (node != null) {
            traverse(node, new StringBuilder(prefix), results);
        }
        return results;
    }
    
    private void traverse(TrieNode node, StringBuilder current, List<String> results) {
        if (node.isEnd()) {
            results.add(current.toString());
        }
        
        for (char ch = 'a'; ch <= 'z'; ch++) {
            if (node.containsKey(ch)) {
                current.append(ch);
                traverse(node.get(ch), current, results);
                current.deleteCharAt(current.length() - 1);
            }
        }
    }
}
```

### 3. 支持所有字符的通用Trie实现

```java
import java.util.*;

class UniversalTrieNode {
    private Map<Character, UniversalTrieNode> children;
    private boolean isEndOfWord;
    
    public UniversalTrieNode() {
        this.children = new HashMap<>();
        this.isEndOfWord = false;
    }
    
    public boolean containsKey(char ch) {
        return children.containsKey(ch);
    }
    
    public UniversalTrieNode get(char ch) {
        return children.get(ch);
    }
    
    public void put(char ch, UniversalTrieNode node) {
        children.put(ch, node);
    }
    
    public void setEnd() {
        isEndOfWord = true;
    }
    
    public boolean isEnd() {
        return isEndOfWord;
    }
    
    public Map<Character, UniversalTrieNode> getChildren() {
        return children;
    }
}

public class UniversalTrie {
    private UniversalTrieNode root;
    
    public UniversalTrie() {
        root = new UniversalTrieNode();
    }
    
    public void insert(String word) {
        UniversalTrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (!node.containsKey(ch)) {
                node.put(ch, new UniversalTrieNode());
            }
            node = node.get(ch);
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        UniversalTrieNode node = searchPrefix(word);
        return node != null && node.isEnd();
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private UniversalTrieNode searchPrefix(String prefix) {
        UniversalTrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            if (!node.containsKey(ch)) {
                return null;
            }
            node = node.get(ch);
        }
        return node;
    }
}
```

### 4. 使用示例

```java
public class TrieExample {
    public static void main(String[] args) {
        // 创建Trie
        Trie trie = new Trie();
        
        // 插入单词
        trie.insert("apple");
        trie.insert("app");
        trie.insert("application");
        trie.insert("banana");
        trie.insert("bat");
        
        // 搜索测试
        System.out.println("搜索 'app': " + trie.search("app")); // true
        System.out.println("搜索 'apple': " + trie.search("apple")); // true
        System.out.println("搜索 'appl': " + trie.search("appl")); // false
        
        // 前缀测试
        System.out.println("前缀 'app': " + trie.startsWith("app")); // true
        System.out.println("前缀 'ba': " + trie.startsWith("ba")); // true
        
        // 获取所有以'app'开头的单词
        List<String> words = trie.getAllWordsWithPrefix("app");
        System.out.println("以'app'开头的单词: " + words);
        
        // 删除测试
        trie.delete("app");
        System.out.println("删除后搜索 'app': " + trie.search("app")); // false
        System.out.println("删除后搜索 'apple': " + trie.search("apple")); // true
    }
}
```

## 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 插入 | O(L) | L为单词长度 |
| 搜索 | O(L) | L为单词长度 |
| 前缀搜索 | O(L) | L为前缀长度 |
| 删除 | O(L) | L为单词长度 |

## 应用场景

1. **自动补全系统**：搜索建议、IDE代码补全
2. **拼写检查**：词典查找
3. **IP路由**：最长前缀匹配
4. **搜索引擎**：前缀搜索建议
5. **联系人搜索**：手机通讯录搜索

## 优缺点

**优点：**
- 前缀搜索效率高
- 支持多模式匹配
- 搜索时间与数据集大小无关

**缺点：**
- 空间消耗较大
- 实现相对复杂
- 对于稀疏数据效率较低

Trie是一种非常实用的数据结构，特别适合处理字符串相关的搜索和匹配问题。