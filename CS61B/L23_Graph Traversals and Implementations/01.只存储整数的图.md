这是一个非常好的问题，它触及了数据结构设计的核心思想。

简短的回答是：**不，这不是一个好的“规定”，而是一个非常普遍且实用的“实践”或“约定”。** 将节点抽象为数字（通常是数组索引）是一种底层实现策略，而不是一个必须遵守的规则。

下面我们来详细分析为什么这么做，以及什么时候不这么做。

### 为什么普遍使用数字（索引）来存储图？

1.  **极高的效率**
    *   **访问速度**：通过数组索引访问一个节点是 O(1) 的时间复杂度，这是最快的访问方式。
    *   **存储紧凑**：使用邻接矩阵（2D数组）或邻接表（数组的数组/列表的列表）时，数据在内存中是连续或近乎连续存储的，缓存命中率高，遍历速度快。
    *   **算法友好**：绝大多数经典的图算法（如BFS, DFS, Dijkstra, Floyd-Warshall）最初都是在数学上基于节点编号（0到n-1）定义的。使用数字索引可以直接、高效地实现这些算法。

2.  **强大的抽象和映射能力**
    *   数字只是一个 **“句柄”** 或 **“唯一标识符”**。在实际应用中，我们几乎总是需要将数字映射回真实的业务对象。
    *   **标准做法是**：创建一个 `Node` 或 `Vertex` 对象数组 `nodes[]`，其中 `nodes[i]` 就存储着索引 `i` 所代表的真实数据。
    *   **示例**：
        ```java
        public class Graph<T> {
            private List<List<Integer>> adjacencyList; // 邻接表，存储数字索引
            private List<T> nodes; // 索引到真实数据的映射

            public Graph(int numberOfNodes) {
                adjacencyList = new ArrayList<>(numberOfNodes);
                nodes = new ArrayList<>(numberOfNodes);
                // 初始化邻接表，并为 nodes 赋值
                for (int i = 0; i < numberOfNodes; i++) {
                    adjacencyList.add(new ArrayList<>());
                    // nodes.add(...); // 在这里或之后填充真实数据
                }
            }

            // 添加一个节点，返回其索引
            public int addNode(T data) {
                nodes.add(data);
                adjacencyList.add(new ArrayList<>());
                return nodes.size() - 1;
            }

            // 根据索引获取节点数据
            public T getNodeData(int index) {
                return nodes.get(index);
            }

            // 在索引 i 和 j 之间添加边
            public void addEdge(int i, int j) {
                adjacencyList.get(i).add(j);
                // 如果是无向图，还需要 adjacencyList.get(j).add(i);
            }
        }
        ```
    *   这样，图的结构运算（遍历、寻路）在高效的索引层面上进行，而当我们关心结果时（例如“找到从A到B的最短路径”），只需将最终得到的索引序列 `[i, j, k]` 通过 `nodes` 数组转换为 `[A, B, C]` 即可。

3.  **简化问题**
    *   在处理图论问题时，先专注于图的结构和算法逻辑，而不被复杂的对象关系所干扰。用数字可以快速搭建原型。

### 什么时候不适合只存数字？

1.  **需要直接关联丰富数据时**
    *   如果你的算法在每一步都需要访问或修改节点的复杂属性，那么每次通过索引去 `nodes` 数组里查找就会多一次间接访问。虽然通常影响不大，但在极端性能敏感的场景下，可能会考虑将数据直接存储在节点结构里。

2.  **使用面向对象的设计**
    *   在一个纯粹的面向对象设计中，你可能会希望一个 `Node` 对象直接持有它的邻居列表。
        ```java
        public class Node<T> {
            private T data;
            private List<Node<T>> neighbors;

            // ... 构造方法、getter、setter ...
        }

        public class Graph<T> {
            private Set<Node<T>> nodes;
        }
        ```
    *   **优点**：非常直观，符合面向对象思想，代码易于理解。
    *   **缺点**：
        *   **性能**：通过指针/引用访问邻居不如通过数组索引快。对象在内存中可能是分散的，导致缓存不友好。
        *   **比较**：判断两个节点是否相同，依赖于对象的 `equals` 和 `hashCode` 方法，这可能比简单的整数比较慢。
        *   **算法实现**：实现某些算法（如需要标记节点的DFS）时，你需要一个 `Map<Node, Boolean>` 来记录访问状态，而不是一个简单的 `boolean[] visited`。

3.  **动态变化的图**
    *   使用基于数组索引的表示法，在节点数量动态频繁变化时，管理 `nodes` 数组和邻接表可能会比较麻烦（尽管使用 `ArrayList` 可以缓解）。而基于 `Node` 对象的 OO 设计在这方面更灵活。

### 结论与最佳实践

*   **没有“规定”**：Java中没有规定必须用数字存图。这只是一种实现选择。
*   **优先考虑数字索引**：在大多数情况下，**尤其是处理算法问题、性能要求高、或图结构相对稳定时，使用数字索引作为底层存储是最佳选择**。它高效、简洁，并且是行业内的标准实践。
*   **结合使用（推荐）**：如上面的代码示例所示，**将高效的索引存储与一个数据映射数组结合起来**，既能获得性能优势，又能灵活地处理任何类型的数据。
*   **考虑面向对象设计**：当代码的可读性、可维护性比极致的性能更重要时，或者图的节点本身是复杂的、有行为的对象时，采用直接的 `List<Node>` 存储方式是完全合理且更好的选择。

总而言之，这不是一个“是非”问题，而是一个“权衡”问题。理解这两种方法的优缺点，能帮助你在不同的场景下做出最合适的设计决策。