# Prim 算法的图论基础

## 图的基本概念

### 1. 图的定义
图 G = (V, E) 由：
- **顶点集 V**：图中的节点集合
- **边集 E**：连接顶点的边集合

### 2. 图的分类
```java
// 图的类型枚举
enum GraphType {
    DIRECTED,      // 有向图
    UNDIRECTED,    // 无向图
    WEIGHTED,      // 带权图
    UNWEIGHTED     // 无权图
}
```

## Prim 算法相关的核心图论概念

### 1. 连通图 (Connected Graph)
**定义**：图中任意两个顶点之间都存在路径

```java
// 检查图是否连通
public boolean isConnected(int[][] graph) {
    int n = graph.length;
    boolean[] visited = new boolean[n];
    dfs(graph, 0, visited);
    
    for (boolean v : visited) {
        if (!v) return false;
    }
    return true;
}

private void dfs(int[][] graph, int node, boolean[] visited) {
    visited[node] = true;
    for (int i = 0; i < graph.length; i++) {
        if (graph[node][i] != 0 && !visited[i]) {
            dfs(graph, i, visited);
        }
    }
}
```

### 2. 生成树 (Spanning Tree)
**定义**：包含图中所有顶点的极小连通子图
- 包含所有顶点
- 是连通图
- 无环（树结构）
- 边数 = 顶点数 - 1

### 3. 最小生成树 (Minimum Spanning Tree, MST)
**定义**：所有生成树中边权重之和最小的那个

**性质**：
- 在连通加权图中存在
- 可能不唯一（当存在相同权重的边时）
- 边数总是 |V| - 1

## 图论定理支撑

### 1. 切分定理 (Cut Property)
**定理**：对于图的任意切分 (S, V-S)，横跨切分的最小权重边必然属于 MST。

```java
// 切分定理的直观理解
class CutTheorem {
    /**
     * 切分定理在Prim算法中的体现：
     * - S: 已加入MST的顶点集合
     * - V-S: 未加入MST的顶点集合
     * - 每次选择连接S和V-S的最小权重边
     */
    public void demonstrateCutProperty(int[][] graph) {
        int n = graph.length;
        boolean[] inMST = new boolean[n];  // 切分S
        // 剩余顶点在 V-S 中
        
        // Prim算法的每一步都在应用切分定理
        // 选择连接 inMST 和 !inMST 的最小边
    }
}
```

### 2. MST 的贪心选择性质
**定理**：局部最优选择可以导致全局最优解

```java
// 贪心选择性质的证明思路
class GreedyProperty {
    /**
     * Prim算法的贪心性证明：
     * 1. 假设存在更优解
     * 2. 考虑算法第一次偏离最优解的选择
     * 3. 可以用算法选择的边替换最优解中的边
     * 4. 得到矛盾，证明算法正确性
     */
}
```

## 图的表示方法

### 1. 邻接矩阵 (Adjacency Matrix)
```java
class AdjacencyMatrix {
    // 适合稠密图
    private int[][] matrix;
    
    public AdjacencyMatrix(int vertices) {
        matrix = new int[vertices][vertices];
    }
    
    // Prim算法在邻接矩阵上的操作复杂度：O(V²)
    public int getMinEdgeToMST(boolean[] inMST) {
        int minWeight = Integer.MAX_VALUE;
        int minVertex = -1;
        
        for (int i = 0; i < matrix.length; i++) {
            if (inMST[i]) {
                for (int j = 0; j < matrix.length; j++) {
                    if (!inMST[j] && matrix[i][j] != 0 && matrix[i][j] < minWeight) {
                        minWeight = matrix[i][j];
                        minVertex = j;
                    }
                }
            }
        }
        return minVertex;
    }
}
```

### 2. 邻接表 (Adjacency List)
```java
class AdjacencyList {
    // 适合稀疏图
    private List<List<Edge>> adjList;
    
    static class Edge {
        int to, weight;
        Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    // Prim算法在邻接表+优先队列上的操作复杂度：O(E log V)
    public void primWithPQ() {
        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));
        // 使用优先队列高效找到最小边
    }
}
```

## Prim 算法的图论正确性证明

### 归纳法证明
**基础情况**：单个顶点构成的树是 MST 的子图

**归纳步骤**：
假设已有 k 个顶点的 MST 子树 T
- 根据切分定理，连接 T 和 V-T 的最小边 e 属于 MST
- 将 e 加入 T，得到 k+1 个顶点的 MST 子树

```java
// 算法正确性的形式化描述
class PrimCorrectness {
    /**
     * 定理：Prim算法生成的树T是最小生成树
     * 
     * 证明：
     * 设T是Prim算法生成的树
     * 设T*是真正的最小生成树
     * 
     * 1. 基础：单个顶点时，T ⊆ T*
     * 2. 归纳：假设前k步T ⊆ T*
     * 3. 第k+1步：选择边e = (u,v)，u∈T, v∉T
     * 4. 如果e ∈ T*，则T ∪ {e} ⊆ T*
     * 5. 如果e ∉ T*，则T* ∪ {e}包含环
     * 6. 环中必存在另一条边f连接T和V-T
     * 7. 由于Prim选择最小边，weight(e) ≤ weight(f)
     * 8. 用e替换f得到更优或等价的生成树
     * 9. 矛盾，因此e必须属于T*
     */
}
```

## 与其他 MST 算法的图论联系

### 1. 与 Kruskal 算法的关系
```java
class MSTAlgorithmsComparison {
    /**
     * Prim vs Kruskal 的图论视角：
     * 
     * Prim: 
     * - 基于顶点扩展
     * - 维护单个连通分量
     * - 应用切分定理
     * 
     * Kruskal:
     * - 基于边排序
     * - 维护多个连通分量
     * - 应用环性质定理
     */
}
```

### 2. 环性质定理 (Cycle Property)
**定理**：对于图中的任意环，最大权重边一定不在 MST 中

## 实际应用中的图论考虑

### 1. 图的连通性保证
```java
class ConnectivityCheck {
    public boolean canFormMST(int[][] graph) {
        // Prim算法要求图是连通的
        return isConnected(graph);
    }
    
    // 对于非连通图，可以找到最小生成森林
    public List<int[][]> findMSF(int[][] graph) {
        // 最小生成森林：每个连通分量的MST
        List<int[][]> forests = new ArrayList<>();
        // 实现略...
        return forests;
    }
}
```

### 2. 权重处理
```java
class WeightHandling {
    /**
     * 图论中的权重考虑：
     * 1. 正权重：Prim算法直接适用
     * 2. 负权重：算法仍然正确
     * 3. 零权重：可能产生多个MST
     * 4. 相同权重：MST可能不唯一
     */
    
    public void handleEqualWeights() {
        // 当存在相同权重的边时，选择不同的边可能得到不同的MST
        // 但所有权重和相同
    }
}
```

## 复杂度分析的图论基础

### 1. 稀疏图 vs 稠密图
- **稀疏图**：|E| ≈ |V|，适合邻接表 + 优先队列
- **稠密图**：|E| ≈ |V|²，适合邻接矩阵

### 2. 图的性质影响
```java
class ComplexityAnalysis {
    /**
     * 图结构对Prim算法的影响：
     * 
     * 完全图：O(V²) 最优
     * 稀疏图：O(E log V) 更优
     * 平面图：有特殊性质，可能优化
     */
}
```

## 总结

Prim 算法的图论基础建立在以下几个核心概念上：

1. **连通图和生成树**：确保解的存在性
2. **切分定理**：提供算法的正确性保证
3. **贪心选择性质**：支撑算法的设计思路
4. **图的表示方法**：影响算法的实现和效率

理解这些图论基础不仅有助于掌握 Prim 算法，也为学习其他图算法提供了坚实的理论基础。算法的每一步操作都有其图论意义的支撑，这使得 Prim 算法不仅实用，而且理论优美。