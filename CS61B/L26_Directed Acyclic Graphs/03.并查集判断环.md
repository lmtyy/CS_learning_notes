# 并查集判断环详解

## 并查集概述

**并查集（Union-Find）** 是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。它常用于解决动态连通性问题。

## 基本操作

- **find(x)**：查找元素 x 所属的集合代表
- **union(x, y)**：合并元素 x 和 y 所在的集合

## 判断环的原理

**核心思想**：在无向图中，如果两个顶点已经在同一个集合中，再添加连接这两个顶点的边就会形成环。

### 算法步骤：

1. 初始化并查集，每个顶点自成一个集合
2. 遍历每条边：
   - 查找两个顶点的根节点
   - 如果根节点相同，说明存在环
   - 如果根节点不同，合并这两个集合
3. 如果遍历完所有边都没有发现环，则图中无环

## Java 实现

### 基础并查集实现

```java
public class UnionFind {
    private int[] parent;
    private int[] rank;  // 用于按秩合并
    
    public UnionFind(int size) {
        parent = new int[size];
        rank = new int[size];
        // 初始化，每个元素的父节点都是自己
        for (int i = 0; i < size; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    /**
     * 查找根节点（路径压缩）
     */
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
    }
    
    /**
     * 合并两个集合（按秩合并）
     * @return 如果x和y已经在同一集合中返回false，否则返回true
     */
    public boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        // 如果已经在同一集合中
        if (rootX == rootY) {
            return false;
        }
        
        // 按秩合并
        if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
}
```

### 判断图中是否有环

```java
import java.util.*;

public class CycleDetection {
    
    static class Edge {
        int from, to;
        public Edge(int from, int to) {
            this.from = from;
            this.to = to;
        }
    }
    
    /**
     * 使用并查集判断无向图是否有环
     * @param V 顶点数量
     * @param edges 边列表
     * @return 是否有环
     */
    public static boolean hasCycle(int V, List<Edge> edges) {
        UnionFind uf = new UnionFind(V);
        
        for (Edge edge : edges) {
            int from = edge.from;
            int to = edge.to;
            
            // 如果两个顶点已经在同一集合中，说明有环
            if (!uf.union(from, to)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * 使用并查集判断无向图是否有环（邻接矩阵版本）
     */
    public static boolean hasCycleMatrix(int V, int[][] graph) {
        UnionFind uf = new UnionFind(V);
        
        for (int i = 0; i < V; i++) {
            for (int j = i + 1; j < V; j++) {
                if (graph[i][j] != 0) {  // 存在边
                    if (!uf.union(i, j)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
```

### 完整测试示例

```java
public class CycleDetectionTest {
    public static void main(String[] args) {
        // 测试用例1：无环图
        System.out.println("=== 测试无环图 ===");
        testAcyclicGraph();
        
        // 测试用例2：有环图
        System.out.println("\n=== 测试有环图 ===");
        testCyclicGraph();
        
        // 测试用例3：自环
        System.out.println("\n=== 测试自环 ===");
        testSelfLoop();
    }
    
    private static void testAcyclicGraph() {
        int V = 4;
        List<Edge> edges = Arrays.asList(
            new Edge(0, 1),
            new Edge(1, 2),
            new Edge(2, 3)
        );
        
        boolean hasCycle = CycleDetection.hasCycle(V, edges);
        System.out.println("无环图检测结果: " + hasCycle);
        System.out.println("期望: false");
    }
    
    private static void testCyclicGraph() {
        int V = 4;
        List<Edge> edges = Arrays.asList(
            new Edge(0, 1),
            new Edge(1, 2),
            new Edge(2, 3),
            new Edge(3, 0)  // 形成环
        );
        
        boolean hasCycle = CycleDetection.hasCycle(V, edges);
        System.out.println("有环图检测结果: " + hasCycle);
        System.out.println("期望: true");
    }
    
    private static void testSelfLoop() {
        int V = 3;
        List<Edge> edges = Arrays.asList(
            new Edge(0, 1),
            new Edge(1, 1)  // 自环
        );
        
        boolean hasCycle = CycleDetection.hasCycle(V, edges);
        System.out.println("自环检测结果: " + hasCycle);
        System.out.println("期望: true");
    }
}
```

### 在 Kruskal 算法中的应用

```java
public class KruskalMST {
    
    static class WeightedEdge implements Comparable<WeightedEdge> {
        int from, to, weight;
        
        public WeightedEdge(int from, int to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
        
        @Override
        public int compareTo(WeightedEdge other) {
            return Integer.compare(this.weight, other.weight);
        }
    }
    
    /**
     * 使用并查集实现的Kruskal算法
     */
    public static List<WeightedEdge> kruskalMST(int V, List<WeightedEdge> edges) {
        List<WeightedEdge> mst = new ArrayList<>();
        UnionFind uf = new UnionFind(V);
        
        // 按权重排序
        Collections.sort(edges);
        
        for (WeightedEdge edge : edges) {
            if (uf.union(edge.from, edge.to)) {
                mst.add(edge);
                
                // 当找到V-1条边时，MST构建完成
                if (mst.size() == V - 1) {
                    break;
                }
            }
        }
        
        return mst;
    }
}
```

## 时间复杂度分析

- **初始化**：O(V)
- **每次 find 操作**：接近 O(1)（使用路径压缩和按秩合并时）
- **每次 union 操作**：接近 O(1)
- **整体判断环**：O(E × α(V))，其中 α 是反阿克曼函数，增长极慢

## 应用场景

1. **图论算法**：Kruskal 算法、判断连通性
2. **网络连接**：判断网络中的环路
3. **编译器优化**：检测代码中的循环依赖
4. **游戏开发**：判断地图连通性
5. **社交网络**：判断关系网中的环路

## 注意事项

1. **只适用于无向图**：对于有向图判断环需要使用 DFS 或其他算法
2. **自环检测**：连接顶点到自身的边会形成环
3. **平行边**：两个顶点间的多条边在某些定义下也被认为是环

## 性能优化技巧

```java
// 更紧凑的并查集实现（适用于竞赛编程）
class CompactUnionFind {
    private int[] parent;
    
    public CompactUnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    public int find(int x) {
        return parent[x] == x ? x : (parent[x] = find(parent[x]));
    }
    
    public boolean union(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;
        parent[y] = x;
        return true;
    }
}
```

并查集判断环是一种高效且实现简单的算法，特别适合在需要动态处理连通性问题的场景中使用。