# 有向无环图和拓扑排序

## 有向无环图 (DAG) 基础

### 1. DAG 的定义和性质

**有向无环图 (Directed Acyclic Graph)**：有向图中不存在任何环

```java
// DAG 的基本性质
class DAGProperties {
    /**
     * DAG 的重要性质：
     * 1. 有向性：边有方向
     * 2. 无环性：不存在路径使得顶点能回到自身
     * 3. 必有拓扑排序
     * 4. 至少有一个入度为0的顶点（源点）
     * 5. 至少有一个出度为0的顶点（汇点）
     */
}
```

### 2. DAG 的表示

```java
import java.util.*;

class DAG {
    private int V; // 顶点数
    private List<List<Integer>> adj; // 邻接表
    
    public DAG(int vertices) {
        this.V = vertices;
        this.adj = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            adj.add(new ArrayList<>());
        }
    }
    
    // 添加有向边
    public void addEdge(int from, int to) {
        adj.get(from).add(to);
    }
    
    // 检查是否为 DAG
    public boolean isDAG() {
        boolean[] visited = new boolean[V];
        boolean[] recStack = new boolean[V];
        
        for (int i = 0; i < V; i++) {
            if (hasCycle(i, visited, recStack)) {
                return false;
            }
        }
        return true;
    }
    
    private boolean hasCycle(int v, boolean[] visited, boolean[] recStack) {
        if (recStack[v]) return true;
        if (visited[v]) return false;
        
        visited[v] = true;
        recStack[v] = true;
        
        for (int neighbor : adj.get(v)) {
            if (hasCycle(neighbor, visited, recStack)) {
                return true;
            }
        }
        
        recStack[v] = false;
        return false;
    }
}
```

## 拓扑排序

### 1. 拓扑排序的定义

**拓扑排序**：对有向无环图的顶点进行线性排序，使得对于每条有向边 (u → v)，u 在排序中都出现在 v 之前。

```java
// 拓扑排序的应用场景
class TopologicalSortApplications {
    /**
     * 应用场景：
     * 1. 任务调度：有依赖关系的任务执行顺序
     * 2. 课程安排：先修课程关系
     * 3. 构建系统：文件编译依赖
     * 4. 事件排序：因果关系
     */
}
```

### 2. Kahn 算法（基于入度）

```java
class TopologicalSortKahn {
    
    public static List<Integer> topologicalSort(int V, List<List<Integer>> adj) {
        // 计算入度
        int[] inDegree = new int[V];
        for (int i = 0; i < V; i++) {
            for (int neighbor : adj.get(i)) {
                inDegree[neighbor]++;
            }
        }
        
        // 初始化队列（入度为0的顶点）
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < V; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        int visitedCount = 0;
        
        // 处理队列
        while (!queue.isEmpty()) {
            int current = queue.poll();
            result.add(current);
            visitedCount++;
            
            // 减少邻居的入度
            for (int neighbor : adj.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        // 检查是否有环
        if (visitedCount != V) {
            throw new IllegalArgumentException("图中存在环，无法进行拓扑排序");
        }
        
        return result;
    }
}
```

### 3. 基于 DFS 的拓扑排序

```java
class TopologicalSortDFS {
    
    public static List<Integer> topologicalSortDFS(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, adj, visited, stack);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }
        return result;
    }
    
    private static void dfs(int v, List<List<Integer>> adj, 
                           boolean[] visited, Stack<Integer> stack) {
        visited[v] = true;
        
        for (int neighbor : adj.get(v)) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited, stack);
            }
        }
        
        stack.push(v);
    }
}
```

## 完整示例和测试

### 1. 课程安排问题

```java
class CourseSchedule {
    
    /**
     * 课程安排问题：
     * 有 n 门课程，编号 0 到 n-1
     * 先修关系：prerequisites[i] = [a, b] 表示要学习课程 a 需要先完成课程 b
     * 判断是否可以完成所有课程，并返回学习顺序
     */
    
    public static boolean canFinish(int numCourses, int[][] prerequisites) {
        // 构建图
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        
        int[] inDegree = new int[numCourses];
        
        for (int[] pre : prerequisites) {
            int course = pre[0];
            int prerequisite = pre[1];
            graph.get(prerequisite).add(course);
            inDegree[course]++;
        }
        
        // Kahn 算法
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        int completed = 0;
        while (!queue.isEmpty()) {
            int current = queue.poll();
            completed++;
            
            for (int neighbor : graph.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        return completed == numCourses;
    }
    
    public static int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        
        int[] inDegree = new int[numCourses];
        
        for (int[] pre : prerequisites) {
            int course = pre[0];
            int prerequisite = pre[1];
            graph.get(prerequisite).add(course);
            inDegree[course]++;
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        int[] result = new int[numCourses];
        int index = 0;
        int completed = 0;
        
        while (!queue.isEmpty()) {
            int current = queue.poll();
            result[index++] = current;
            completed++;
            
            for (int neighbor : graph.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        if (completed != numCourses) {
            return new int[0]; // 无法完成
        }
        
        return result;
    }
}
```

### 2. 测试示例

```java
public class DAGTopologicalTest {
    public static void main(String[] args) {
        // 测试用例1：简单的 DAG
        testSimpleDAG();
        
        // 测试用例2：课程安排问题
        testCourseSchedule();
        
        // 测试用例3：有环图
        testCyclicGraph();
    }
    
    private static void testSimpleDAG() {
        System.out.println("=== 测试简单 DAG ===");
        DAG dag = new DAG(6);
        dag.addEdge(5, 2);
        dag.addEdge(5, 0);
        dag.addEdge(4, 0);
        dag.addEdge(4, 1);
        dag.addEdge(2, 3);
        dag.addEdge(3, 1);
        
        System.out.println("是否为 DAG: " + dag.isDAG());
        
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < 6; i++) adj.add(new ArrayList<>());
        adj.get(5).addAll(Arrays.asList(2, 0));
        adj.get(4).addAll(Arrays.asList(0, 1));
        adj.get(2).add(3);
        adj.get(3).add(1);
        
        List<Integer> result = TopologicalSortKahn.topologicalSort(6, adj);
        System.out.println("拓扑排序结果: " + result);
    }
    
    private static void testCourseSchedule() {
        System.out.println("\n=== 测试课程安排 ===");
        int numCourses = 4;
        int[][] prerequisites = {{1,0}, {2,0}, {3,1}, {3,2}};
        
        boolean canFinish = CourseSchedule.canFinish(numCourses, prerequisites);
        System.out.println("能否完成课程: " + canFinish);
        
        int[] order = CourseSchedule.findOrder(numCourses, prerequisites);
        System.out.println("学习顺序: " + Arrays.toString(order));
    }
    
    private static void testCyclicGraph() {
        System.out.println("\n=== 测试有环图 ===");
        DAG cyclicGraph = new DAG(3);
        cyclicGraph.addEdge(0, 1);
        cyclicGraph.addEdge(1, 2);
        cyclicGraph.addEdge(2, 0); // 形成环
        
        System.out.println("是否为 DAG: " + cyclicGraph.isDAG());
        
        try {
            List<List<Integer>> adj = new ArrayList<>();
            for (int i = 0; i < 3; i++) adj.add(new ArrayList<>());
            adj.get(0).add(1);
            adj.get(1).add(2);
            adj.get(2).add(0);
            
            List<Integer> result = TopologicalSortKahn.topologicalSort(3, adj);
            System.out.println("拓扑排序结果: " + result);
        } catch (IllegalArgumentException e) {
            System.out.println("预期错误: " + e.getMessage());
        }
    }
}
```

## DAG 的高级应用

### 1. 关键路径（最长路径）

```java
class CriticalPath {
    
    /**
     * 在 DAG 中寻找最长路径（关键路径）
     * 常用于项目管理和任务调度
     */
    public static int[] longestPath(int V, List<List<int[]>> adj, int source) {
        // 拓扑排序
        List<Integer> topologicalOrder = getTopologicalOrder(V, adj);
        
        int[] dist = new int[V];
        Arrays.fill(dist, Integer.MIN_VALUE);
        dist[source] = 0;
        
        // 按拓扑顺序处理顶点
        for (int u : topologicalOrder) {
            if (dist[u] != Integer.MIN_VALUE) {
                for (int[] edge : adj.get(u)) {
                    int v = edge[0];
                    int weight = edge[1];
                    if (dist[v] < dist[u] + weight) {
                        dist[v] = dist[u] + weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
    private static List<Integer> getTopologicalOrder(int V, List<List<int[]>> adj) {
        // 实现拓扑排序（略）
        return new ArrayList<>();
    }
}
```

### 2. DAG 的最短路径

```java
class DAGShortestPath {
    
    public static int[] shortestPath(int V, List<List<int[]>> adj, int source) {
        // 拓扑排序
        List<Integer> topologicalOrder = TopologicalSortDFS.topologicalSortDFS(V, 
            convertToIntegerAdj(adj));
        
        int[] dist = new int[V];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        
        for (int u : topologicalOrder) {
            if (dist[u] != Integer.MAX_VALUE) {
                for (int[] edge : adj.get(u)) {
                    int v = edge[0];
                    int weight = edge[1];
                    if (dist[v] > dist[u] + weight) {
                        dist[v] = dist[u] + weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
    private static List<List<Integer>> convertToIntegerAdj(List<List<int[]>> adj) {
        List<List<Integer>> result = new ArrayList<>();
        for (List<int[]> edges : adj) {
            List<Integer> neighbors = new ArrayList<>();
            for (int[] edge : edges) {
                neighbors.add(edge[0]);
            }
            result.add(neighbors);
        }
        return result;
    }
}
```

## 算法复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| Kahn | O(V + E) | O(V) | 需要检测环，直观易懂 |
| DFS | O(V + E) | O(V) | 递归实现，代码简洁 |

## 总结

### DAG 和拓扑排序的重要性：

1. **理论价值**：DAG 是许多算法问题的基础结构
2. **实际应用**：广泛用于任务调度、依赖管理、编译系统等
3. **算法基础**：为动态规划、最短路径等算法提供基础
4. **问题建模**：许多现实问题可以抽象为 DAG 问题

### 关键要点：

- **DAG 必存在拓扑排序**，反之亦然
- **拓扑排序不唯一**：一个 DAG 可能有多个有效的拓扑排序
- **环检测**：无法进行拓扑排序意味着图中存在环
- **应用广泛**：从编译器到项目管理都有重要应用

理解 DAG 和拓扑排序对于解决复杂的依赖关系问题至关重要，是算法学习中不可或缺的一部分。