好的，我们来详细讲解**插入排序**，这是一种直观且高效的简单排序算法。

## 1. 插入排序的核心思想

插入排序的思想就像我们整理扑克牌一样：
- 假设手中的牌已经有一部分是排好序的
- 每次从剩余的牌中拿出一张，**插入**到已排序部分的正确位置
- 重复这个过程，直到所有牌都排好序

## 2. 算法步骤分解

以数组 `[5, 2, 4, 6, 1, 3]` 为例：

**初始状态**：已排序部分只有第一个元素 `[5]`，未排序部分 `[2, 4, 6, 1, 3]`

**第1轮**：拿出 `2`
- 比较：2 < 5，将5右移
- 插入2到正确位置
- 结果：`[2, 5, 4, 6, 1, 3]`

**第2轮**：拿出 `4`
- 比较：4 < 5，将5右移；4 > 2，停止比较
- 插入4到正确位置
- 结果：`[2, 4, 5, 6, 1, 3]`

**第3轮**：拿出 `6`
- 比较：6 > 5，直接放在末尾
- 结果：`[2, 4, 5, 6, 1, 3]`

**第4轮**：拿出 `1`
- 比较：1 < 6，右移6；1 < 5，右移5；1 < 4，右移4；1 < 2，右移2
- 插入1到最前面
- 结果：`[1, 2, 4, 5, 6, 3]`

**第5轮**：拿出 `3`
- 比较：3 < 6，右移6；3 < 5，右移5；3 < 4，右移4；3 > 2，停止
- 插入3到正确位置
- 结果：`[1, 2, 3, 4, 5, 6]`

## 3. Java实现

```java
public class InsertionSort {
    
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        System.out.println("原始数组: " + Arrays.toString(arr));
        
        // 从第二个元素开始（索引1），因为第一个元素自然是有序的
        for (int i = 1; i < n; i++) {
            int key = arr[i];  // 当前要插入的元素
            int j = i - 1;
            
            System.out.printf("第%d轮: 要插入的元素是 %d%n", i, key);
            
            // 将比key大的元素都向右移动一位
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
                System.out.println("  移动元素: " + Arrays.toString(arr));
            }
            
            // 将key插入到正确位置
            arr[j + 1] = key;
            System.out.println("  插入后: " + Arrays.toString(arr));
            System.out.println();
        }
    }
    
    // 简化版本（无输出）
    public static void insertionSortSimple(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // 寻找key的插入位置
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
    
    // 测试代码
    public static void main(String[] args) {
        int[] arr = {5, 2, 4, 6, 1, 3};
        
        System.out.println("=== 插入排序演示 ===");
        insertionSort(arr);
        
        System.out.println("最终排序结果: " + Arrays.toString(arr));
    }
}
```

## 4. 运行结果示例

```
=== 插入排序演示 ===
原始数组: [5, 2, 4, 6, 1, 3]

第1轮: 要插入的元素是 2
  移动元素: [5, 5, 4, 6, 1, 3]
  插入后: [2, 5, 4, 6, 1, 3]

第2轮: 要插入的元素是 4
  移动元素: [2, 5, 5, 6, 1, 3]
  插入后: [2, 4, 5, 6, 1, 3]

第3轮: 要插入的元素是 6
  插入后: [2, 4, 5, 6, 1, 3]

第4轮: 要插入的元素是 1
  移动元素: [2, 4, 5, 6, 6, 3]
  移动元素: [2, 4, 5, 5, 6, 3]
  移动元素: [2, 4, 4, 5, 6, 3]
  移动元素: [2, 2, 4, 5, 6, 3]
  插入后: [1, 2, 4, 5, 6, 3]

第5轮: 要插入的元素是 3
  移动元素: [1, 2, 4, 5, 6, 6]
  移动元素: [1, 2, 4, 5, 5, 6]
  移动元素: [1, 2, 4, 4, 5, 6]
  插入后: [1, 2, 3, 4, 5, 6]

最终排序结果: [1, 2, 3, 4, 5, 6]
```

## 5. 算法特点

**时间复杂度：**
- **最好情况**（数组已有序）：O(n) - 只需要比较n-1次
- **最坏情况**（数组逆序）：O(n²) - 每个元素都要移动很多次
- **平均情况**：O(n²)

**空间复杂度：** O(1) - 原地排序

**优点：**
- 实现简单，代码短小
- 对于小数据集非常高效
- 对于基本有序的数组，性能接近O(n)
- 稳定排序（相等元素的相对位置不变）
- 原地排序，不需要额外空间

**缺点：**
- 最坏情况时间复杂度为O(n²)
- 不适合大规模乱序数据集

## 6. 实际应用场景

1. **小规模数据**：当n < 50时，插入排序往往比O(n log n)的算法更快
2. **部分有序数组**：对于基本有序的数据，插入排序效率很高
3. **作为其他算法的基础**：比如在快速排序和归并排序中，当子数组规模较小时，会切换到插入排序

## 7. 关键理解点

1. **"抓牌"思想**：像整理扑克牌一样，每次处理一张新牌
2. **已排序区**：维护一个始终有序的子数组
3. **元素移动**：通过右移元素来为新元素腾出空间
4. **提前终止**：内层循环可以提前终止，这是它高效的原因之一

插入排序虽然理论复杂度不高，但由于其出色的常数因子和缓存友好性，在实际应用中对于小规模数据非常有效！