好的，我们来详细讲解一下数据结构中，特别是在**平衡二叉搜索树（如AVL树、红黑树）** 中非常重要的一个操作——**树的旋转**。

### 1. 为什么需要旋转？

首先，要理解旋转的目的。普通的二叉搜索树（BST）在插入或删除节点时，如果顺序不当（例如按顺序插入1,2,3,4），会退化成一条链表，使得搜索、插入、删除的时间复杂度从理想的O(log n)恶化到O(n)。

为了解决这个问题，我们引入了**平衡二叉搜索树**。它通过定义一些平衡规则，并在插入/删除操作后通过**旋转**来调整树的结构，使其始终保持平衡，从而保证各项操作的高效性。

**旋转的核心目的**：在保持二叉搜索树“左小右大”性质的前提下，通过局部调整降低树的高度，或使树重新满足平衡条件。

---

### 2. 旋转的基本类型

旋转主要分为四种基本类型，但两两对称，所以本质上就是两种：
1.  **左旋 (Left Rotation)**
2.  **右旋 (Right Rotation)**
3.  左右旋 (Left-Right Rotation) - **先左旋再右旋**
4.  右左旋 (Right-Left Rotation) - **先右旋再左旋**

后两种是前两种的组合，用于处理更复杂的不平衡情况。

---

### 3. 单旋：左旋和右旋

#### (1) 右旋 (Right Rotation)

**场景**：当一个节点的**左子树比右子树高**太多，导致不平衡时（例如在AVL树中，其平衡因子 > 1），我们需要进行右旋操作。可以理解为把树“向右扳倒”。

**操作对象**：围绕**不平衡节点**（图中为 `A`）进行旋转。

**步骤**（对照下图）：
1.  将 `A` 的左孩子 `B` 提升为新的根节点（子树的根）。
2.  将 `B` 的右子树（`β`）作为 `A` 的新左子树。
3.  将 `A` 作为 `B` 的新右子树。

**口诀**：提左子，变根节点；原根节点，变成新右。

**Before Right Rotation**:
```
        A
       / \
      B   γ
     / \
    α   β
```

**After Right Rotation**:
```
        B
       / \
      α   A
         / \
        β   γ
```
*（注：α, β, γ 代表子树，可能为空）*

---

#### (2) 左旋 (Left Rotation)

**场景**：当一个节点的**右子树比左子树高**太多，导致不平衡时（例如在AVL树中，其平衡因子 < -1），我们需要进行左旋操作。可以理解为把树“向左扳倒”。

**操作对象**：围绕**不平衡节点**（图中为 `A`）进行旋转。

**步骤**（对照下图）：
1.  将 `A` 的右孩子 `B` 提升为新的根节点（子树的根）。
2.  将 `B` 的左子树（`β`）作为 `A` 的新右子树。
3.  将 `A` 作为 `B` 的新左子树。

**口诀**：提右子，变根节点；原根节点，变成新左。

**Before Left Rotation**:
```
      A
     / \
    α   B
       / \
      β   γ
```

**After Left Rotation**:
```
        B
       / \
      A   γ
     / \
    α   β
```
*（注：α, β, γ 代表子树，可能为空）*

---

### 4. 双旋：左右旋和右左旋

有些情况一次单旋无法解决不平衡问题，需要两次旋转。

#### (1) 左右旋 (Left-Right Rotation)

**场景**：不平衡节点 `A` 的**左孩子 `B` 的右子树**过高导致复杂的不平衡。
**操作**：**先对左孩子 `B` 进行左旋，再对 `A` 进行右旋**。

**过程分解**：
1.  **左旋**：对 `A` 的左孩子 `B` 执行一次左旋。这将问题转换成了简单的左左不平衡。
2.  **右旋**：再对不平衡节点 `A` 执行一次右旋。

```
// 初始状态
    A
   / \
  B   γ
 / \
α   C
   / \
  β1 β2

// Step 1: 对B进行左旋
    A
   / \
  C   γ
 / \
B   β2
/ \
α  β1

// Step 2: 对A进行右旋
      C
     / \
    B   A
   / \ / \
  α β1 β2 γ
```

#### (2) 右左旋 (Right-Left Rotation)

**场景**：不平衡节点 `A` 的**右孩子 `B` 的左子树**过高导致复杂的不平衡。
**操作**：**先对右孩子 `B` 进行右旋，再对 `A` 进行左旋**。

**过程分解**：
1.  **右旋**：对 `A` 的右孩子 `B` 执行一次右旋。这将问题转换成了简单的右右不平衡。
2.  **左旋**：再对不平衡节点 `A` 执行一次左旋。

```
// 初始状态
    A
   / \
  α   B
     / \
    C   γ
   / \
  β1 β2

// Step 1: 对B进行右旋
    A
   / \
  α   C
     / \
    β1  B
       / \
      β2  γ

// Step 2: 对A进行左旋
      C
     / \
    A   B
   / \ / \
  α β1 β2 γ
```

---

### 5. 实例：在AVL树中的应用

AVL树要求每个节点的左右子树高度差（平衡因子）绝对值不超过1。
插入节点后，从插入点向上回溯，检查每个祖先节点的平衡因子。

1.  **发现不平衡**：找到第一个不平衡的节点。
2.  **判断类型**：
    *   **LL型**（左孩子的左子树导致）：一次**右旋**。
    *   **RR型**（右孩子的右子树导致）：一次**左旋**。
    *   **LR型**（左孩子的右子树导致）：一次**左右双旋**。
    *   **RL型**（右孩子的左子树导致）：一次**右左双旋**。
3.  **执行旋转**：完成旋转后，该子树的高度降低，恢复平衡，并且整个树仍然保持BST的性质。

### 总结

| 旋转类型 | 适用情况（以AVL树为例） | 操作方式 |
| :--- | :--- | :--- |
| **右旋** | LL型不平衡（左子树更高，且左孩子也是左子树更高或平衡） | 围绕不平衡节点进行一次右旋 |
| **左旋** | RR型不平衡（右子树更高，且右孩子也是右子树更高或平衡） | 围绕不平衡节点进行一次左旋 |
| **左右旋** | LR型不平衡（左子树更高，但左孩子的右子树更高） | 先对左孩子左旋，再对自己右旋 |
| **右左旋** | RL型不平衡（右子树更高，但右孩子的左子树更高） | 先对右孩子右旋，再对自己左旋 |

树的旋转是平衡二叉树的核心维护操作，它通过O(1)时间复杂度的局部调整，保证了整棵树在动态更新后依然能维持大致平衡，是实现高效查找、插入、删除算法的基石。