# Java中最小堆的实现

在Java中，最小堆通常使用数组来实现，遵循堆的性质：父节点的值总是小于或等于其子节点的值。

## 1. 基础最小堆实现

```java
import java.util.Arrays;
import java.util.NoSuchElementException;

public class MinHeap {
    private int[] heap;
    private int size;
    private int capacity;
    
    // 构造函数
    public MinHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity];
    }
    
    // 获取父节点索引
    private int parent(int index) {
        return (index - 1) / 2;
    }
    
    // 获取左子节点索引
    private int leftChild(int index) {
        return 2 * index + 1;
    }
    
    // 获取右子节点索引
    private int rightChild(int index) {
        return 2 * index + 2;
    }
    
    // 交换两个元素
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
    // 上浮操作
    private void heapifyUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            swap(parent(index), index);
            index = parent(index);
        }
    }
    
    // 下沉操作
    private void heapifyDown(int index) {
        int smallest = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        // 找到当前节点、左子节点、右子节点中最小的
        if (left < size && heap[left] < heap[smallest]) {
            smallest = left;
        }
        
        if (right < size && heap[right] < heap[smallest]) {
            smallest = right;
        }
        
        // 如果最小的不是当前节点，交换并继续下沉
        if (smallest != index) {
            swap(index, smallest);
            heapifyDown(smallest);
        }
    }
    
    // 插入元素
    public void insert(int value) {
        if (size == capacity) {
            // 扩容
            capacity *= 2;
            heap = Arrays.copyOf(heap, capacity);
        }
        
        heap[size] = value;
        heapifyUp(size);
        size++;
    }
    
    // 删除并返回最小元素
    public int extractMin() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        
        int min = heap[0];
        heap[0] = heap[size - 1];
        size--;
        heapifyDown(0);
        
        return min;
    }
    
    // 获取最小元素（不删除）
    public int peek() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        return heap[0];
    }
    
    // 堆的大小
    public int size() {
        return size;
    }
    
    // 判断堆是否为空
    public boolean isEmpty() {
        return size == 0;
    }
    
    // 打印堆
    public void printHeap() {
        System.out.print("Min Heap: ");
        for (int i = 0; i < size; i++) {
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }
}
```

## 2. 泛型最小堆实现

```java
import java.util.*;

public class GenericMinHeap<T extends Comparable<T>> {
    private List<T> heap;
    
    public GenericMinHeap() {
        this.heap = new ArrayList<>();
    }
    
    public GenericMinHeap(int capacity) {
        this.heap = new ArrayList<>(capacity);
    }
    
    private int parent(int index) {
        return (index - 1) / 2;
    }
    
    private int leftChild(int index) {
        return 2 * index + 1;
    }
    
    private int rightChild(int index) {
        return 2 * index + 2;
    }
    
    private void swap(int i, int j) {
        T temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }
    
    private void heapifyUp(int index) {
        while (index > 0 && 
               heap.get(parent(index)).compareTo(heap.get(index)) > 0) {
            swap(parent(index), index);
            index = parent(index);
        }
    }
    
    private void heapifyDown(int index) {
        int smallest = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < heap.size() && 
            heap.get(left).compareTo(heap.get(smallest)) < 0) {
            smallest = left;
        }
        
        if (right < heap.size() && 
            heap.get(right).compareTo(heap.get(smallest)) < 0) {
            smallest = right;
        }
        
        if (smallest != index) {
            swap(index, smallest);
            heapifyDown(smallest);
        }
    }
    
    public void insert(T value) {
        heap.add(value);
        heapifyUp(heap.size() - 1);
    }
    
    public T extractMin() {
        if (heap.isEmpty()) {
            throw new NoSuchElementException("Heap is empty");
        }
        
        T min = heap.get(0);
        T last = heap.remove(heap.size() - 1);
        
        if (!heap.isEmpty()) {
            heap.set(0, last);
            heapifyDown(0);
        }
        
        return min;
    }
    
    public T peek() {
        if (heap.isEmpty()) {
            throw new NoSuchElementException("Heap is empty");
        }
        return heap.get(0);
    }
    
    public int size() {
        return heap.size();
    }
    
    public boolean isEmpty() {
        return heap.isEmpty();
    }
    
    // 堆排序（会破坏堆结构）
    public List<T> heapSort() {
        List<T> sorted = new ArrayList<>();
        GenericMinHeap<T> tempHeap = new GenericMinHeap<>();
        tempHeap.heap = new ArrayList<>(this.heap);
        
        while (!tempHeap.isEmpty()) {
            sorted.add(tempHeap.extractMin());
        }
        
        return sorted;
    }
}
```

## 3. 使用PriorityQueue（Java内置）

```java
import java.util.*;

public class PriorityQueueExample {
    public static void main(String[] args) {
        // Java内置的最小堆（PriorityQueue默认是最小堆）
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        // 添加元素
        minHeap.offer(5);
        minHeap.offer(2);
        minHeap.offer(8);
        minHeap.offer(1);
        minHeap.offer(3);
        
        System.out.println("最小堆元素:");
        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " "); // 输出: 1 2 3 5 8
        }
        System.out.println();
        
        // 最大堆（使用Comparator.reverseOrder()）
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        
        maxHeap.offer(5);
        maxHeap.offer(2);
        maxHeap.offer(8);
        maxHeap.offer(1);
        maxHeap.offer(3);
        
        System.out.println("最大堆元素:");
        while (!maxHeap.isEmpty()) {
            System.out.print(maxHeap.poll() + " "); // 输出: 8 5 3 2 1
        }
        System.out.println();
    }
}
```

## 4. 自定义对象的最小堆

```java
class Student implements Comparable<Student> {
    String name;
    int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.score, other.score);
    }
    
    @Override
    public String toString() {
        return name + "(" + score + ")";
    }
}

public class CustomObjectMinHeap {
    public static void main(String[] args) {
        GenericMinHeap<Student> studentHeap = new GenericMinHeap<>();
        
        studentHeap.insert(new Student("Alice", 85));
        studentHeap.insert(new Student("Bob", 92));
        studentHeap.insert(new Student("Charlie", 78));
        studentHeap.insert(new Student("David", 95));
        
        System.out.println("按分数排序的学生:");
        while (!studentHeap.isEmpty()) {
            System.out.println(studentHeap.extractMin());
        }
    }
}
```

## 5. 测试示例

```java
public class MinHeapExample {
    public static void main(String[] args) {
        // 测试基础最小堆
        MinHeap heap = new MinHeap(10);
        
        heap.insert(10);
        heap.insert(5);
        heap.insert(20);
        heap.insert(3);
        heap.insert(8);
        heap.insert(15);
        
        heap.printHeap(); // 最小堆结构
        
        System.out.println("提取最小元素:");
        while (!heap.isEmpty()) {
            System.out.print(heap.extractMin() + " "); // 3 5 8 10 15 20
        }
        System.out.println();
    }
}
```

## 关键点总结：

1. **核心操作**：插入(`insert`)、删除最小元素(`extractMin`)、获取最小元素(`peek`)
2. **维护堆性质**：上浮(`heapifyUp`)和下沉(`heapifyDown`)操作
3. **时间复杂度**：插入和删除都是O(log n)，获取最小值是O(1)
4. **适用场景**：优先级队列、Dijkstra算法、堆排序等

对于日常使用，推荐直接使用Java内置的`PriorityQueue`，它已经提供了完整的堆功能。如果需要特殊功能或学习目的，可以自己实现。