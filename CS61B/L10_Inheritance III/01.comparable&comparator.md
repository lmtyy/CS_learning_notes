好的，我们来详细讲解 Java 中用于对象排序和比较的两个核心接口：`Comparable` 和 `Comparator`。它们是实现高阶函数概念的经典例子。

### 核心概念对比

| 特性 | `Comparable` (可比较的) | `Comparator` (比较器) |
| :--- | :--- | :--- |
| **包** | `java.lang` | `java.util` |
| **核心方法** | `int compareTo(T o)` | `int compare(T o1, T o2)` |
| **排序逻辑位置** | **内部**（在要比较的类的内部定义） | **外部**（定义一个单独的比较规则） |
| **目的** | 定义对象的**自然顺序**（Natural Order） | 定义对象的**定制顺序**（Custom Order）或替代顺序 |
| **称呼** | 让对象**自己变得可比较** | 创建一个**对象的比较器** |
| **使用场景** | 类有唯一、默认的排序方式（如 String按字母，Integer按数字） | 需要多种排序方式，或无法修改类源码（如第三方库的类） |

---

## 一、Comparable 接口

`Comparable` 接口定义了对象的**自然顺序**。一个类实现了 `Comparable` 接口，就表示它的实例可以相互比较和排序。

### 如何实现？

1.  让需要排序的类实现 `Comparable<T>` 接口（T 是类本身）。
2.  重写 `compareTo(T o)` 方法。
    *   返回一个负整数：表示当前对象 **小于** 参数对象 `o`（应排在前面）。
    *   返回零：表示当前对象 **等于** 参数对象 `o`。
    *   返回一个正整数：表示当前对象 **大于** 参数对象 `o`（应排在后面）。

### 示例：对 Person 对象按年龄进行自然排序

```java
// 1. 实现 Comparable 接口
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // 构造方法、getter、setter、toString 省略...

    // 2. 重写 compareTo 方法，定义自然顺序（这里按年龄升序）
    @Override
    public int compareTo(Person otherPerson) {
        // 经典写法：直接相减（注意整数溢出风险，仅用于示例）
        // return this.age - otherPerson.age;

        // 标准、安全的写法：使用 Integer.compare()
        return Integer.compare(this.age, otherPerson.age);
        
        // 如果想按年龄降序，可以交换两个参数
        // return Integer.compare(otherPerson.age, this.age);
    }
}

// 使用
public class Test {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        );

        // Collections.sort() 和 List.sort() 会自动使用 Comparable 的实现
        Collections.sort(people); 
        // 或者更现代的方式：
        people.sort(null); // 传入 null 表示使用自然顺序

        System.out.println(people);
        // 输出: [Bob (25), Alice (30), Charlie (35)] （按年龄升序）
    }
}
```

---

## 二、Comparator 接口

`Comparator` 接口是一个**函数式接口**，用于定义**独立的、外部的**比较规则。你可以为同一个类创建多个不同的 `Comparator` 来实现多种排序方式。

### 如何实现？

有四种常见的方式创建 `Comparator`：

#### 方式 1：实现 Comparator 接口（传统匿名类）

```java
// 按姓名排序
Comparator<Person> byName = new Comparator<Person>() {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
};
```

#### 方式 2：使用 Lambda 表达式（最常用，Java 8+）

```java
// 按姓名排序 (升序)
Comparator<Person> byName = (p1, p2) -> p1.getName().compareTo(p2.getName());

// 按年龄降序排序
Comparator<Person> byAgeDesc = (p1, p2) -> Integer.compare(p2.getAge(), p1.getAge());
```

#### 方式 3：使用 Comparator 的静态工厂方法（推荐，Java 8+）

`Comparator` 接口提供了大量强大的辅助方法。

```java
import static java.util.Comparator.*;

// 1. comparing: 根据一个键提取函数（Key Extractor）创建Comparator
Comparator<Person> byName = comparing(Person::getName); // 按姓名（String的自然顺序）
Comparator<Person> byAge = comparing(Person::getAge);   // 按年龄（Integer的自然顺序）
Comparator<Person> byNameLength = comparing(p -> p.getName().length()); // 按姓名长度

// 2. 反转顺序
Comparator<Person> byAgeDesc = comparing(Person::getAge).reversed();

// 3. thenComparing: 链式比较（主要规则相同后，按次要规则比较）
// 先按年龄排，年龄相同再按姓名排
Comparator<Person> byAgeThenByName = comparing(Person::getAge)
                                        .thenComparing(comparing(Person::getName));

// 4. nullsFirst / nullsLast: 友好地处理null值
// 将null值视为最小，放在最前面
Comparator<Person> byNameNullsFirst = nullsFirst(comparing(Person::getName));
// 将null值视为最大，放在最后面
Comparator<Person> byNameNullsLast = nullsLast(comparing(Person::getName));
```

#### 方式 4：使用方法引用

```java
// 假设String有自定义的比较器
Comparator<Person> byCaseInsensitiveName = comparing(Person::getName, String.CASE_INSENSITIVE_ORDER);
```

### 示例：使用 Comparator 进行多种排序

```java
public class Test {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("charlie", 35),
            new Person("Bob", 30) // 同名的Bob，年龄不同
        );

        // 1. 按姓名排序 (自然顺序，区分大小写)
        people.sort(comparing(Person::getName));
        System.out.println("By name: " + people);

        // 2. 按年龄降序排序
        people.sort(comparing(Person::getAge).reversed());
        System.out.println("By age desc: " + people);

        // 3. 先按年龄升序，年龄相同再按姓名降序
        Comparator<Person> complexComparator = comparing(Person::getAge)
                                                .thenComparing(comparing(Person::getName).reversed());
        people.sort(complexComparator);
        System.out.println("By age asc, then name desc: " + people);
        
        // 4. 在Stream API中使用
        List<String> sortedNames = people.stream()
                                         .sorted(comparing(Person::getName)) // 排序
                                         .map(Person::getName)
                                         .collect(Collectors.toList());
    }
}
```

---

### 总结与最佳实践

| 场景 | 选择 |
| :--- | :--- |
| 类有**一种明显、默认**的排序方式（如日期、数字、字母） | 实现 **`Comparable`** |
| 需要**多种**排序方式 | 创建多个 **`Comparator`** |
| 无法修改类的源代码（如第三方库的类） | 使用 **`Comparator`** |
| 排序规则简单 | 使用 **Lambda表达式** |
| 排序规则复杂或需要链式、空值安全 | 使用 **`Comparator.comparing()`** 等静态方法 |

**核心区别记忆：**
*   **`Comparable`**: `a.compareTo(b)` — “**a** 如何与 **b** 比较？”
*   **`Comparator`**: `comparator.compare(a, b)` — “**比较器** 如何看待 **a** 和 **b**？”

两者结合使用，为 Java 中的对象排序提供了极其强大和灵活的解决方案，完美体现了策略模式和高阶函数的思想。