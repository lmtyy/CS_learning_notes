好的，我们来详细、深入地探讨一下 Java 中的 `Comparator` 接口。这是一个非常重要且强大的接口，用于定义自定义的排序规则。

### 1. Comparator 接口是什么？

`Comparator` 是一个**函数式接口**（Functional Interface），定义在 `java.util` 包中。它包含一个名为 `compare(T o1, T o2)` 的抽象方法，用于比较两个同类型的对象。

它的核心目的是：**为无法修改其源代码的类（例如 `String`, `Integer` 或第三方库中的类）或者希望有多种排序方式的类，提供一种外部化的、灵活的比较规则**。

这与 `Comparable` 接口形成对比：
- **`Comparable`** (内比较器): 定义在类的内部，通过 `compareTo` 方法实现。它表示对象天生可排序，有一种“自然的”默认排序规则（例如 `String` 按字母表排序，`Integer` 按数字大小排序）。
- **`Comparator`** (外比较器): 定义在类的外部，是一种“策略”（Strategy）设计模式的实现。你可以为同一个类创建多种不同的 `Comparator` 来实现多种排序规则。

### 2. 核心方法：compare(T o1, T o2)

`int compare(T o1, T o2)` 方法是所有比较逻辑的核心。它的返回值规则至关重要：

- **返回负整数**：表示第一个参数 `o1` **小于** 第二个参数 `o2`。在排序结果中，`o1` 会出现在 `o2` 的**前面**。
- **返回零**：表示两个对象相等。
- **返回正整数**：表示第一个参数 `o1` **大于** 第二个参数 `o2`。在排序结果中，`o1` 会出现在 `o2` 的**后面**。

**简单记忆口诀：`o1 - o2` 代表升序（从小到大），反之 `o2 - o1` 代表降序（从大到小）**（对于数值类型而言）。

### 3. 如何使用 Comparator？

主要有三种使用方式，从传统到现代：

#### 方式一：创建独立的 Comparator 实现类（传统，不常用）

你可以创建一个单独的类来实现 `Comparator` 接口。

```java
import java.util.Comparator;

// 定义一个专门的比较器类
class StudentAgeComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        // 按年龄升序排序
        return s1.getAge() - s2.getAge();
    }
}

// 使用
List<Student> students = ...;
students.sort(new StudentAgeComparator()); // 传入比较器实例
// 或者 Collections.sort(students, new StudentAgeComparator());
```

#### 方式二：使用匿名内部类（经典，较常用）

为了避免创建单独的文件，可以在需要的地方直接使用匿名内部类。

```java
List<Student> students = ...;

Collections.sort(students, new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        // 按姓名升序排序 (String 本身实现了 Comparable，可以用 compareTo)
        return s1.getName().compareTo(s2.getName());
    }
});
```

#### 方式三：使用 Lambda 表达式（现代，最常用）

因为 `Comparator` 是函数式接口（只有一个抽象方法），所以它是 Lambda 表达式的完美候选者，代码可以变得极其简洁。

```java
List<Student> students = ...;

// 1. 按年龄升序排序
students.sort((s1, s2) -> s1.getAge() - s2.getAge());

// 因为参数类型可由编译器推断，甚至可以更简洁
students.sort(Comparator.comparingInt(Student::getAge));

// 2. 按姓名降序排序
students.sort((s1, s2) -> s2.getName().compareTo(s1.getName()));

// 3. 更复杂的多级排序：先按年龄降序，年龄相同再按姓名升序
students.sort((s1, s2) -> {
    int ageCompare = s2.getAge() - s1.getAge(); // 年龄降序
    if (ageCompare != 0) {
        return ageCompare;
    }
    return s1.getName().compareTo(s2.getName()); // 姓名升序
});
```

### 4. Comparator 的辅助工具方法（JDK 8+）

Java 8 为 `Comparator` 接口添加了一系列强大的静态和默认方法，使得构建复杂的比较器变得异常简单和流畅。

#### 常用静态方法：

1.  **`Comparator.comparing(Function keyExtractor)`**
    提取一个可比较的排序键（如 `Integer`, `String`），并按其**自然顺序**排序。

    ```java
    // 按学生年龄排序（自然顺序，即升序）
    Comparator<Student> byAge = Comparator.comparing(Student::getAge);
    students.sort(byAge);

    // 按学生姓名排序
    Comparator<Student> byName = Comparator.comparing(Student::getName);
    ```

2.  **`Comparator.comparingInt(ToIntFunction keyExtractor)`**
    专门用于提取 `int` 排序键，避免装箱/拆箱，效率更高。

    ```java
    Comparator<Student> byAge = Comparator.comparingInt(Student::getAge);
    ```

3.  **`Comparator.naturalOrder()` / `Comparator.reverseOrder()`**
    返回一个按自然顺序/逆自然顺序比较的比较器。常用于已经实现了 `Comparable` 的类。

    ```java
    // 对字符串列表按字母表逆序排序
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    names.sort(Comparator.reverseOrder());
    ```

4.  **`Comparator.nullsFirst(Comparator)` / `Comparator.nullsLast(Comparator)`**
    创建一个能友好处理 `null` 值的比较器，将 `null` 值视为最小或最大。

    ```java
    // 按姓名排序，将 null 名字的学生放在最后
    Comparator<Student> byNameNullsLast = Comparator.nullsLast(Comparator.comparing(Student::getName));
    students.sort(byNameNullsLast);
    ```

#### 常用默认方法（用于链式调用）：

1.  **`reversed()`**
    返回当前比较器的逆序版本。

    ```java
    // 按年龄降序排序
    Comparator<Student> byAgeDesc = Comparator.comparingInt(Student::getAge).reversed();
    ```

2.  **`thenComparing(Comparator other)`**
    **多级排序**的关键。如果当前比较器认为两个对象相等，则使用另一个比较器 `other` 进行次级比较。

    ```java
    // 先按年龄升序，如果年龄相同，再按姓名升序
    Comparator<Student> byAgeThenByName = Comparator.comparingInt(Student::getAge)
                                                    .thenComparing(Student::getName);

    // 先按年龄降序，年龄相同再按姓名升序
    Comparator<Student> complexComparator = Comparator.comparingInt(Student::getAge)
                                                     .reversed()
                                                     .thenComparing(Student::getName);
    students.sort(complexComparator);
    ```

### 5. 一个完整的示例

```java
import java.util.*;

class Student {
    private String name;
    private int age;
    private int grade;

    // 构造方法、Getter、Setter、toString 省略...
    public Student(String name, int age, int grade) {
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
    public String getName() { return name; }
    public int getAge() { return age; }
    public int getGrade() { return grade; }
    public String toString() {
        return name + " (Age: " + age + ", Grade: " + grade + ")";
    }
}

public class ComparatorDemo {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", 23, 88),
            new Student("Bob", 20, 92),
            new Student("Charlie", 23, 85),
            new Student("Diana", 20, 95)
        );

        System.out.println("原始列表: " + students);

        // 1. 按年龄升序 (Lambda)
        students.sort((s1, s2) -> s1.getAge() - s2.getAge());
        System.out.println("\n按年龄升序: " + students);

        // 2. 按成绩降序 (方法引用 + reversed)
        students.sort(Comparator.comparingInt(Student::getGrade).reversed());
        System.out.println("按成绩降序: " + students);

        // 3. 多级排序：先按年龄升序，年龄相同按成绩降序
        Comparator<Student> byAge = Comparator.comparingInt(Student::getAge);
        Comparator<Student> byGradeDesc = Comparator.comparingInt(Student::getGrade).reversed();
        students.sort(byAge.thenComparing(byGradeDesc));
        System.out.println("先年龄升序，后成绩降序: " + students);
    }
}
```

### 总结

| 特性 | 描述 |
| :--- | :--- |
| **目的** | 为类提供**外部化的、灵活的、多种**比较规则。 |
| **核心方法** | `int compare(T o1, T o2)`，遵循负/零/正的返回值约定。 |
| **与 Comparable** | `Comparable` 是内在的默认排序（`compareTo`），`Comparator` 是外在的自定义排序。 |
| **现代用法** | **优先使用 `Comparator.comparing()`、Lambda 表达式和方法引用**来创建比较器。 |
| **高级技巧** | 使用 `reversed()`, `thenComparing()` 进行逆序和多级排序，使用 `nullsFirst/Last` 处理空值。 |

掌握 `Comparator` 接口能让你在处理 Java 集合排序时游刃有余，写出既简洁又强大的代码。