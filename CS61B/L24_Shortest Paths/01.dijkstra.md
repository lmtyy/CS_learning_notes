好的，我们来详细分析Dijkstra算法两种实现版本的时间复杂度。

### 1. 朴素版（使用邻接矩阵）

**实现方式**：
- 使用一个二维数组 `graph[][]` 存储图的边权。
- 使用一个数组 `dist[]` 存储源点到各点的最短距离。
- 使用一个布尔数组 `visited[]` 标记节点是否已确定最短距离。

**算法步骤**：
1. 初始化 `dist` 数组，源点设为0，其他设为无穷大。
2. 循环n次（n为节点数）：
   - 在**未访问**节点中找到 `dist` 最小的节点 `u`（需要遍历所有节点）。
   - 标记 `u` 为已访问。
   - 用 `u` 更新所有**未访问**邻居节点的 `dist` 值（需要遍历所有节点检查是否为邻居）。

**时间复杂度分析**：
- 外层循环：O(V)（V为节点数）
- 每次循环中：
  - 查找最小 `dist` 节点：O(V)
  - 更新邻居：O(V)
- **总时间复杂度**：O(V) × O(V) = **O(V²)**

**空间复杂度**：O(V²)（邻接矩阵存储）

### 2. 堆优化版（使用邻接表+优先队列）

**实现方式**：
- 使用邻接表（如 `List<int[]>[] graph`）存储图。
- 使用优先队列（最小堆）快速获取当前距离最小的节点。

**算法步骤**：
1. 初始化优先队列，将源点(距离=0)入队。
2. 当队列不为空：
   - 弹出堆顶节点 `u`（当前距离最小的节点）。
   - 如果 `u` 已访问，跳过。
   - 标记 `u` 为已访问。
   - 遍历 `u` 的所有邻居 `v`：
     - 如果通过 `u` 到 `v` 的距离更短，更新 `dist[v]` 并将 `(新距离, v)` 入队。

**时间复杂度分析**：
- 每个节点最多入队一次（实际可能多次，但每个节点只会被处理一次）。
- 每次从堆中取出最小元素：O(logV)
- 每条边都会被遍历一次来更新邻居：O(E)（E为边数）
- 每次更新可能涉及堆操作（入队）：O(logV)

**总时间复杂度**：O(E logV)

**更精确的分析**：
- 由于每个节点可能多次入队（当找到更短路径时），但标准实现中每个节点只会被处理一次。
- **最佳情况**：O(E logV)
- **最坏情况**：O(E logE)（由于E ≤ V²，logE ≤ 2logV，因此仍是O(E logV)量级）

**空间复杂度**：O(V + E)（邻接表存储）

### 对比总结

| 版本 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 朴素版 | **O(V²)** | O(V²) | 稠密图（E ≈ V²），节点数较少 |
| 堆优化版 | **O(E logV)** | O(V + E) | 稀疏图（E << V²），节点数较多 |

### 选择建议

- **当图很稠密时**（E ≈ V²）：朴素版可能更快，因为O(V²)可能小于O(E logV) = O(V² logV)
- **当图很稀疏时**（E ≈ V）：堆优化版明显更优，O(E logV) ≈ O(V logV) 远小于 O(V²)

在实际编程竞赛和工程应用中，**堆优化版更为常用**，因为现实中的图大多是稀疏的。