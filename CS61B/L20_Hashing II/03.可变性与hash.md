好的，我们来深入探讨**可变性**与 **`HashSet`/`HashMap`** 之间的关系。这是一个非常重要的话题，因为不当的处理会导致一些非常诡异且难以调试的bug。

核心问题在于：**如果你在使用一个对象作为 `HashSet` 或 `HashMap` 的键（Key）时，修改了该对象的字段，将会破坏哈希表的不变性，导致无法预测的行为。**

---

### 一、回顾基础：`HashSet` 和 `HashMap` 如何工作

1.  **存储位置基于哈希码**：当你向 `HashMap` 添加一个键值对或向 `HashSet` 添加一个元素时，会调用键的 `.hashCode()` 方法计算哈希值，根据这个值决定对象应该存放在哪个"桶"里。
2.  **相等性基于 `equals`**：如果发生哈希冲突（两个不同的键有相同的哈希值），系统会使用 `.equals()` 方法在同一个桶内查找确切的键。

**关键点**：这个存储位置（桶的索引）是在**插入时**根据键**当时**的哈希码计算出来的。

---

### 二、灾难场景：修改已作为键的可变对象

让我们通过一个经典的例子来演示这个问题。

#### 示例代码

```java
import java.util.HashMap;
import java.util.Map;

public class MutableKeyDemo {
    static class Person {
        private String name; // 可变字段！
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() { return name; }
        public void setName(String name) { this.name = name; } // Setter 允许修改！

        // 正确重写了 hashCode 和 equals，依赖于 name 和 age
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }

        @Override
        public boolean equals(Object obj) {
            // ... 标准的 equals 实现，比较 name 和 age
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Person person = (Person) obj;
            return age == person.age && Objects.equals(name, person.name);
        }

        @Override
        public String toString() { return "Person{name='" + name + "', age=" + age + '}'; }
    }

    public static void main(String[] args) {
        // 1. 创建一个 Person 对象作为键
        Person alice = new Person("Alice", 30);

        // 2. 将其用作 HashMap 的键，并关联一个值
        Map<Person, String> favoriteFoods = new HashMap<>();
        favoriteFoods.put(alice, "Pizza");

        // 3. 查询 - 正常工作
        String food = favoriteFoods.get(alice);
        System.out.println("Alice's favorite food: " + food); // 输出: Pizza

        // 4. !!! 灾难性的操作：修改键对象的字段 !!!
        alice.setName("Alicia"); // 修改了用于计算 hashCode 和 equals 的字段！

        // 5. 再次尝试查询
        food = favoriteFoods.get(alice);
        System.out.println("After change, Alicia's food: " + food); // 输出: null ???

        // 6. 但键明明在 Map 里！
        System.out.println("Map contains Alicia? " + favoriteFoods.containsKey(alice)); // 输出: false
        System.out.println("Map contents: " + favoriteFoods);
        // 输出: {Person{name='Alice', age=30}=Pizza}
        // 注意：Map 里存储的键仍然是 "Alice"！
    }
}
```

#### 发生了什么？逐步分析

1.  **插入时 (`put(alice, "Pizza")`)**:
    *   计算 `alice.hashCode()`。此时 `name="Alice"`, `age=30`，假设哈希值是 `123`。
    *   将键值对 `(alice, "Pizza")` 存储在哈希表索引为 `123` 的桶中。

2.  **修改键对象 (`alice.setName("Alicia")`)**:
    *   键 `alice` 的内部状态发生了变化！它的 `name` 从 "Alice" 变成了 "Alicia"。
    *   **重要**：`HashMap` 对此一无所知，它不会自动重新分配存储位置。

3.  **查询时 (`get(alice)`)**:
    *   计算 `alice.hashCode()`。此时 `name="Alicia"`, `age=30`，新的哈希值可能是 `456`。
    *   `HashMap` 会去索引为 `456` 的桶里寻找键。
    *   但是，键值对实际存储在索引为 `123` 的桶里！`456` 号桶是空的，所以返回 `null`。
    *   即使 `HashMap` 因为哈希冲突检查了 `123` 号桶，它也会用 `equals` 方法比较。它会拿修改后的 `alice` (name="Alicia") 和桶内存储的原始键 (name="Alice") 比较。由于 `name` 不同，`equals` 返回 `false`，所以仍然认为键不存在。

**结果就是：你永远无法再通过这个被修改过的键对象取回原本关联的值。** 这个键值对变成了一个“幽灵条目”——它存在于 `Map` 中（你可以通过迭代看到它），但你无法通过正常的 `get` 操作访问它。这还会导致内存泄漏，因为这个条目无法被正常使用和回收。

---

### 三、对 `HashSet` 的影响

`HashSet` 本质上就是一个只存储键的 `HashMap`。所以上述问题对 `HashSet` 有完全相同的效果。

```java
HashSet<Person> set = new HashSet<>();
Person p = new Person("Bob", 25);
set.add(p);

System.out.println(set.contains(p)); // 输出: true

p.setName("Robert"); // 修改可变字段

System.out.println(set.contains(p)); // 输出: false! 元素"消失"了
```

---

### 四、最佳实践和解决方案

1.  **首选不可变对象作为键**
    这是最根本、最安全的解决方案。如果作为键的类（如 `String`, `Integer`, `LocalDateTime`）是不可变的，那么它的哈希码在创建后就永远不会改变，从而完美避免了这个问题。

    ```java
    // String 是不可变的，是完美的键
    Map<String, Person> peopleByName = new HashMap<>();
    String key = "Alice";
    peopleByName.put(key, aliceObject);
    // 任何操作都无法改变 key 的内容，哈希码是稳定的。
    ```

2.  **如果必须使用可变对象作为键，请遵守铁律**
    如果你的自定义类必须作为键，并且它确实是可变的，那么你必须确保：
    *   **一旦对象被用作 `HashMap` 或 `HashSet` 的键，就绝对不要再修改那些用于计算 `hashCode()` 和 `equals()` 的字段。**
    *   可以将这些关键字段标记为 `final` 来强制实现这一点。

3.  **如果需要修改键，正确的做法是**
    1.  从 `Map` 中 `remove` 旧的键值对。
    2.  修改对象。
    3.  使用修改后的对象作为键，将键值对重新 `put` 回 `Map`。

    ```java
    // 错误：直接修改
    // alice.setName("Alicia");

    // 正确：先移除，再修改，再插入
    String food = favoriteFoods.remove(alice);
    alice.setName("Alicia");
    favoriteFoods.put(alice, food);
    ```

### 总结

| 行为 | 后果 |
| :--- | :--- |
| 使用不可变对象（如 `String`, `Integer`）作为键 | **安全**。哈希码稳定，行为可预测。 |
| 使用可变对象作为键，但永不修改其关键字段 | **安全**。但需要开发者自觉维护，有风险。 |
| **使用可变对象作为键，并修改了其关键字段** | **灾难**。导致键值对“丢失”，内存泄漏，是严重的逻辑错误。 |

**核心结论**：为了代码的健壮性和可维护性，**强烈建议使用不可变对象作为 `HashMap` 和 `HashSet` 的键**。这是避免这类诡异问题的最有效设计。