好的，这是一个非常重要的问题！外部类访问内部类非常直接，因为外部类完全知晓内部类的存在和结构。

---

### 核心原则

**在外部类内部，你可以像使用普通类一样访问内部类：直接创建实例、调用方法、访问字段（取决于访问修饰符）。**

下面我们分情况详细说明。

---

### 1. 访问成员内部类（最常用的情况）

由于成员内部类依附于外部类的实例，在外部类内部创建内部类实例时，不需要通过外部类实例前缀。

#### 示例1：在外部类的方法中访问

```java
public class Outer {
    private String outerField = "I'm from Outer";

    // 成员内部类
    public class Inner {
        private String innerField = "I'm from Inner";

        public void innerMethod() {
            // 内部类可以自由访问外部类的私有成员
            System.out.println("Inner can see: " + outerField);
        }
    }

    // 外部类的方法
    public void outerMethod() {
        System.out.println("=== Inside outerMethod ===");

        // 1. 创建内部类的实例 (直接 new，不需要 Outer.this)
        Inner innerObj = new Inner(); 

        // 2. 访问内部类的公有方法
        innerObj.innerMethod(); 

        // 3. 访问内部类的公有字段（如果有）
        System.out.println("Outer accessing inner's public field: " + innerObj.innerField);

        // 4. 即使内部类的字段是 private，只要在外部类内部，也能访问（因为外部类是"家长"）
        // 假设 innerField 是 private，下面这行依然可以编译
        // System.out.println("Outer accessing inner's PRIVATE field: " + innerObj.innerField);
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.outerMethod(); // 触发外部类访问内部类
    }
}
```

**输出：**
```
=== Inside outerMethod ===
Inner can see: I'm from Outer
Outer accessing inner's public field: I'm from Inner
```

#### 示例2：在外部类的其他位置（如构造器、代码块）访问

```java
public class Outer {
    private Inner innerInstance;

    // 在构造器中访问
    public Outer() {
        this.innerInstance = new Inner(); // 在构造器中创建内部类实例
        System.out.println("Outer constructor created an Inner.");
    }

    // 在实例初始化块中访问
    {
        Inner innerInBlock = new Inner();
        innerInBlock.innerMethod();
    }

    public class Inner {
        public void innerMethod() {
            System.out.println("Inner method called.");
        }
    }
}
```

---

### 2. 访问静态内部类

访问静态内部类更加简单，因为不需要外部类实例。

```java
public class Outer {
    private static String staticOuterField = "Static Outer Field";

    // 静态内部类
    public static class StaticInner {
        private String innerField = "StaticInner Field";

        public void innerMethod() {
            System.out.println("StaticInner can see: " + staticOuterField);
        }

        public static void staticInnerMethod() {
            System.out.println("Static method in StaticInner.");
        }
    }

    public void outerMethod() {
        System.out.println("=== Accessing Static Inner Class ===");

        // 1. 创建静态内部类实例 (不需要外部类实例)
        StaticInner staticInner = new StaticInner();

        // 2. 调用实例方法
        staticInner.innerMethod();

        // 3. 访问实例字段
        System.out.println(staticInner.innerField);

        // 4. 直接调用静态内部类的静态方法
        StaticInner.staticInnerMethod();
    }

    public static void main(String[] args) {
        new Outer().outerMethod();
    }
}
```

---

### 3. 访问局部内部类和匿名内部类

这两种内部类的作用域仅限于定义它们的方法或代码块内。因此，**外部类只能在定义它们的那个特定作用域内访问它们**。

```java
public class Outer {
    public void outerMethod() {
        final String localVar = "Local Variable";

        // 局部内部类
        class LocalInner {
            public void greet() {
                System.out.println("Hello from LocalInner. Local var: " + localVar);
            }
        }

        // 只能在 outerMethod 内部访问 LocalInner
        LocalInner local = new LocalInner();
        local.greet(); // 这是可以的

        // 匿名内部类
        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println("Running from Anonymous Inner Class.");
            }
        };
        r.run(); // 这也是可以的
    }

    // 在类的其他方法中无法访问 LocalInner 或那个匿名内部类
    public void anotherMethod() {
        // LocalInner local = new LocalInner(); // 编译错误！LocalInner 在此处不可见
        // Runnable r = ... // 也无法访问上面定义的匿名内部类实例
    }
}
```

---

### 4. 特殊的访问语法：`Outer.this`

虽然在外部类内部直接使用 `new Inner()` 最常见，但有时为了清晰表明归属，也可以使用完整语法。

```java
public class Outer {
    private String name = "Outer";

    public class Inner {
        private String name = "Inner";

        public void printNames() {
            System.out.println("Inner's name: " + this.name);       // "Inner"
            System.out.println("Inner's name: " + name);            // "Inner" (同上)
            System.out.println("Outer's name: " + Outer.this.name); // "Outer" !!! 使用 Outer.this 访问外部类实例
        }
    }

    public void test() {
        Inner inner = new Inner();        // 常规方式
        Inner inner2 = this.new Inner();  // 使用 this，明确是当前外部类实例的 Inner
        // Inner inner3 = Outer.this.new Inner(); // 最明确的写法，但通常多余
        inner.printNames();
    }
}
```

**`Outer.this` 的主要用途是在内部类内部，当内部类的成员名与外部类的成员名冲突时，用来明确指代外部类的成员。**

---

### 总结对比

| 场景 | 外部类如何访问内部类 | 关键点 |
| :--- | :--- | :--- |
| **访问成员内部类** | `Inner obj = new Inner();` | 在外部类内部，可以直接创建实例，无需前缀。 |
| **访问静态内部类** | `StaticInner obj = new StaticInner();` | 更加直接，因为不依赖实例。 |
| **访问局部/匿名内部类** | 只能在定义它们的方法或代码块内部访问。 | 作用域受限。 |
| **明确指定外部实例** | `Inner obj = this.new Inner();` | 使用 `this` 或 `Outer.this` 来明确关联，通常不需要。 |

**核心要点记住：在外部类的"地盘"上，它对自己的内部类拥有完全的访问权，就像家长管理自己的孩子一样自然。**