好的，我们来详细讲解**堆排序**，包括它的核心思想、算法步骤和Java实现。

## 1. 堆排序的核心思想

堆排序是一种基于**完全二叉树**（堆）的排序算法，它的巧妙之处在于：

- 先将普通数组构建成一个**最大堆**（大顶堆）
- 此时堆顶元素就是整个数组的**最大值**
- 将堆顶元素与堆的最后一个元素交换，最大值就放到了正确位置
- 排除已排序的元素，重新调整剩余元素为最大堆
- 重复这个过程，直到所有元素有序

## 2. 重要概念：什么是堆？

**堆**是一种特殊的完全二叉树，满足：
- **最大堆**：每个节点的值都**大于或等于**其子节点的值
- **最小堆**：每个节点的值都**小于或等于**其子节点的值

在数组中表示堆时，对于位置 `i` 的元素：
- 父节点位置：`(i-1)/2`
- 左子节点：`2*i + 1`
- 右子节点：`2*i + 2`

## 3. 算法步骤分解

以数组 `[4, 10, 3, 5, 1]` 为例：

### 步骤1：构建最大堆
从最后一个非叶子节点开始，自底向上调整
```
原始数组: [4, 10, 3, 5, 1]
构建后的最大堆: [10, 5, 3, 4, 1]
```

### 步骤2：排序过程
1. 交换堆顶(10)与最后一个元素(1) → `[1, 5, 3, 4, 10]`
2. 调整前4个元素为最大堆 → `[5, 4, 3, 1, 10]`
3. 交换堆顶(5)与最后一个未排序元素(1) → `[1, 4, 3, 5, 10]`
4. 调整前3个元素为最大堆 → `[4, 1, 3, 5, 10]`
5. 继续这个过程直到完全有序

## 4. Java实现

```java
public class HeapSort {

    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        System.out.println("原始数组: " + arrayToString(arr));
        
        // 步骤1：构建最大堆
        // 从最后一个非叶子节点开始向前调整
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        System.out.println("构建最大堆: " + arrayToString(arr));
        
        // 步骤2：逐个提取元素
        for (int i = n - 1; i > 0; i--) {
            // 将当前堆顶（最大值）移动到数组末尾
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            System.out.println("交换后: " + arrayToString(arr));
            
            // 调整剩余元素为最大堆
            heapify(arr, i, 0);
            System.out.println("调整堆: " + arrayToString(arr));
        }
    }
    
    /**
     * 调整堆
     * @param arr 数组
     * @param n 堆的大小（要调整的元素个数）
     * @param i 当前要调整的节点索引
     */
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;        // 假设当前节点是最大值
        int left = 2 * i + 1;   // 左子节点
        int right = 2 * i + 2;  // 右子节点
        
        // 如果左子节点存在且大于当前最大值
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        // 如果右子节点存在且大于当前最大值
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // 如果最大值不是当前节点，需要交换并继续调整
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            
            // 递归调整受影响的子树
            heapify(arr, n, largest);
        }
    }
    
    // 打印数组的辅助方法
    private static String arrayToString(int[] arr) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < arr.length; i++) {
            sb.append(arr[i]);
            if (i < arr.length - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
    
    // 测试代码
    public static void main(String[] args) {
        int[] arr = {4, 10, 3, 5, 1};
        
        System.out.println("=== 堆排序演示 ===");
        heapSort(arr);
        
        System.out.println("\n最终排序结果: " + arrayToString(arr));
    }
}
```

## 5. 简化版本（去掉详细输出）

```java
public class HeapSortSimple {
    
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 逐个提取元素
        for (int i = n - 1; i > 0; i--) {
            // 交换堆顶和末尾元素
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            // 调整剩余堆
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            heapify(arr, n, largest);
        }
    }
}
```

## 6. 算法特点

**时间复杂度：**
- 构建堆：O(n)
- 每次调整堆：O(log n)
- 总时间复杂度：O(n log n)

**空间复杂度：** O(1) - 原地排序

**优点：**
- 时间复杂度稳定在 O(n log n)
- 原地排序，不需要额外空间
- 适用于大数据集

**缺点：**
- 不稳定排序
- 常数因子较大，在小数据集中可能不如插入排序快
- 实现相对复杂

## 7. 关键理解点

1. **堆的构建**：从最后一个非叶子节点开始，自底向上调整
2. **堆的性质**：最大堆的堆顶永远是当前最大值
3. **排序过程**：每次取出堆顶，放到数组末尾，然后重新调整堆
4. **递归调整**：交换可能破坏堆性质，需要递归调整受影响的部分

堆排序是效率很高的排序算法，特别适合需要处理大量数据的场景！