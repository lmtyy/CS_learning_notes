好的，我们来详细讲解**选择排序**，并用Java实现它。

## 1. 选择排序的核心思想

选择排序就像我们整理扑克牌一样简单直观：
- 从所有牌中找出**最小的**那张，放到最左边
- 从剩下的牌中再找出**最小的**，放到左边第二的位置
- 重复这个过程，直到所有牌都排好序

## 2. 算法步骤分解

以数组 `[64, 25, 12, 22, 11]` 为例：

**第1轮：**
- 在全部元素 `[64, 25, 12, 22, 11]` 中找到最小值 `11`
- 将 `11` 与第一个元素 `64` 交换
- 结果：`[11, 25, 12, 22, 64]`

**第2轮：**
- 在剩余元素 `[25, 12, 22, 64]` 中找到最小值 `12`
- 将 `12` 与第二个元素 `25` 交换
- 结果：`[11, 12, 25, 22, 64]`

**第3轮：**
- 在剩余元素 `[25, 22, 64]` 中找到最小值 `22`
- 将 `22` 与第三个元素 `25` 交换
- 结果：`[11, 12, 22, 25, 64]`

**第4轮：**
- 在剩余元素 `[25, 64]` 中找到最小值 `25`（已在正确位置）
- 无需交换
- 最终结果：`[11, 12, 22, 25, 64]`

## 3. Java实现

```java
public class SelectionSort {
    
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        
        // 遍历所有元素（最后一个元素会自动就位）
        for (int i = 0; i < n - 1; i++) {
            // 假设当前i位置是最小值的索引
            int minIndex = i;
            
            // 在剩余元素中寻找真正的最小值
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;  // 更新最小值的索引
                }
            }
            
            // 将找到的最小值与i位置的元素交换
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
            
            // 打印每轮排序结果（可选，用于理解过程）
            System.out.print("第" + (i + 1) + "轮: ");
            printArray(arr);
        }
    }
    
    // 打印数组的辅助方法
    public static void printArray(int[] arr) {
        for (int value : arr) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
    
    // 测试代码
    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        
        System.out.println("排序前:");
        printArray(arr);
        System.out.println();
        
        selectionSort(arr);
        
        System.out.println("\n排序后:");
        printArray(arr);
    }
}
```

## 4. 运行结果

```
排序前:
64 25 12 22 11 

第1轮: 11 25 12 22 64 
第2轮: 11 12 25 22 64 
第3轮: 11 12 22 25 64 
第4轮: 11 12 22 25 64 

排序后:
11 12 22 25 64 
```

## 5. 算法特点

**时间复杂度：**
- 最好情况：O(n²)
- 最坏情况：O(n²)
- 平均情况：O(n²)

**空间复杂度：** O(1) - 原地排序

**优点：**
- 简单直观，容易理解
- 不占用额外内存
- 交换次数少，最多进行 n-1 次交换

**缺点：**
- 时间复杂度较高，不适合大数据集
- 不稳定排序（可能改变相等元素的相对顺序）

## 6. 关键理解点

1. **两层循环**：外层循环控制轮次，内层循环寻找最小值
2. **记录索引**：我们记录最小值的**索引**而不是值本身，这样交换时更高效
3. **边界条件**：外层循环到 `n-1` 即可，因为最后一个元素会自动就位

选择排序是理解排序算法的很好起点，虽然效率不高，但思想简单明了！